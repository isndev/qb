#include            "../SocketTCP.h"
#include            "../utils/branch_hints.h"

#ifdef _MSC_VER
#pragma warning(disable: 4127) // "conditional expression is constant" generated by the FD_SET macro
#endif

namespace
{
    // Define the low-level send/receive flags, which depend on the OS
#ifdef __WIN__SYSTEM__
    const int flags = 0;
#else
    constexpr const int flags = MSG_NOSIGNAL;
#endif
}

namespace           cube {
    namespace       network {

        SocketTCP::SocketTCP()
                : TSocket<Socket::TCP>() {
        }

        SocketTCP::SocketTCP(Socket::Handler fd)
            : TSocket<Socket::TCP>() {
            _handle = fd;
        }

        unsigned short SocketTCP::getLocalPort() const {
            if (good()) {
                // Retrieve informations about the local end of the socket
                sockaddr_in address;
                Socket::AddrLength size = sizeof(address);
                if (getsockname(_handle, reinterpret_cast<sockaddr *>(&address), &size) != -1) {
                    return ntohs(address.sin_port);
                }
            }

            // We failed to retrieve the port
            return 0;
        }

        ip SocketTCP::getRemoteAddress() const {
            if (good()) {
                // Retrieve informations about the remote end of the socket
                sockaddr_in address;
                Socket::AddrLength size = sizeof(address);
                if (getpeername(_handle, reinterpret_cast<sockaddr *>(&address), &size) != -1) {
                    return ip(ntohl(address.sin_addr.s_addr));
                }
            }

            // We failed to retrieve the address
            return ip::None;
        }

        unsigned short SocketTCP::getRemotePort() const {
            if (good()) {
                // Retrieve informations about the remote end of the socket
                sockaddr_in address;
                Socket::AddrLength size = sizeof(address);
                if (getpeername(_handle, reinterpret_cast<sockaddr *>(&address), &size) != -1) {
                    return ntohs(address.sin_port);
                }
            }

            // We failed to retrieve the port
            return 0;
        }

        Socket::Status SocketTCP::connect(const ip &remoteAddress, unsigned short remotePort, int timeout) {
            // Disconnect the socket if it is already connected
            disconnect();

            // Create the internal socket if it doesn't exist
            init();

            // Create the remote address
            sockaddr_in address = Socket::createAddress(remoteAddress.toInteger(), remotePort);

            if (!timeout) {
                // ----- We're not using a timeout: just try to connect -----

                // Connect the socket
                if (::connect(_handle, reinterpret_cast<sockaddr *>(&address), sizeof(address)) == -1)
                    return Socket::getErrorStatus();

                // Connection succeeded
                return Socket::Done;
            } else {
                // ----- We're using a timeout: we'll need a few tricks to make it work -----

                // Save the previous blocking state
                bool blocking = isBlocking();

                // Switch to non-blocking to enable our connection timeout
                if (blocking)
                    setBlocking(false);

                // Try to connect to the remote address
                if (::connect(_handle, reinterpret_cast<sockaddr *>(&address), sizeof(address)) >= 0) {
                    // We got instantly connected! (it may no happen a lot...)
                    setBlocking(blocking);
                    return Socket::Done;
                }

                // Get the error status
                Socket::Status status = Socket::getErrorStatus();

                // If we were in non-blocking mode, return immediately
                if (!blocking)
                    return status;

                // Otherwise, wait until something happens to our socket (success, timeout or error)
                if (status == Socket::NotReady) {
                    // Setup the selector
                    fd_set selector;
                    FD_ZERO(&selector);
                    FD_SET(_handle, &selector);

                    // Setup the timeout
                    timeval time;
                    time.tv_sec = timeout;
                    time.tv_usec = 0;

                    // Wait for something to write on our socket (which means that the connection request has returned)
                    if (select(static_cast<int>(_handle + 1), NULL, &selector, NULL, &time) > 0) {
                        // At this point the connection may have been either accepted or refused.
                        // To know whether it's a success or a failure, we must check the address of the connected peer
                        if (getRemoteAddress() != ip::None) {
                            // Connection accepted
                            status = Socket::Done;
                        } else {
                            // Connection refused
                            status = Socket::getErrorStatus();
                        }
                    } else {
                        // Failed to connect before timeout is over
                        status = Socket::getErrorStatus();
                    }
                }

                // Switch back to blocking mode
                setBlocking(true);

                return status;
            }
        }

        void SocketTCP::disconnect() {
            // Close the socket
            if (good()) {
                close();
                _handle = Socket::INVALID;
            }
        }

        Socket::Status SocketTCP::send(const void *data, std::size_t size) const {
            std::size_t sent;

            return send(data, size, sent);
        }

        Socket::Status SocketTCP::send(const void *data, std::size_t size, std::size_t &sent) const {
            sent = ::send(_handle, static_cast<const char *>(data), static_cast<int>(size), flags);
            if (unlikely(sent < 0))
                return Socket::getErrorStatus();

            return Socket::Done;
        }

        Socket::Status SocketTCP::sendall(const void *data, std::size_t size, std::size_t &sent) const {
            // Loop until every byte has been sent
            int result = 0;
            for (sent = 0; sent < size; sent += result) {
                // Send a chunk of data
                result = ::send(_handle, static_cast<const char *>(data) + sent, static_cast<int>(size - sent), flags);

                // Check for errors
                if (result < 0) {
                    Socket::Status status = Socket::getErrorStatus();

                    if ((status == Socket::NotReady) && sent)
                        return Socket::Partial;

                    return status;
                }
            }

            return Socket::Done;
        }

        Socket::Status SocketTCP::receive(void *data, std::size_t size, std::size_t &received) const {
            // First clear the variables to fill
            received = 0;

            // Receive a chunk of bytes
            int sizeReceived = recv(_handle, static_cast<char *>(data), static_cast<int>(size), flags);

            // Check the number of bytes received
            if (sizeReceived > 0) {
                received = static_cast<std::size_t>(sizeReceived);
                return Socket::Done;
            } else if (sizeReceived == 0) {
                return Socket::Disconnected;
            } else {
                return Socket::getErrorStatus();
            }
        }

    } // namespace network
} // namespace cube
