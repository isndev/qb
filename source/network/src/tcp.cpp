/*
 * qb - C++ Actor Framework
 * Copyright (C) 2011-2019 isndev (www.qbaf.io). All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 *         limitations under the License.
 */

#include            <qb/utility/branch_hints.h>
#include            <qb/network/tcp.h>

#ifdef _MSC_VER
#pragma warning(disable: 4127) // "conditional expression is constant" generated by the FD_SET macro
#endif

namespace
{
    // Define the low-level send/receive flags, which depend on the OS
#ifdef __WIN__SYSTEM__
    const int flags = 0;
#else
    constexpr const int flags = MSG_NOSIGNAL;
#endif
}

namespace           qb {
    namespace       network {
        namespace   tcp {

            Socket::Socket()
                    : sys::Socket<SocketType::TCP>() {
            }

            Socket::Socket(SocketHandler fd)
                    : sys::Socket<SocketType::TCP>() {
                _handle = fd;
            }

            unsigned short Socket::getLocalPort() const {
                if (good()) {
                    // Retrieve informations about the local end of the Socket
                    sockaddr_in address;
                    AddrLength size = sizeof(address);
                    if (getsockname(_handle, reinterpret_cast<sockaddr *>(&address), &size) != -1) {
                        return ntohs(address.sin_port);
                    }
                }

                // We failed to retrieve the port
                return 0;
            }

            ip Socket::getRemoteAddress() const {
                if (good()) {
                    // Retrieve informations about the remote end of the socket
                    sockaddr_in address;
                    AddrLength size = sizeof(address);
                    if (getpeername(_handle, reinterpret_cast<sockaddr *>(&address), &size) != -1) {
                        return ip(ntohl(address.sin_addr.s_addr));
                    }
                }

                // We failed to retrieve the address
                return ip::None;
            }

            unsigned short Socket::getRemotePort() const {
                if (good()) {
                    // Retrieve informations about the remote end of the socket
                    sockaddr_in address;
                    AddrLength size = sizeof(address);
                    if (getpeername(_handle, reinterpret_cast<sockaddr *>(&address), &size) != -1) {
                        return ntohs(address.sin_port);
                    }
                }

                // We failed to retrieve the port
                return 0;
            }

            SocketStatus Socket::connect(const ip &remoteAddress, unsigned short remotePort, int timeout) {
                // Disconnect the socket if it is already connected
                disconnect();

                // Create the internal socket if it doesn't exist
                init();

                // Create the remote address
                sockaddr_in address = helper::createAddress(remoteAddress.toInteger(), remotePort);

                if (!timeout) {
                    // ----- We're not using a timeout: just try to connect -----

                    // Connect the socket
                    if (::connect(_handle, reinterpret_cast<sockaddr *>(&address), sizeof(address)) == -1)
                        return helper::getErrorStatus();

                    // Connection succeeded
                    return SocketStatus::Done;
                } else {
                    // ----- We're using a timeout: we'll need a few tricks to make it work -----

                    // Save the previous blocking state
                    bool blocking = isBlocking();

                    // Switch to non-blocking to enable our connection timeout
                    if (blocking)
                        setBlocking(false);

                    // Try to connect to the remote address
                    if (::connect(_handle, reinterpret_cast<sockaddr *>(&address), sizeof(address)) >= 0) {
                        // We got instantly connected! (it may no happen a lot...)
                        setBlocking(blocking);
                        return SocketStatus::Done;
                    }

                    // Get the error status
                    SocketStatus status = helper::getErrorStatus();

                    // If we were in non-blocking mode, return immediately
                    if (!blocking)
                        return status;

                    // Otherwise, wait until something happens to our socket (success, timeout or error)
                    if (status == SocketStatus::NotReady) {
                        // Setup the selector
                        fd_set selector;
                        FD_ZERO(&selector);
                        FD_SET(_handle, &selector);

                        // Setup the timeout
                        timeval time;
                        time.tv_sec = timeout;
                        time.tv_usec = 0;

                        // Wait for something to write on our socket (which means that the connection request has returned)
                        if (select(static_cast<int>(_handle + 1), NULL, &selector, NULL, &time) > 0) {
                            // At this point the connection may have been either accepted or refused.
                            // To know whether it's a success or a failure, we must check the address of the connected peer
                            if (getRemoteAddress() != ip::None) {
                                // Connection accepted
                                status = SocketStatus::Done;
                            } else {
                                // Connection refused
                                status = helper::getErrorStatus();
                            }
                        } else {
                            // Failed to connect before timeout is over
                            status = helper::getErrorStatus();
                        }
                    }

                    // Switch back to blocking mode
                    setBlocking(true);

                    return status;
                }
            }

            void Socket::disconnect() {
                // Close the socket
                if (good()) {
                    close();
                    _handle = SOCKET_INVALID;
                }
            }

            network::SocketStatus Socket::send(const void *data, std::size_t size) const {
                std::size_t sent;

                return send(data, size, sent);
            }

            SocketStatus Socket::send(const void *data, std::size_t size, std::size_t &sent) const {
                int result = ::send(_handle, static_cast<const char *>(data), static_cast<int>(size), flags);
                if (unlikely(result < 0))
                    return helper::getErrorStatus();
                sent = result;
                return SocketStatus::Done;
            }

            SocketStatus Socket::sendall(const void *data, std::size_t size, std::size_t &sent) const {
                // Loop until every byte has been sent
                int result = 0;
                for (sent = 0; sent < size; sent += result) {
                    // Send a chunk of data
                    result = ::send(_handle, static_cast<const char *>(data) + sent, static_cast<int>(size - sent),
                                    flags);

                    // Check for errors
                    if (result < 0) {
                        SocketStatus status = helper::getErrorStatus();

                        if ((status == SocketStatus::NotReady) && sent)
                            return SocketStatus::Partial;

                        return status;
                    }
                }

                return SocketStatus::Done;
            }

            SocketStatus Socket::receive(void *data, std::size_t size, std::size_t &received) const {
                // First clear the variables to fill
                received = 0;

                // Receive a chunk of bytes
                int sizeReceived = recv(_handle, static_cast<char *>(data), static_cast<int>(size), flags);

                // Check the number of bytes received
                if (sizeReceived > 0) {
                    received = static_cast<std::size_t>(sizeReceived);
                    return SocketStatus::Done;
                } else if (sizeReceived == 0) {
                    return SocketStatus::Disconnected;
                } else {
                    return helper::getErrorStatus();
                }
            }

            Listener::Listener()
                    : Socket()
            {}

            Listener::~Listener() {
                close();
            }

            unsigned short Listener::getLocalPort() const
            {
                if (good())
                {
                    // Retrieve informations about the local end of the socket
                    sockaddr_in address;
                    AddrLength size = sizeof(address);
                    if (getsockname(_handle, reinterpret_cast<sockaddr*>(&address), &size) != -1)
                    {
                        return ntohs(address.sin_port);
                    }
                }

                // We failed to retrieve the port
                return 0;
            }

            SocketStatus Listener::listen(unsigned short port, const ip& address)
            {
                // Close the socket if it is already bound
                close();

                // init the internal socket if it doesn't exist
                init();

#ifdef __LINUX__SYSTEM__
                int Yes = 1;
                setsockopt(_handle, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<char*>(&Yes), sizeof(Yes));
#endif
                // Check if the address is valid
                if ((address == ip::None)) {
                    _handle = SOCKET_INVALID;
                    return SocketStatus::Error;
                }

                // Bind the socket to the specified port
                sockaddr_in addr = helper::createAddress(address.toInteger(), port);
                if (bind(_handle, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) == -1)
                {
                    _handle = SOCKET_INVALID;
                    // Not likely to happen, but...
                    std::cerr << "Failed to bind listener socket to port " << port << std::endl;
                    return SocketStatus::Error;
                }

                // Listen to the bound port
                if (::listen(_handle, SOMAXCONN) == -1)
                {
                    close();
                    _handle = SOCKET_INVALID;
                    // Oops, socket is deaf
                    std::cerr << "Failed to listen to port " << port << std::endl;
                    return SocketStatus::Error;
                }

                return SocketStatus::Done;
            }

            SocketStatus Listener::accept(Socket& sock)
            {
                // Make sure that we're listening
                if (!good())
                {
                    std::cerr << "Failed to accept a new connection, the socket is not listening" << std::endl;
                    return SocketStatus::Error;
                }

                // Accept a new connection
                sockaddr_in address;
                AddrLength length = sizeof(address);
                SocketHandler remote = ::accept(_handle, reinterpret_cast<sockaddr*>(&address), &length);

                // Check for errors
                if (remote == SOCKET_INVALID)
                    return helper::getErrorStatus();

                // Initialize the new connected socket
                sock.close();
                sock.init(remote);

                return SocketStatus::Done;
            }

        } // namespace socket
    } // namespace network
} // namespace qb
