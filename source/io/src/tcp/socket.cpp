/*
 * qb - C++ Actor Framework
 * Copyright (C) 2011-2019 isndev (www.qbaf.io). All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 *         limitations under the License.
 */

#include            <qb/utility/branch_hints.h>
#include            <qb/io/tcp/socket.h>

#ifdef _MSC_VER
#pragma warning(disable: 4127) // "conditional expression is constant" generated by the FD_SET macro
#endif

namespace {
    // Define the low-level send/receive flags, which depend on the OS
#if defined(__WIN__SYSTEM__) || defined(__APPLE__)
    const int flags = 0;
#else
    constexpr const int flags = MSG_NOSIGNAL;
#endif
}

namespace qb {
    namespace io {
        namespace tcp {

            socket::socket()
                    : sys::socket<SocketType::TCP>() {
            }

//            socket::socket(SocketHandler fd)
//                    : sys::socket<SocketType::TCP>() {
//                _handle = fd;
//            }

            unsigned short socket::getLocalPort() const {
                if (good()) {
                    // Retrieve informations about the local end of the socket
                    sockaddr_in address;
                    AddrLength size = sizeof(address);
                    if (getsockname(_handle, reinterpret_cast<sockaddr *>(&address), &size) != -1) {
                        return ntohs(address.sin_port);
                    }
                }

                // We failed to retrieve the port
                return 0;
            }

            ip socket::getRemoteAddress() const {
                if (good()) {
                    // Retrieve informations about the remote end of the socket
                    sockaddr_in address;
                    AddrLength size = sizeof(address);
                    if (getpeername(_handle, reinterpret_cast<sockaddr *>(&address), &size) != -1) {
                        return ip(ntohl(address.sin_addr.s_addr));
                    }
                }

                // We failed to retrieve the address
                return ip::None;
            }

            unsigned short socket::getRemotePort() const {
                if (good()) {
                    // Retrieve informations about the remote end of the socket
                    sockaddr_in address;
                    AddrLength size = sizeof(address);
                    if (getpeername(_handle, reinterpret_cast<sockaddr *>(&address), &size) != -1) {
                        return ntohs(address.sin_port);
                    }
                }

                // We failed to retrieve the port
                return 0;
            }

            SocketStatus socket::connect(const ip &remoteAddress, unsigned short remotePort, int timeout) {
                // Disconnect the socket if it is already connected
                disconnect();

                // Create the internal socket if it doesn't exist
                init();

                // Create the remote address
                sockaddr_in address = helper::createAddress(remoteAddress.toInteger(), remotePort);

                if (!timeout) {
                    // ----- We're not using a timeout: just try to connect -----

                    // Connect the socket
                    if (::connect(_handle, reinterpret_cast<sockaddr *>(&address), sizeof(address)) == -1)
                        return helper::getErrorStatus();

                    // Connection succeeded
                    return SocketStatus::Done;
                } else {
                    // ----- We're using a timeout: we'll need a few tricks to make it work -----

                    // Save the previous blocking state
                    bool blocking = isBlocking();

                    // Switch to non-blocking to enable our connection timeout
                    if (blocking)
                        setBlocking(false);

                    // Try to connect to the remote address
                    if (::connect(_handle, reinterpret_cast<sockaddr *>(&address), sizeof(address)) >= 0) {
                        // We got instantly connected! (it may no happen a lot...)
                        setBlocking(blocking);
                        return SocketStatus::Done;
                    }

                    // Get the error status
                    SocketStatus status = helper::getErrorStatus();

                    // If we were in non-blocking mode, return immediately
                    if (!blocking)
                        return status;

                    // Otherwise, wait until something happens to our socket (success, timeout or error)
                    if (status == SocketStatus::NotReady) {
                        // Setup the selector
                        fd_set selector;
                        FD_ZERO(&selector);
                        FD_SET(_handle, &selector);

                        // Setup the timeout
                        timeval time;
                        time.tv_sec = timeout;
                        time.tv_usec = 0;

                        // Wait for something to write on our socket (which means that the connection request has returned)
                        if (select(static_cast<int>(_handle + 1), NULL, &selector, NULL, &time) > 0) {
                            // At this point the connection may have been either accepted or refused.
                            // To know whether it's a success or a failure, we must check the address of the connected peer
                            if (getRemoteAddress() != ip::None) {
                                // Connection accepted
                                status = SocketStatus::Done;
                            } else {
                                // Connection refused
                                status = helper::getErrorStatus();
                            }
                        } else {
                            // Failed to connect before timeout is over
                            status = helper::getErrorStatus();
                        }
                    }

                    // Switch back to blocking mode
                    setBlocking(true);

                    return status;
                }
            }

            void socket::disconnect() {
                // Close the socket
                if (good()) {
                    close();
                    _handle = SOCKET_INVALID;
                }
            }

            int socket::read(void *data, std::size_t size) const {
                const auto ret = ::recv(_handle, static_cast<char *>(data), static_cast<int>(size), flags);
                return ret ? ret : -1;
            }

            int socket::write(const void *data, std::size_t size) const {
                return ::send(_handle, static_cast<const char *>(data), static_cast<int>(size), flags);
            }

        } // namespace tcp
    } // namespace io
} // namespace qb
