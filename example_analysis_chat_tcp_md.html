<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <head>
        <meta http-equiv="cache-control" content="max-age=86400"/>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta http-equiv="X-UA-Compatible" content="IE=9"/>
        <meta name="generator" content="Doxygen 1.14.0"/>
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <title>qb: Case Study: Building a TCP Chat System with QB Actors</title>
        <meta name="description" content="qb OpenSource C++17 Actor Framework Documentation, all API detailed">
        <meta name="keywords"
              content="qb, cube, actor, framework, actor framework, opensource, cpp, c++, cpp17, c++17, documentation, docs, git">
        <meta name="author" content="isndev">
        <!-- BEGIN opengraph metadata -->
<!--        <meta property="og:title" content="Doxygen Awesome"/>-->
<!--        <meta property="og:image"-->
<!--              content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>-->
<!--        <meta property="og:description"-->
<!--              content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>-->
<!--        <meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/"/>-->
        <!-- END opengraph metadata -->
        <!-- BEGIN twitter metadata -->
<!--        <meta name="twitter:image:src"-->
<!--              content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>-->
<!--        <meta name="twitter:title" content="Doxygen Awesome"/>-->
<!--        <meta name="twitter:description"-->
<!--              content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>-->
        <!-- END twitter metadata -->
        <title>qb: Case Study: Building a TCP Chat System with QB Actors</title>
        <link href="tabs.css" rel="stylesheet" type="text/css"/>
        <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
        <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
        <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
        <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
        <script type="text/javascript" src="toggle-alternative-theme.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeFragmentCopyButton.init()
            DoxygenAwesomeDarkModeToggle.init()
            DoxygenAwesomeParagraphLink.init()
            DoxygenAwesomeInteractiveToc.init()
            DoxygenAwesomeTabs.init()
        </script>
        <script async defer src="https://buttons.github.io/buttons.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css"/>
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
    </head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/isndev/qb" class="github-corner" title="View source on GitHub"
   target="_blank" rel="noopener noreferrer">
    <svg viewBox="0 0 250 250" width="40" height="40"
         style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
<style>.github-corner:hover .octo-arm {
    animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
    0%, 100% {
        transform: rotate(0)
    }
    20%, 60% {
        transform: rotate(-25deg)
    }
    40%, 80% {
        transform: rotate(10deg)
    }
}
@media (max-width: 500px) {
    .github-corner:hover .octo-arm {
        animation: none
    }
    .github-corner .octo-arm {
        animation: octocat-wave 560ms ease-in-out
    }
}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
            <tr style="height: 56px;">
                <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
                <td id="projectalign" style="padding-left: 0.5em;">
                    <div id="projectname">qb
                        &#160;<span id="projectnumber">2.0.0.0</span>
                    </div>
                    <div id="projectbrief">C++17 Actor Framework</div>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
    <div style="padding-left: 0.5em;">
        <a class="navbar-brand" href="https://github.com/isndev/qb">
            <img src="GitHub-Mark-64px.png" width="32px" alt="qb">
        </a>
        <a class="github-button" href="https://github.com/isndev/qb/issues" data-icon="octicon-issue-opened" data-size="large" data-show-count="true" aria-label="Issue isndev/qb on GitHub">Issue</a>
        <a class="github-button" href="https://github.com/isndev/qb/subscription" data-icon="octicon-eye" data-size="large" data-show-count="true" aria-label="Watch isndev/qb on GitHub">Watch</a>
        <a class="github-button" href="https://github.com/isndev/qb" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star isndev/qb on GitHub">Star</a>
        <a class="github-button" href="https://github.com/isndev/qb/fork" data-icon="octicon-repo-forked" data-size="large" data-show-count="true" aria-label="Fork isndev/qb on GitHub">Fork</a>
        <a class="github-button" href="https://github.com/isndev" data-size="large" data-show-count="false" aria-label="Follow @isndev on GitHub">Follow @isndev</a>
    </div>
    <!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('example_analysis_chat_tcp_md.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Case Study: Building a TCP Chat System with QB Actors </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A step-by-step analysis of the <span class="tt">chat_tcp</span> example, showcasing actor-based TCP client/server development, protocol handling, and session management in QB.</p>
<h1>Case Study: Building a TCP Chat System with QB Actors</h1>
<ul>
<li><b>Location:</b> <span class="tt">example/core_io/chat_tcp/</span></li>
<li><b>Objective:</b> This example demonstrates how to construct a classic client-server TCP chat application using the QB Actor Framework. It's an excellent case study for understanding how actors manage network connections, handle custom communication protocols, manage user sessions, and distribute workload across multiple cores.</li>
</ul>
<p>By dissecting this example, you'll see practical applications of:</p><ul>
<li>Asynchronous TCP client and server patterns using <span class="tt"><a class="el" href="structqb_1_1io_1_1use.html" title="Helper template providing type aliases for integrating qb-io asynchronous components.">qb::io::use</a>&lt;&gt;</span>.</li>
<li>Custom protocol definition for message framing (<span class="tt">ChatProtocol</span>).</li>
<li>Actor-based session management.</li>
<li>Inter-actor communication for application logic.</li>
<li>Multi-core actor distribution.</li>
</ul>
<h2>Server-Side Architecture: A Multi-Core Design</h2>
<p>The <span class="tt">chat_server</span> employs a distributed architecture, separating responsibilities across actors typically running on different <span class="tt">VirtualCore</span>s for scalability.</p>
<h3>1. <span class="tt">AcceptActor</span>: The Connection Gateway</h3>
<ul>
<li><b>Header:</b> <span class="tt">server/AcceptActor.h</span>, <span class="tt">server/AcceptActor.cpp</span></li>
<li><b>Core Assignment (Typical):</b> Core 0 (dedicated to accepting new connections).</li>
<li><b>Role:</b> Listens for incoming TCP connections on one or more network ports.</li>
<li><b>QB Integration:</b> Inherits from <span class="tt"><a class="el" href="classqb_1_1_actor.html" title="Base class for all actors in the qb framework.">qb::Actor</a></span> and <span class="tt"><a class="el" href="structqb_1_1io_1_1use.html" title="Helper template providing type aliases for integrating qb-io asynchronous components.">qb::io::use</a>&lt;AcceptActor&gt;::tcp::acceptor</span>.<ul>
<li>The <span class="tt">tcp::acceptor</span> base provides the <span class="tt">transport()</span> method (a <span class="tt"><a class="el" href="classqb_1_1io_1_1tcp_1_1listener.html" title="Class implementing a TCP listener for accepting incoming connections.">qb::io::tcp::listener</a></span>) and handles the low-level asynchronous accept operations.</li>
</ul>
</li>
<li><b>Initialization (<span class="tt">onInit()</span>): <span class="tt">cpp
    // Inside AcceptActor::onInit()
    for (const auto&amp; uri_str : _listen_uris) {
        <a class="el" href="classqb_1_1io_1_1uri.html" title="Class for parsing, manipulating, and representing URIs.">qb::io::uri</a> u(uri_str.c_str());
        if (this-&gt;transport().listen(u) != 0) { /* error handling */ }
    }
    this-&gt;start(); // Start the internal async::input mechanism of the acceptor base
    </span> It configures its <span class="tt"><a class="el" href="classqb_1_1io_1_1tcp_1_1listener.html" title="Class implementing a TCP listener for accepting incoming connections.">qb::io::tcp::listener</a></span> (via <span class="tt">this-&gt;transport()</span>) to listen on specified URIs (e.g., "tcp://0.0.0.0:3001"). <span class="tt">this-&gt;start()</span> activates the underlying event loop monitoring for new connections.</b></li>
<li><b> **Handling New Connections (<span class="tt">on(accepted_socket_type&amp;&amp; new_io)</span>): <span class="tt">cpp
    // Inside AcceptActor::on(accepted_socket_type&amp;&amp; new_io)
    if (!_server_pool.empty()) {
        <a class="el" href="classqb_1_1_actor_id.html" title="Unique identifier for actors.">qb::ActorId</a> target_server = _server_pool[_session_counter % _server_pool.size()];
        _session_counter++;
        push&lt;NewSessionEvent&gt;(target_server, std::move(new_io));
    }
    </span> When a TCP connection is accepted by the <span class="tt">listener</span>, this method is invoked by the <span class="tt">tcp::acceptor</span> base. <span class="tt">new_io</span> is a <span class="tt"><a class="el" href="classqb_1_1io_1_1tcp_1_1socket.html" title="Class implementing TCP socket functionality for reliable, stream-oriented communication.">qb::io::tcp::socket</a></span> representing the newly connected client. The <span class="tt">AcceptActor</span> then dispatches this new socket to one of the <span class="tt">ServerActor</span> instances (from <span class="tt">_server_pool</span>) using a round-robin strategy, wrapping the socket in a <span class="tt">NewSessionEvent</span>.</b></li>
<li><b> **Shutdown:</b> Its <span class="tt">on(<a class="el" href="structqb_1_1io_1_1async_1_1event_1_1disconnected.html" title="Event triggered when a connection is closed or lost.">qb::io::async::event::disconnected</a> const&amp;)</span> handler for the listener socket (if it gets closed or errors out) triggers a broadcast of <span class="tt"><a class="el" href="structqb_1_1_kill_event.html" title="Event used to terminate an actor.">qb::KillEvent</a></span> to gracefully shut down other server components.</li>
</ul>
<h3>2. <span class="tt">ServerActor</span>: The Session Manager</h3>
<ul>
<li><b>Header:</b> <span class="tt">server/ServerActor.h</span>, <span class="tt">server/ServerActor.cpp</span></li>
<li><b>Core Assignment (Typical):</b> Core 1 (or a pool of <span class="tt">ServerActor</span>s across multiple cores, e.g., cores 1 &amp; 2).</li>
<li><b>Role:</b> Manages a collection of active client connections (<span class="tt">ChatSession</span> instances). It acts as a bridge between individual client sessions and the central <span class="tt">ChatRoomActor</span>.</li>
<li><b>QB Integration:</b> Inherits from <span class="tt"><a class="el" href="classqb_1_1_actor.html" title="Base class for all actors in the qb framework.">qb::Actor</a></span> and <span class="tt"><a class="el" href="structqb_1_1io_1_1use.html" title="Helper template providing type aliases for integrating qb-io asynchronous components.">qb::io::use</a>&lt;ServerActor&gt;::tcp::server&lt;ChatSession&gt;</span>.<ul>
<li>The <span class="tt">tcp::server&lt;ChatSession&gt;</span> base provides the <span class="tt">io_handler</span> functionality, automatically managing a map of <span class="tt">ChatSession</span> objects (keyed by <span class="tt"><a class="el" href="uuid_8h.html#acd92a3e374d3cbc05094c4f6a8b547a1" title="UUID type alias for the underlying implementation.">qb::uuid</a></span>).</li>
</ul>
</li>
<li>**Handling New Sessions (<span class="tt">on(NewSessionEvent&amp;)</span>): <span class="tt">cpp
    // Inside ServerActor::on(NewSessionEvent&amp; evt)
    auto&amp; session = registerSession(std::move(evt.socket));
    // session is a ChatSession&amp;
    // The registerSession method (from io_handler base) creates a ChatSession,
    // associates the socket, starts its I/O, and adds it to the managed session map.
    </span> Receives the <span class="tt">NewSessionEvent</span> from an <span class="tt">AcceptActor</span>. The <span class="tt">registerSession(std::move(evt.socket))</span> call (provided by the <span class="tt">io_handler</span> part of its base) instantiates a <span class="tt">ChatSession</span>, associates the client's socket with it, starts its asynchronous I/O operations, and adds it to an internal session map.</li>
<li>**Message Routing (from <span class="tt">ChatSession</span> to <span class="tt">ChatRoomActor</span>):<ul>
<li><span class="tt">ChatSession</span> calls methods like <span class="tt">server().handleAuth(id(), username)</span> on its managing <span class="tt">ServerActor</span>.</li>
<li><span class="tt">ServerActor</span> then creates specific events (e.g., <span class="tt">AuthEvent</span>, <span class="tt">ChatEvent</span>) and <span class="tt">push</span>es them to the <span class="tt">ChatRoomActor</span>.</li>
</ul>
</li>
<li>**Message Routing (from <span class="tt">ChatRoomActor</span> to <span class="tt">ChatSession</span>): <span class="tt">cpp
    // Inside ServerActor::on(SendMessageEvent&amp; evt)
    auto session_ptr = sessions().find(evt.target_session_id);
    if (session_ptr != sessions().end() &amp;&amp; session_ptr-&gt;second) {
        // Send the raw message content using the session's output stream
        *(session_ptr-&gt;second) &lt;&lt; evt.message_container.message().payload;
    }
    </span> Receives <span class="tt">SendMessageEvent</span> from <span class="tt">ChatRoomActor</span>. It looks up the target <span class="tt">ChatSession</span> in its session map and sends the message payload directly to the client using the session's <span class="tt">operator&lt;&lt;</span> (which uses <span class="tt">publish()</span>).</li>
<li>**Client Disconnects (<span class="tt">handleDisconnect(qb::uuid session_id)</span>):<ul>
<li>Called by a <span class="tt">ChatSession</span> when its connection drops. Forwards a <span class="tt">DisconnectEvent</span> to the <span class="tt">ChatRoomActor</span>.</li>
</ul>
</li>
</ul>
<h3>3. <span class="tt">ChatSession</span>: The Client Connection Handler</h3>
<ul>
<li><b>Header:</b> <span class="tt">server/ChatSession.h</span>, <span class="tt">server/ChatSession.cpp</span></li>
<li><b>Context:</b> Instantiated and managed by a <span class="tt">ServerActor</span>, runs on the same <span class="tt">VirtualCore</span> as its managing <span class="tt">ServerActor</span>.</li>
<li><b>Role:</b> Represents and handles all I/O and protocol parsing for a single connected client.</li>
<li><b>QB Integration:</b> Inherits from <span class="tt"><a class="el" href="structqb_1_1io_1_1use.html" title="Helper template providing type aliases for integrating qb-io asynchronous components.">qb::io::use</a>&lt;ChatSession&gt;::tcp::client&lt;ServerActor&gt;</span> and <span class="tt"><a class="el" href="structqb_1_1io_1_1use.html" title="Helper template providing type aliases for integrating qb-io asynchronous components.">qb::io::use</a>&lt;ChatSession&gt;::timeout</span>.<ul>
<li><span class="tt">tcp::client&lt;ServerActor&gt;</span>: Provides the TCP transport and stream capabilities. The <span class="tt">ServerActor</span> template argument allows the session to call back to its manager (e.g., <span class="tt">server().handleAuth(...)</span>).</li>
<li><span class="tt">timeout</span>: Adds inactivity timeout functionality.</li>
</ul>
</li>
<li><b>Protocol Handling:</b><ul>
<li><span class="tt">using Protocol = chat::ChatProtocol&lt;ChatSession&gt;;</span> (defined in <span class="tt">shared/Protocol.h</span>).</li>
<li>The constructor calls <span class="tt">this-&gt;template switch_protocol&lt;Protocol&gt;(*this);</span> to activate the custom protocol.</li>
<li><span class="tt">on(chat::Message&amp; msg)</span>: This method is invoked by the framework when the <span class="tt">ChatProtocol</span> successfully parses a complete message from the client. Based on <span class="tt">msg.type</span> (<span class="tt">AUTH_REQUEST</span>, <span class="tt">CHAT_MESSAGE</span>), it calls the appropriate <span class="tt">handleAuth(...)</span> or <span class="tt">handleChat(...)</span> method on its parent <span class="tt">ServerActor</span> instance (accessed via <span class="tt">server()</span>).</li>
</ul>
</li>
<li><b>Lifecycle Events:</b><ul>
<li><span class="tt">on(<a class="el" href="structqb_1_1io_1_1async_1_1event_1_1disconnected.html" title="Event triggered when a connection is closed or lost.">qb::io::async::event::disconnected</a> const&amp;)</span>: Handles socket disconnection. Calls <span class="tt">server().handleDisconnect(this-&gt;id())</span>.</li>
<li><span class="tt">on(<a class="el" href="structqb_1_1io_1_1async_1_1event_1_1timer.html" title="Event for handling time-based operations (timers and timeouts).">qb::io::async::event::timer</a> const&amp;)</span>: Handles inactivity timeout. Also calls <span class="tt">server().handleDisconnect(this-&gt;id())</span>.</li>
</ul>
</li>
</ul>
<h3>4. <span class="tt">ChatRoomActor</span>: The Central Application Logic</h3>
<ul>
<li><b>Header:</b> <span class="tt">server/ChatRoomActor.h</span>, <span class="tt">server/ChatRoomActor.cpp</span></li>
<li><b>Core Assignment (Typical):</b> Core 3 (a separate core for application logic).</li>
<li><b>Role:</b> Manages the chat room's state, including the list of authenticated users and their associated <span class="tt">ServerActor</span> (for routing replies). It handles authentication, message broadcasting, and user presence.</li>
<li><b>State:</b><ul>
<li><span class="tt">_sessions</span>: A map from <span class="tt"><a class="el" href="uuid_8h.html#acd92a3e374d3cbc05094c4f6a8b547a1" title="UUID type alias for the underlying implementation.">qb::uuid</a></span> (client session ID) to <span class="tt">SessionInfo { <a class="el" href="classqb_1_1_actor_id.html" title="Unique identifier for actors.">qb::ActorId</a> server_id, <a class="el" href="classqb_1_1string.html" title="Fixed-size string with optimized storage.">qb::string</a> username }</span>.</li>
<li><span class="tt">_usernames</span>: A map from <span class="tt"><a class="el" href="classqb_1_1string.html" title="Fixed-size string with optimized storage.">qb::string</a> username</span> to <span class="tt"><a class="el" href="uuid_8h.html#acd92a3e374d3cbc05094c4f6a8b547a1" title="UUID type alias for the underlying implementation.">qb::uuid</a></span> for quick lookup.</li>
</ul>
</li>
<li><b>Event Handlers:</b><ul>
<li><span class="tt">on(AuthEvent&amp;)</span>: Validates username. If valid, stores session info, sends an <span class="tt">AUTH_RESPONSE</span> (<span class="tt">chat::MessageType::RESPONSE</span>) back to the specific client via the correct <span class="tt">ServerActor</span> (using <span class="tt">push&lt;SendMessageEvent&gt;(evt.server_id, ...)</span>), and broadcasts a join message to all other clients.</li>
<li><span class="tt">on(ChatEvent&amp;)</span>: Retrieves the username for the sending session. Formats the chat message (e.g., "username: message_content"). Broadcasts this formatted message to all connected clients via their respective <span class="tt">ServerActor</span>s.</li>
<li><span class="tt">on(DisconnectEvent&amp;)</span>: Removes the user and session information from its state maps. Broadcasts a leave message to remaining clients.</li>
</ul>
</li>
<li><b>Message Broadcasting (<span class="tt">broadcastMessage</span>, <span class="tt">sendToSession</span> helpers):</b> These methods iterate through the <span class="tt">_sessions</span> map and <span class="tt">push</span> a <span class="tt">SendMessageEvent</span> to the appropriate <span class="tt">ServerActor</span> for each recipient. The <span class="tt">SendMessageEvent</span> contains the <span class="tt"><a class="el" href="uuid_8h.html#acd92a3e374d3cbc05094c4f6a8b547a1" title="UUID type alias for the underlying implementation.">qb::uuid</a></span> of the target <span class="tt">ChatSession</span> and the message payload (as a <span class="tt">chat::MessageContainer</span>, which uses <span class="tt">std::shared_ptr</span> for efficient sharing of message data).</li>
</ul>
<h2>Client-Side Architecture: <span class="tt">chat_client</span></h2>
<p>The client is simpler, typically running actors on fewer cores.</p>
<h3>1. <span class="tt">InputActor</span>: Console Input Handler</h3>
<ul>
<li><b>Header:</b> <span class="tt">client/InputActor.h</span>, <span class="tt">client/InputActor.cpp</span></li>
<li><b>Core Assignment (Typical):</b> Core 0.</li>
<li><b>Role:</b> Reads user input from the console asynchronously.</li>
<li><b>QB Integration:</b> Inherits from <span class="tt"><a class="el" href="classqb_1_1_actor.html" title="Base class for all actors in the qb framework.">qb::Actor</a></span> and <span class="tt"><a class="el" href="classqb_1_1_i_callback.html" title="Interface for actor callbacks.">qb::ICallback</a></span>.</li>
<li><b>Functionality (<span class="tt">onCallback()</span>):</b> Uses <span class="tt">std::getline(std::cin, line)</span> (note: <span class="tt">std::cin</span> itself can be blocking if not handled carefully, though <span class="tt">onCallback</span> is non-blocking with respect to other actors). If the input is "quit", it sends a <span class="tt"><a class="el" href="structqb_1_1_kill_event.html" title="Event used to terminate an actor.">qb::KillEvent</a></span> to the <span class="tt">ClientActor</span>. Otherwise, it <span class="tt">push</span>es a <span class="tt">ChatInputEvent</span> (containing the raw input string) to the <span class="tt">ClientActor</span>.</li>
</ul>
<h3>2. <span class="tt">ClientActor</span>: Network Communication &amp; UI Display</h3>
<ul>
<li><b>Header:</b> <span class="tt">client/ClientActor.h</span>, <span class="tt">client/ClientActor.cpp</span></li>
<li><b>Core Assignment (Typical):</b> Core 1.</li>
<li><b>Role:</b> Manages the TCP connection to the server, sends user messages, and displays incoming chat messages to the console.</li>
<li><b>QB Integration:</b> Inherits from <span class="tt"><a class="el" href="classqb_1_1_actor.html" title="Base class for all actors in the qb framework.">qb::Actor</a></span> and <span class="tt"><a class="el" href="structqb_1_1io_1_1use.html" title="Helper template providing type aliases for integrating qb-io asynchronous components.">qb::io::use</a>&lt;ClientActor&gt;::tcp::client&lt;&gt;</span>.</li>
<li><b>Protocol:</b> <span class="tt">using Protocol = chat::ChatProtocol&lt;ClientActor&gt;;</span>.</li>
<li><b>Connection (<span class="tt">onInit()</span> and connection callback):<ul>
<li>Uses <span class="tt"><a class="el" href="connector_8h.html#ad0a3210805ff5e6d0b92b7c8eb051d68" title="Initiates an asynchronous TCP connection.">qb::io::async::tcp::connect</a></span> to establish a non-blocking connection to the server URI.</li>
<li>The callback lambda, upon successful TCP connection, moves the new socket into <span class="tt">this-&gt;transport().transport()</span>, switches to the <span class="tt">ChatProtocol</span> (<span class="tt">this-&gt;template switch_protocol&lt;Protocol&gt;(*this);</span>), starts I/O event monitoring (<span class="tt">this-&gt;start();</span>), and then sends an initial <span class="tt">AUTH_REQUEST</span> message to the server.</li>
<li>If connection fails, it uses <span class="tt"><a class="el" href="group___async.html#ga79acd187eb2aeb629523ebb206ee004d" title="Utility function to schedule a callable for execution after a timeout.">qb::io::async::callback</a></span> to schedule a reconnection attempt.</li>
</ul>
</b></li>
<li><b> **Event Handling:</b><ul>
<li><span class="tt">on(ChatInputEvent&amp;)</span>: Receives raw command strings from <span class="tt">InputActor</span>. If connected and authenticated, formats them into <span class="tt">chat::Message</span> objects (e.g., <span class="tt">CHAT_MESSAGE</span> type) and sends them to the server using <span class="tt">*this &lt;&lt; protocol_message &lt;&lt; Protocol::end;</span>.</li>
<li><span class="tt">on(chat::Message&amp;)</span>: Receives messages from the server parsed by <span class="tt">ChatProtocol</span>. Handles <span class="tt">AUTH_RESPONSE</span> (updates authenticated state), <span class="tt">CHAT_MESSAGE</span> (prints to console), and <span class="tt">ERROR</span> messages.</li>
<li><span class="tt">on(<a class="el" href="structqb_1_1io_1_1async_1_1event_1_1disconnected.html" title="Event triggered when a connection is closed or lost.">qb::io::async::event::disconnected</a> const&amp;)</span>: Handles server disconnection, clears authenticated state, and attempts to reconnect using <span class="tt"><a class="el" href="group___async.html#ga79acd187eb2aeb629523ebb206ee004d" title="Utility function to schedule a callable for execution after a timeout.">qb::io::async::callback</a></span>.</li>
</ul>
</li>
<li><b>Shutdown (<span class="tt">on(<a class="el" href="structqb_1_1_kill_event.html" title="Event used to terminate an actor.">qb::KillEvent</a>&amp;)</span>):</b> Calls <span class="tt">this-&gt;disconnect()</span> (which internally calls <span class="tt">this-&gt;close()</span> on the transport) and then <span class="tt">this-&gt;kill()</span>.</li>
</ul>
<h2>Key QB Concepts Illustrated by <span class="tt">chat_tcp</span></h2>
<ul>
<li><b>Client-Server Architecture with Actors:</b> A classic networking pattern implemented using actor principles.</li>
<li><b>Multi-Core Actor Distribution:</b> Demonstrates assigning different roles (accepting, session handling, core logic, UI input) to actors potentially running on different cores.</li>
<li><b>Asynchronous TCP Client &amp; Server:</b> Extensive use of <span class="tt"><a class="el" href="structqb_1_1io_1_1use.html" title="Helper template providing type aliases for integrating qb-io asynchronous components.">qb::io::use</a>&lt;&gt;</span> templates for TCP operations (<span class="tt">tcp::acceptor</span>, <span class="tt">tcp::server</span>, <span class="tt">tcp::client</span>).</li>
<li><b>Custom Protocol (<span class="tt">ChatProtocol</span>):</b> Shows how to define a header-based binary protocol for message framing and how <span class="tt"><a class="el" href="classqb_1_1allocator_1_1pipe.html" title="Extensible buffer optimized for performance.">qb::allocator::pipe</a></span> can be specialized with <span class="tt">put</span> for efficient serialization into the output buffer (see <span class="tt">Protocol.cpp</span>).</li>
<li><b>Actor-Based Session Management:</b> The <span class="tt">ServerActor</span> uses the <span class="tt">io_handler</span> capabilities provided by <span class="tt"><a class="el" href="structqb_1_1io_1_1use.html" title="Helper template providing type aliases for integrating qb-io asynchronous components.">qb::io::use</a>&lt;...&gt;::tcp::server&lt;ChatSession&gt;</span> to manage multiple <span class="tt">ChatSession</span> objects.</li>
<li><b>Centralized State Management:</b> The <span class="tt">ChatRoomActor</span> acts as a central authority for shared application state (user lists, subscriptions), ensuring consistent access through sequential event processing.</li>
<li><b>Inter-Actor Communication:</b> Clear examples of <span class="tt">push</span> for reliable event delivery between actors, and how <span class="tt">ActorId</span>s are used for addressing.</li>
<li><b>Connection Resilience (Client-Side):</b> Basic reconnection logic implemented using <span class="tt"><a class="el" href="group___async.html#ga79acd187eb2aeb629523ebb206ee004d" title="Utility function to schedule a callable for execution after a timeout.">qb::io::async::callback</a></span>.</li>
<li><b>Inactivity Timeouts (Session-Side):</b> <span class="tt">ChatSession</span> uses <span class="tt"><a class="el" href="structqb_1_1io_1_1use.html" title="Helper template providing type aliases for integrating qb-io asynchronous components.">qb::io::use</a>&lt;...&gt;::timeout</span> to detect and handle idle client connections.</li>
<li><b>Separation of Concerns:</b> Network I/O, user input, and core application logic are well-separated into distinct actor responsibilities.</li>
</ul>
<p>By studying the <span class="tt">chat_tcp</span> example, developers can gain a solid understanding of how to combine <span class="tt">qb-core</span> and <span class="tt">qb-io</span> to build complex, scalable, and robust networked applications.</p>
<p><b>(Next Example Analysis:</b> distributed_computing Example Analysis**) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="index.html">QB Actor Framework: High-Performance C++17 Concurrent Systems</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
