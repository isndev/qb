<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <head>
        <meta http-equiv="cache-control" content="max-age=86400"/>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta http-equiv="X-UA-Compatible" content="IE=9"/>
        <meta name="generator" content="Doxygen 1.14.0"/>
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <title>qb: QB-Core: Engine - `qb::Main` &amp; `VirtualCore`</title>
        <meta name="description" content="qb OpenSource C++17 Actor Framework Documentation, all API detailed">
        <meta name="keywords"
              content="qb, cube, actor, framework, actor framework, opensource, cpp, c++, cpp17, c++17, documentation, docs, git">
        <meta name="author" content="isndev">
        <!-- BEGIN opengraph metadata -->
<!--        <meta property="og:title" content="Doxygen Awesome"/>-->
<!--        <meta property="og:image"-->
<!--              content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>-->
<!--        <meta property="og:description"-->
<!--              content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>-->
<!--        <meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/"/>-->
        <!-- END opengraph metadata -->
        <!-- BEGIN twitter metadata -->
<!--        <meta name="twitter:image:src"-->
<!--              content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>-->
<!--        <meta name="twitter:title" content="Doxygen Awesome"/>-->
<!--        <meta name="twitter:description"-->
<!--              content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>-->
        <!-- END twitter metadata -->
        <title>qb: QB-Core: Engine - `qb::Main` &amp; `VirtualCore`</title>
        <link href="tabs.css" rel="stylesheet" type="text/css"/>
        <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
        <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
        <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
        <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
        <script type="text/javascript" src="toggle-alternative-theme.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeFragmentCopyButton.init()
            DoxygenAwesomeDarkModeToggle.init()
            DoxygenAwesomeParagraphLink.init()
            DoxygenAwesomeInteractiveToc.init()
            DoxygenAwesomeTabs.init()
        </script>
        <script async defer src="https://buttons.github.io/buttons.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css"/>
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
    </head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/isndev/qb" class="github-corner" title="View source on GitHub"
   target="_blank" rel="noopener noreferrer">
    <svg viewBox="0 0 250 250" width="40" height="40"
         style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
<style>.github-corner:hover .octo-arm {
    animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
    0%, 100% {
        transform: rotate(0)
    }
    20%, 60% {
        transform: rotate(-25deg)
    }
    40%, 80% {
        transform: rotate(10deg)
    }
}
@media (max-width: 500px) {
    .github-corner:hover .octo-arm {
        animation: none
    }
    .github-corner .octo-arm {
        animation: octocat-wave 560ms ease-in-out
    }
}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
            <tr style="height: 56px;">
                <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
                <td id="projectalign" style="padding-left: 0.5em;">
                    <div id="projectname">qb
                        &#160;<span id="projectnumber">2.0.0.0</span>
                    </div>
                    <div id="projectbrief">C++17 Actor Framework</div>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
    <div style="padding-left: 0.5em;">
        <a class="navbar-brand" href="https://github.com/isndev/qb">
            <img src="GitHub-Mark-64px.png" width="32px" alt="qb">
        </a>
        <a class="github-button" href="https://github.com/isndev/qb/issues" data-icon="octicon-issue-opened" data-size="large" data-show-count="true" aria-label="Issue isndev/qb on GitHub">Issue</a>
        <a class="github-button" href="https://github.com/isndev/qb/subscription" data-icon="octicon-eye" data-size="large" data-show-count="true" aria-label="Watch isndev/qb on GitHub">Watch</a>
        <a class="github-button" href="https://github.com/isndev/qb" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star isndev/qb on GitHub">Star</a>
        <a class="github-button" href="https://github.com/isndev/qb/fork" data-icon="octicon-repo-forked" data-size="large" data-show-count="true" aria-label="Fork isndev/qb on GitHub">Fork</a>
        <a class="github-button" href="https://github.com/isndev" data-size="large" data-show-count="false" aria-label="Follow @isndev on GitHub">Follow @isndev</a>
    </div>
    <!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('qb_core_engine_md.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">QB-Core: Engine - `qbMain` &amp; `VirtualCore` </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Understand the QB actor system's engine, how <span class="tt"><a class="el" href="classqb_1_1_main.html" title="The main controller for the QB Actor Framework engine.">qb::Main</a></span> orchestrates <span class="tt">VirtualCore</span> worker threads, and how actors are scheduled.</p>
<h1>QB-Core: Engine - <span class="tt"><a class="el" href="classqb_1_1_main.html" title="The main controller for the QB Actor Framework engine.">qb::Main</a></span> &amp; <span class="tt">VirtualCore</span></h1>
<p>The QB Actor Framework's engine is the runtime environment that brings your actors to life, manages their execution, and facilitates their communication. It's primarily composed of the <span class="tt"><a class="el" href="classqb_1_1_main.html" title="The main controller for the QB Actor Framework engine.">qb::Main</a></span> class, which orchestrates multiple <span class="tt"><a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">qb::VirtualCore</a></span> instances (worker threads).</p>
<h2><span class="tt"><a class="el" href="classqb_1_1_main.html" title="The main controller for the QB Actor Framework engine.">qb::Main</a></span>: The Conductor of Your Actor Symphony</h2>
<p>(<span class="tt"><a class="el" href="core_2main_8h.html" title="Main control for the QB Actor Framework.">qb/core/Main.h</a></span>)</p>
<p>Think of <span class="tt"><a class="el" href="classqb_1_1_main.html" title="The main controller for the QB Actor Framework engine.">qb::Main</a></span> as the central controller for your entire actor system. It's responsible for setting up the environment, launching worker threads, and managing the overall lifecycle.</p>
<p>Basic Engine Architecture: </p><div class="fragment"><div class="line">+------------------------------------+</div>
<div class="line">|             qb::Main               |</div>
<div class="line">|  (Engine Orchestrator)             |</div>
<div class="line">+-----------------|------------------+</div>
<div class="line">                  | Manages</div>
<div class="line">      +-----------+-----------+</div>
<div class="line">      |                       |</div>
<div class="line">+-----v-----------+     +-----v-----------+</div>
<div class="line">|  VirtualCore 0  |     |  VirtualCore 1  |  ... (More VirtualCores)</div>
<div class="line">|  (Worker Thread)|     |  (Worker Thread)|</div>
<div class="line">| +-------------+ |     | +-------------+ |</div>
<div class="line">| |   Actor A   | |     | |   Actor C   | |</div>
<div class="line">| +-------------+ |     | +-------------+ |</div>
<div class="line">| +-------------+ |     | +-------------+ |</div>
<div class="line">| |   Actor B   | |     | |   Actor D   | |</div>
<div class="line">| +-------------+ |     | +-------------+ |</div>
<div class="line">| (Event Loop &amp;   |     | (Event Loop &amp;   |</div>
<div class="line">|  Mailbox)       |     |  Mailbox)       |</div>
<div class="line">+-----------------+     +-----------------+</div>
</div><!-- fragment --><h3>Initializing and Configuring the Engine</h3>
<ol type="1">
<li><p class="startli"><b>Instantiate <span class="tt"><a class="el" href="classqb_1_1_main.html" title="The main controller for the QB Actor Framework engine.">qb::Main</a></span>:</b> Your application typically starts by creating an instance of <span class="tt"><a class="el" href="classqb_1_1_main.html" title="The main controller for the QB Actor Framework engine.">qb::Main</a></span>. ```cpp #include &lt;<a class="el" href="main_8h.html" title="Convenience header for the QB Main engine controller.">qb/main.h</a>&gt; // For <a class="el" href="classqb_1_1_main.html" title="The main controller for the QB Actor Framework engine.">qb::Main</a>, <a class="el" href="classqb_1_1_core_initializer.html" title="Handles pre-start configuration for a single VirtualCore.">qb::CoreInitializer</a>, <a class="el" href="group___core.html#gaf938afc2318277511d1b20184c0c1152" title="Efficient set implementation for storing CoreId values.">qb::CoreIdSet</a> #include "MyActor.h" // Your actor definitions</p>
<p class="startli">int main() { <a class="el" href="classqb_1_1_main.html" title="The main controller for the QB Actor Framework engine.">qb::Main</a> engine; // ... configuration and actor addition follow ... } ```</p>
</li>
<li><p class="startli"><b>(Optional) Configure <span class="tt">VirtualCore</span> Behavior (Before Starting):</b> <span class="tt"><a class="el" href="classqb_1_1_main.html" title="The main controller for the QB Actor Framework engine.">qb::Main</a></span> allows you to fine-tune the behavior of each <span class="tt">VirtualCore</span> <em>before</em> the engine starts. You access a core's configuration through <span class="tt">engine.core(core_id)</span>, which returns a <span class="tt"><a class="el" href="classqb_1_1_core_initializer.html" title="Handles pre-start configuration for a single VirtualCore.">qb::CoreInitializer</a>&amp;</span>.</p><ul>
<li><b>Set Event Loop Latency:</b> <span class="tt">core_initializer.setLatency(nanoseconds)</span>:<ul>
<li><span class="tt">0</span> (default): Lowest latency; the <span class="tt">VirtualCore</span> spins actively, consuming 100% CPU. Ideal for highly responsive tasks.</li>
<li><span class="tt">&gt;0</span>: The <span class="tt">VirtualCore</span> may sleep for up to this duration if idle, reducing CPU usage at the cost of slightly increased event processing latency.</li>
</ul>
</li>
<li><b>Set CPU Affinity:</b> <span class="tt">core_initializer.setAffinity(<a class="el" href="group___core.html#gaf938afc2318277511d1b20184c0c1152" title="Efficient set implementation for storing CoreId values.">qb::CoreIdSet</a>{cpu_id1, cpu_id2, ...})</span>:<ul>
<li>Pins the <span class="tt">VirtualCore</span> thread to specific physical CPU cores. This can improve performance by enhancing cache locality and reducing thread migration. Requires careful planning. ```cpp // Example: Configure core 1 for lower CPU usage, core 2 for high responsiveness <a class="el" href="group___core.html#gaf938afc2318277511d1b20184c0c1152" title="Efficient set implementation for storing CoreId values.">qb::CoreIdSet</a> core2_affinity = {2}; // Assuming physical core 2 engine.core(1).setLatency(1000000); // 1ms latency for core 1 engine.core(2).setAffinity(core2_affinity).setLatency(0); // Core 2 on physical CPU 2, no latency</li>
</ul>
</li>
</ul>
<p class="startli">// Set a default latency for any other cores that might be implicitly created or used engine.setLatency(500000); // Default 0.5ms for other cores ```</p>
</li>
<li><p class="startli"><b>Add Actors to Cores:</b> Assign your actor instances to specific <span class="tt">VirtualCore</span>s.</p><ul>
<li><span class="tt">engine.addActor&lt;MyActorType&gt;(core_id, constructor_arg1, ...)</span>: Adds a single actor to the specified <span class="tt">core_id</span>.</li>
<li><span class="tt">engine.core(core_id).builder().addActor&lt;ActorA&gt;(...).addActor&lt;ActorB&gt;(...).idList()</span>: A fluent interface for adding multiple actors to the same core and retrieving their <span class="tt">ActorId</span>s. ```cpp // Add a LoggerService actor to core 0 <a class="el" href="classqb_1_1_actor_id.html" title="Unique identifier for actors.">qb::ActorId</a> logger_id = engine.addActor&lt;LoggerService&gt;(0, "system_log.txt"); if (!logger_id.is_valid()) { /* Handle error, e.g., duplicate service */ }</li>
</ul>
<p class="startli">// Add multiple worker actors to core 1 auto worker_ids = engine.core(1).builder() .addActor&lt;DataProcessor&gt;(logger_id) .addActor&lt;ReportGenerator&gt;(logger_id) .idList(); // Returns std::vector&lt;qb::ActorId&gt; ```</p>
</li>
</ol>
<h3>Running and Stopping the Engine</h3>
<ul>
<li><b><span class="tt">engine.start(bool async = true)</span>:</b> This crucial method launches the <span class="tt">VirtualCore</span> threads and starts their event loops.<ul>
<li><span class="tt">async = true</span> (default): <span class="tt">start()</span> returns immediately. Your <span class="tt">main()</span> thread (or the calling thread) continues execution independently. You'll typically call <span class="tt">engine.join()</span> later to wait for the engine to shut down.</li>
<li><span class="tt">async = false</span>: The calling thread <b>becomes</b> one of the <span class="tt">VirtualCore</span> worker threads (usually the one with the lowest available <span class="tt">core_id</span> if not explicitly configured, or the last one in a single-threaded setup for <span class="tt">start(false)</span>). This call <b>blocks</b> until the entire engine is stopped.</li>
</ul>
</li>
<li><b><span class="tt">engine.join()</span>:</b> If you started the engine with <span class="tt">async = true</span>, call <span class="tt">join()</span> on the <span class="tt">engine</span> object in your main thread. This will block until all <span class="tt">VirtualCore</span> threads have completed their shutdown and terminated.</li>
<li><b><span class="tt"><a class="el" href="group___engine.html#ga17196adf7b7ab867d25074f78f048658" title="Stop the engine and all its VirtualCores gracefully.">qb::Main::stop()</a></span> (Static Method):</b> This is the recommended way to initiate a graceful shutdown of the entire actor system. It can be called from any thread, including OS signal handlers. It typically works by sending <span class="tt"><a class="el" href="structqb_1_1_kill_event.html" title="Event used to terminate an actor.">qb::KillEvent</a></span> or a similar signal to all actors/cores.</li>
<li><b>Signal Handling:</b> By default, <span class="tt"><a class="el" href="classqb_1_1_main.html" title="The main controller for the QB Actor Framework engine.">qb::Main</a></span> registers handlers for <span class="tt">SIGINT</span> and <span class="tt">SIGTERM</span> (on POSIX-like systems) that will call <span class="tt"><a class="el" href="group___engine.html#ga17196adf7b7ab867d25074f78f048658" title="Stop the engine and all its VirtualCores gracefully.">qb::Main::stop()</a></span>. You can customize this using <span class="tt"><a class="el" href="group___engine.html#gaaedd9ea643c7b1f9bdc007ef600647de" title="Register a system signal to be handled by the engine (results in graceful shutdown).">qb::Main::registerSignal(int signum)</a></span> and <span class="tt"><a class="el" href="group___engine.html#ga2416f2d96af077756b1b39b7db299c61" title="Unregister a previously registered system signal from engine handling.">qb::Main::unregisterSignal(int signum)</a></span>.</li>
<li><b>Error Checking (<span class="tt">engine.hasError()</span>):</b> After <span class="tt">engine.join()</span> returns, call <span class="tt">engine.hasError()</span> to check if any <span class="tt">VirtualCore</span> terminated prematurely due to an unhandled exception or other critical error.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Typical asynchronous startup and shutdown</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_class" href="classqb_1_1_main.html">qb::Main</a> engine;</div>
<div class="line">    <span class="comment">// ... configure engine and add actors ...</span></div>
<div class="line"> </div>
<div class="line">    engine.<a class="code hl_function" href="group___engine.html#ga0990bde9edb018a122be3dfe30069181">start</a>(); <span class="comment">// Start asynchronously</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classqb_1_1io_1_1cout.html">qb::io::cout</a>() &lt;&lt; <span class="stringliteral">&quot;QB Engine running in background. Main thread can do other work or wait.\n&quot;</span>;</div>
<div class="line">    <span class="comment">// Example: Let the engine run for a while, then stop it</span></div>
<div class="line">    <span class="comment">// In a real server, this might be an indefinite wait or controlled by other logic</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::seconds(10));</div>
<div class="line">    <a class="code hl_class" href="classqb_1_1io_1_1cout.html">qb::io::cout</a>() &lt;&lt; <span class="stringliteral">&quot;Requesting engine stop...\n&quot;</span>;</div>
<div class="line">    <a class="code hl_function" href="group___engine.html#ga17196adf7b7ab867d25074f78f048658">qb::Main::stop</a>(); <span class="comment">// Signal all cores/actors to stop</span></div>
<div class="line"> </div>
<div class="line">    engine.<a class="code hl_function" href="group___engine.html#ga0f82608ca2a0ba910873d0caabbf6e65">join</a>(); <span class="comment">// Wait for graceful shutdown</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (engine.<a class="code hl_function" href="group___engine.html#gad337df7d61e82fe2d32c0cc328c44835">hasError</a>()) {</div>
<div class="line">        <a class="code hl_class" href="classqb_1_1io_1_1cout.html">qb::io::cout</a>() &lt;&lt; <span class="stringliteral">&quot;Engine stopped with an error!\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_class" href="classqb_1_1io_1_1cout.html">qb::io::cout</a>() &lt;&lt; <span class="stringliteral">&quot;Engine stopped successfully.\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassqb_1_1_main_html"><div class="ttname"><a href="classqb_1_1_main.html">qb::Main</a></div><div class="ttdoc">The main controller for the QB Actor Framework engine.</div><div class="ttdef"><b>Definition</b> Main.h:408</div></div>
<div class="ttc" id="aclassqb_1_1io_1_1cout_html"><div class="ttname"><a href="classqb_1_1io_1_1cout.html">qb::io::cout</a></div><div class="ttdoc">Thread-safe console output class.</div><div class="ttdef"><b>Definition</b> io.h:100</div></div>
<div class="ttc" id="agroup___engine_html_ga0990bde9edb018a122be3dfe30069181"><div class="ttname"><a href="group___engine.html#ga0990bde9edb018a122be3dfe30069181">qb::Main::start</a></div><div class="ttdeci">void start(bool async=true) noexcept</div><div class="ttdoc">Start the engine and its VirtualCore worker threads.</div></div>
<div class="ttc" id="agroup___engine_html_ga0f82608ca2a0ba910873d0caabbf6e65"><div class="ttname"><a href="group___engine.html#ga0f82608ca2a0ba910873d0caabbf6e65">qb::Main::join</a></div><div class="ttdeci">void join()</div><div class="ttdoc">Wait for the engine and all its VirtualCore threads to terminate.</div></div>
<div class="ttc" id="agroup___engine_html_ga17196adf7b7ab867d25074f78f048658"><div class="ttname"><a href="group___engine.html#ga17196adf7b7ab867d25074f78f048658">qb::Main::stop</a></div><div class="ttdeci">static void stop() noexcept</div><div class="ttdoc">Stop the engine and all its VirtualCores gracefully.</div></div>
<div class="ttc" id="agroup___engine_html_gad337df7d61e82fe2d32c0cc328c44835"><div class="ttname"><a href="group___engine.html#gad337df7d61e82fe2d32c0cc328c44835">qb::Main::hasError</a></div><div class="ttdeci">bool hasError() const noexcept</div><div class="ttdoc">Check if any VirtualCore encountered an error and terminated prematurely.</div></div>
</div><!-- fragment --><p><b>(Reference:</b> <span class="tt">test-main.cpp</span> for various startup/shutdown scenarios. All examples in <span class="tt">example/</span> showcase <span class="tt"><a class="el" href="classqb_1_1_main.html" title="The main controller for the QB Actor Framework engine.">qb::Main</a></span> usage.**)</p>
<h2><span class="tt"><a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">qb::VirtualCore</a></span>: The Actor's Execution Environment</h2>
<p>(<span class="tt"><a class="el" href="_virtual_core_8h.html" title="Defines the VirtualCore class, representing a worker thread in the QB Actor Framework.">qb/core/VirtualCore.h</a></span>)</p>
<p>A <span class="tt"><a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">qb::VirtualCore</a></span> represents a single, independent worker thread that is responsible for executing the actors assigned to it. You don't typically interact with <span class="tt">VirtualCore</span> objects directly; <span class="tt"><a class="el" href="classqb_1_1_main.html" title="The main controller for the QB Actor Framework engine.">qb::Main</a></span> manages them.</p>
<ul>
<li><b>Execution Model &amp; Event Loop:</b> At its heart, each <span class="tt">VirtualCore</span> runs an event loop powered by <span class="tt"><a class="el" href="classqb_1_1io_1_1async_1_1listener.html" title="Central event loop manager for asynchronous IO operations.">qb::io::async::listener</a></span> (from the <span class="tt">qb-io</span> library). This loop is the engine that drives all activity for the actors on that core.</li>
<li><b>Mailbox &amp; Event Queues:</b> To handle messages:<ul>
<li><b>Inter-Core Mailbox:</b> Each <span class="tt">VirtualCore</span> has an incoming MPSC (Multiple-Producer, Single-Consumer) queue. When an actor on <em>another</em> core sends an event to an actor on <em>this</em> core, the event data is placed into this mailbox.</li>
<li><b>Local Event Queue:</b> Events sent between actors residing on the <em>same</em> <span class="tt">VirtualCore</span> (e.g., via <span class="tt">actor.push()</span>) are typically handled through a more direct local queueing mechanism within that core.</li>
</ul>
</li>
<li><b>Sequential Actor Processing (The Key Guarantee):</b> A <span class="tt">VirtualCore</span> processes <b>one event for one actor to completion</b> before moving to the next event or any other task (like callbacks) for any actor on that same core. This sequential execution of an actor's event handlers is what provides inherent thread safety for an actor's internal state, eliminating the need for manual locking <em>within</em> an actor for its own data.</li>
<li><b>Scheduling Cycle (Conceptual):</b> In each iteration of its main processing loop, a <span class="tt">VirtualCore</span> generally performs these steps:<ol type="1">
<li><b>Process I/O Events:</b> Polls its <span class="tt"><a class="el" href="classqb_1_1io_1_1async_1_1listener.html" title="Central event loop manager for asynchronous IO operations.">qb::io::async::listener</a></span> for any pending I/O events (socket readiness, file changes, timer expirations from <span class="tt"><a class="el" href="group___async.html#ga79acd187eb2aeb629523ebb206ee004d" title="Utility function to schedule a callable for execution after a timeout.">qb::io::async::callback</a></span> or <span class="tt"><a class="el" href="classqb_1_1io_1_1async_1_1with__timeout.html" title="CRTP base class that adds timeout functionality to derived asynchronous components.">qb::io::async::with_timeout</a></span>) and dispatches them.</li>
<li><b>Process Inter-Core Mailbox:</b> Dequeues and processes events that have arrived from other <span class="tt">VirtualCore</span>s.</li>
<li><b>Process Local Event Queue:</b> Dequeues and processes events sent between actors on this same core.</li>
<li><b>Execute Callbacks:</b> Invokes the <span class="tt">onCallback()</span> method for all actors on this core that have registered via <span class="tt"><a class="el" href="classqb_1_1_i_callback.html" title="Interface for actor callbacks.">qb::ICallback</a></span>.</li>
<li><b>Flush Outgoing Pipes:</b> Sends any buffered outgoing events to their destination <span class="tt">VirtualCore</span> mailboxes.</li>
<li><b>Idle Behavior:</b> If configured with a <span class="tt">latency &gt; 0</span> and there's no immediate work, the <span class="tt">VirtualCore</span> may briefly sleep to conserve CPU resources.</li>
</ol>
</li>
</ul>
<h2>Inter-Core Communication <a class="el" href="namespace_internals.html" title="Internal helper functions for CPU information.">Internals</a>: A Glimpse</h2>
<p>(<span class="tt"><a class="el" href="core_2main_8h.html" title="Main control for the QB Actor Framework.">qb/core/Main.h</a></span> - <span class="tt">SharedCoreCommunication</span>, <span class="tt"><a class="el" href="mpsc_8h.html" title="Multiple-Producer Single-Consumer lockfree queue.">qb/system/lockfree/mpsc.h</a></span>)</p>
<p>While largely transparent to the application developer, understanding the basics of inter-core messaging can be insightful:</p>
<ul>
<li><b><span class="tt">SharedCoreCommunication</span>:</b> An internal component managed by <span class="tt"><a class="el" href="classqb_1_1_main.html" title="The main controller for the QB Actor Framework engine.">qb::Main</a></span>. It owns and provides access to the MPSC mailboxes for all <span class="tt">VirtualCore</span>s.</li>
<li><b>Mailboxes (MPSC Queues):</b> Each <span class="tt">VirtualCore</span> has one such incoming mailbox. Events destined for actors on this core from <em>other</em> cores are enqueued here. The use of lock-free MPSC queues (<span class="tt"><a class="el" href="classqb_1_1lockfree_1_1mpsc_1_1ringbuffer.html" title="Multi-Producer Single-Consumer ring buffer with fixed number of producers.">qb::lockfree::mpsc::ringbuffer</a></span>) is critical for minimizing contention and maximizing throughput when multiple cores are sending events to a single target core.</li>
<li><b><span class="tt">VirtualPipe</span>:</b> When an actor calls <span class="tt">push()</span> or <span class="tt">getPipe().push()</span>, events are initially buffered in per-destination <span class="tt">VirtualPipe</span> objects within the sending <span class="tt">VirtualCore</span>. The <span class="tt">VirtualCore</span> then flushes these pipes at an appropriate point in its loop, transferring the event data to the destination core's MPSC mailbox.</li>
</ul>
<p>Inter-Core Event Flow (Actor A on VC0 sends to Actor C on VC1): </p><div class="fragment"><div class="line">+-----------------+       +-----------------+       +----------------------+</div>
<div class="line">| VirtualCore 0   |       | Shared MPSC     |       | VirtualCore 1        |</div>
<div class="line">|  +-----------+  |       | Mailbox for VC1 |       |      +-----------+   |</div>
<div class="line">|  | Actor A   |--&gt;Event-&gt;| (from VC0)      |---&gt;Event----&gt;| Actor C   |   |</div>
<div class="line">|  | (Sender)  |  |       +-----------------+       |      | (Receiver)|   |</div>
<div class="line">|  +-----------+  |                                 |      +-----------+   |</div>
<div class="line">+-----------------+                                 +----------------------+</div>
<div class="line"> </div>
<div class="line">1. Actor A (on VC0) calls push&lt;Event&gt;(actor_c_id, ...)</div>
<div class="line">2. VC0 places event data into VC1&#39;s MPSC Mailbox.</div>
<div class="line">3. VC1, during its event loop, dequeues event from its Mailbox.</div>
<div class="line">4. VC1 dispatches event to Actor C&#39;s on(Event&amp;) handler.</div>
</div><!-- fragment --><p>This architecture is designed to ensure efficient, low-contention message passing, forming the backbone of QB's scalable actor communication.</p>
<p><b>(Next:</b> Explore QB-Core: Actor Patterns &amp; Utilities or review Core Concepts: Concurrency and Parallelism in QB for a higher-level view.**) <b>(Reference Examples:</b> <span class="tt">test-actor-event.cpp</span> (Multi core, High Latency tests), <span class="tt">test-actor-service-event.cpp</span> for inter-core messaging demonstrations.**) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="index.html">QB Actor Framework: High-Performance C++17 Concurrent Systems</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
