<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <head>
        <meta http-equiv="cache-control" content="max-age=86400"/>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta http-equiv="X-UA-Compatible" content="IE=9"/>
        <meta name="generator" content="Doxygen 1.14.0"/>
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <title>qb: QB Framework: Advanced Techniques &amp; System Design</title>
        <meta name="description" content="qb OpenSource C++17 Actor Framework Documentation, all API detailed">
        <meta name="keywords"
              content="qb, cube, actor, framework, actor framework, opensource, cpp, c++, cpp17, c++17, documentation, docs, git">
        <meta name="author" content="isndev">
        <!-- BEGIN opengraph metadata -->
<!--        <meta property="og:title" content="Doxygen Awesome"/>-->
<!--        <meta property="og:image"-->
<!--              content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>-->
<!--        <meta property="og:description"-->
<!--              content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>-->
<!--        <meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/"/>-->
        <!-- END opengraph metadata -->
        <!-- BEGIN twitter metadata -->
<!--        <meta name="twitter:image:src"-->
<!--              content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>-->
<!--        <meta name="twitter:title" content="Doxygen Awesome"/>-->
<!--        <meta name="twitter:description"-->
<!--              content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>-->
        <!-- END twitter metadata -->
        <title>qb: QB Framework: Advanced Techniques &amp; System Design</title>
        <link href="tabs.css" rel="stylesheet" type="text/css"/>
        <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
        <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
        <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
        <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
        <script type="text/javascript" src="toggle-alternative-theme.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeFragmentCopyButton.init()
            DoxygenAwesomeDarkModeToggle.init()
            DoxygenAwesomeParagraphLink.init()
            DoxygenAwesomeInteractiveToc.init()
            DoxygenAwesomeTabs.init()
        </script>
        <script async defer src="https://buttons.github.io/buttons.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css"/>
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
    </head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/isndev/qb" class="github-corner" title="View source on GitHub"
   target="_blank" rel="noopener noreferrer">
    <svg viewBox="0 0 250 250" width="40" height="40"
         style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
<style>.github-corner:hover .octo-arm {
    animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
    0%, 100% {
        transform: rotate(0)
    }
    20%, 60% {
        transform: rotate(-25deg)
    }
    40%, 80% {
        transform: rotate(10deg)
    }
}
@media (max-width: 500px) {
    .github-corner:hover .octo-arm {
        animation: none
    }
    .github-corner .octo-arm {
        animation: octocat-wave 560ms ease-in-out
    }
}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
            <tr style="height: 56px;">
                <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
                <td id="projectalign" style="padding-left: 0.5em;">
                    <div id="projectname">qb
                        &#160;<span id="projectnumber">2.0.0.0</span>
                    </div>
                    <div id="projectbrief">C++17 Actor Framework</div>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
    <div style="padding-left: 0.5em;">
        <a class="navbar-brand" href="https://github.com/isndev/qb">
            <img src="GitHub-Mark-64px.png" width="32px" alt="qb">
        </a>
        <a class="github-button" href="https://github.com/isndev/qb/issues" data-icon="octicon-issue-opened" data-size="large" data-show-count="true" aria-label="Issue isndev/qb on GitHub">Issue</a>
        <a class="github-button" href="https://github.com/isndev/qb/subscription" data-icon="octicon-eye" data-size="large" data-show-count="true" aria-label="Watch isndev/qb on GitHub">Watch</a>
        <a class="github-button" href="https://github.com/isndev/qb" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star isndev/qb on GitHub">Star</a>
        <a class="github-button" href="https://github.com/isndev/qb/fork" data-icon="octicon-repo-forked" data-size="large" data-show-count="true" aria-label="Fork isndev/qb on GitHub">Fork</a>
        <a class="github-button" href="https://github.com/isndev" data-size="large" data-show-count="false" aria-label="Follow @isndev on GitHub">Follow @isndev</a>
    </div>
    <!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('guides_advanced_usage_md.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">QB Framework: Advanced Techniques &amp; System Design </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Explore sophisticated usage patterns, advanced system design considerations, and performance optimization strategies for complex QB applications.</p>
<h1>QB Framework: Advanced Techniques &amp; System Design</h1>
<p>Once you're comfortable with the core concepts and basic patterns of the QB Actor Framework, you can begin to explore more advanced techniques to build truly sophisticated, scalable, and resilient systems. This guide delves into such practices, often drawing inspiration from the more complex examples provided with the framework.</p>
<h2>1. Complex Actor Hierarchies &amp; Supervision</h2>
<p>While QB doesn't enforce a built-in supervisor hierarchy like some other actor systems, you can implement robust supervision trees using standard actor patterns.</p>
<ul>
<li><b>Parent-Child Relationships (Logical):</b><ul>
<li>An actor (supervisor) can create other actors (workers/children) and store their <span class="tt">ActorId</span>s.</li>
<li>The supervisor is responsible for the <em>logical</em> lifecycle of its children: sending them initial configuration, work, and potentially <span class="tt"><a class="el" href="structqb_1_1_kill_event.html" title="Event used to terminate an actor.">qb::KillEvent</a></span>s when the supervisor itself is shutting down.</li>
</ul>
</li>
<li><b>Health Monitoring &amp; Restart Strategies:</b><ul>
<li><b>Heartbeats/Pings:</b> Supervisors can periodically send <span class="tt">PingEvent</span>s to children. Children reply with <span class="tt">PongEvent</span>. If a pong is missed (detected via a timeout scheduled with <span class="tt"><a class="el" href="group___async.html#ga79acd187eb2aeb629523ebb206ee004d" title="Utility function to schedule a callable for execution after a timeout.">qb::io::async::callback</a></span> in the supervisor), the child might be considered unresponsive.</li>
<li><b>Explicit Failure Reporting:</b> Children can <span class="tt">push</span> a specific <span class="tt">ChildFailedEvent(reason)</span> to their supervisor upon encountering an unrecoverable internal error before terminating themselves.</li>
<li><b>Restart Logic:</b> Upon detecting a child failure, the supervisor can:<ul>
<li><b>Restart:</b> Create a new instance of the failed child actor (<span class="tt">addActor</span> or <span class="tt">addRefActor</span>). The new actor might need to recover state (e.g., from a persistent store or by requesting it from peers).</li>
<li><b>Delegate:</b> Reassign the failed child's pending tasks to other available workers.</li>
<li><b>Escalate:</b> If the failure is critical or repeated, the supervisor might notify its own supervisor or a system-level manager actor.</li>
</ul>
</li>
</ul>
</li>
<li><b>Fault Isolation:</b> A key benefit is that the failure of a child actor (even an unhandled exception causing its <span class="tt">VirtualCore</span> to terminate, if not designed carefully) can be contained. The supervisor, ideally on a different <span class="tt">VirtualCore</span>, can detect this and react without being directly affected by the crash itself (though it needs to handle the loss of the child).</li>
</ul>
<p><b>(Reference:</b> The <span class="tt">example/core/example10_distributed_computing.cpp</span> showcases a <span class="tt">SystemMonitorActor</span> that launches and (conceptually) oversees other top-level actors. The <span class="tt">TaskSchedulerActor</span> in the same example implicitly supervises workers by tracking their heartbeats and status.)**</p>
<h2>2. Advanced Message Design &amp; Serialization</h2>
<p>For highly performance-sensitive applications or when integrating with external systems, consider these advanced messaging aspects:</p>
<ul>
<li><b>Custom Serialization for Large/Complex Events:</b><ul>
<li>While <span class="tt">std::shared_ptr</span> is excellent for passing large data within events without copying the payload, if you need to send events over a network to non-QB systems or require a very compact representation, you might implement custom serialization/deserialization directly within your event types or specialized <span class="tt">Protocol</span> classes.</li>
<li>This could involve using libraries like Protocol Buffers, FlatBuffers, Cap'n Proto, or a custom binary format. Your <span class="tt">Protocol::onMessage</span> would deserialize, and your sending logic would serialize.</li>
</ul>
</li>
<li><b>Zero-Copy Techniques (Conceptual within QB):</b><ul>
<li><b><span class="tt">qb::string_view</span> Protocols:</b> Using protocols like <span class="tt">text::string_view</span> or <span class="tt">text::command_view</span> allows your actor to receive a view of the data directly from the <span class="tt">qb-io</span> input buffer without copying the payload into a <span class="tt">std::string</span> or <span class="tt"><a class="el" href="classqb_1_1string.html" title="Fixed-size string with optimized storage.">qb::string</a></span> within the <span class="tt">Protocol::message</span> struct. This is effective if the message is processed immediately and the buffer isn't modified or invalidated before the view is used.</li>
<li><b><span class="tt"><a class="el" href="classqb_1_1allocator_1_1pipe.html" title="Extensible buffer optimized for performance.">qb::allocator::pipe</a></span> and <span class="tt">allocated_push</span>:</b> When sending large, self-constructed messages, using <span class="tt">actor.getPipe(...).allocated_push&lt;MyEvent&gt;(total_size_hint, ...)</span> can help pre-allocate a sufficiently large contiguous block in the communication pipe. If <span class="tt">MyEvent</span> is designed to then directly use parts of this pre-allocated block for its payload (e.g., by constructing an internal <span class="tt">qb::string_view</span> that points into this tail data), you can minimize intermediate buffer copies.</li>
</ul>
</li>
<li><b>Message Batching:</b> For very high-throughput scenarios where individual event overhead is a concern, actors can implement a batching pattern: accumulate multiple small logical messages into a single larger <span class="tt">BatchEvent</span> before sending. The recipient then iterates through the items in the batch.</li>
</ul>
<h2>3. Dynamic Load Balancing &amp; Work Distribution</h2>
<p>Beyond simple round-robin, more sophisticated load balancing can be implemented:</p>
<ul>
<li><b>Metrics-Based Dispatch:</b> A dispatcher/scheduler actor can collect metrics from worker actors (e.g., current queue depth, CPU utilization, processing time per task via <span class="tt">WorkerStatusMessage</span>). It then uses these metrics to route new tasks to the least loaded or most performant available worker.<ul>
<li>Workers would periodically <span class="tt">push</span> <span class="tt">WorkerStatusUpdate</span> events to the scheduler.</li>
</ul>
</li>
<li><b>Work-Stealing (Conceptual):</b> Idle worker actors could proactively request work from a central queue or even from other busy worker actors (requires careful protocol design to avoid contention).</li>
<li><b>Adaptive Concurrency:</b> A manager actor could monitor system load and dynamically create or terminate worker actors to match demand (though actor creation/destruction has overhead, so this is for longer-term load changes).</li>
</ul>
<p><b>(Reference:</b> <span class="tt">example/core/example10_distributed_computing.cpp</span>'s <span class="tt">TaskSchedulerActor</span> implements a basic form of load awareness by checking worker availability and (conceptually) utilization before assigning tasks.)**</p>
<h2>4. Advanced State Management &amp; Persistence</h2>
<p>For actors requiring durable state or complex state recovery:</p>
<ul>
<li><b>Event Sourcing:</b> Instead of just storing the current state, an actor persists the sequence of events that led to its current state. To recover, it replays these events. This can be complex but offers powerful auditing and debugging capabilities.<ul>
<li>The actor would, upon processing a state-changing event, also send this event (or a derivative) to a dedicated <span class="tt">PersistenceActor</span>.</li>
</ul>
</li>
<li><b>Snapshotting:</b> Periodically, or after a certain number_of_events, an actor can serialize its current full state (a snapshot) and send it to a <span class="tt">PersistenceActor</span>. Recovery involves loading the latest snapshot and then replaying only the events that occurred after that snapshot.</li>
<li><b>Dedicated Persistence Actor(s):</b> Abstract database or file system interactions into one or more <span class="tt">PersistenceActor</span>s. Other actors send <span class="tt">SaveStateEvent</span> or <span class="tt">LoadStateRequest</span> events. This centralizes and serializes access to the storage medium.</li>
</ul>
<p><b>(Reference:</b> <span class="tt">qb/source/core/tests/system/test-actor-state-persistence.cpp</span> demonstrates a basic in-memory persistence and recovery simulation.)**</p>
<h2>5. Interfacing with Blocking/External Systems Safely</h2>
<p>When actors must interact with legacy blocking libraries or external systems that don't offer asynchronous APIs:</p>
<ul>
<li><b>Dedicated Worker Actor Pool:</b> Create a pool of worker actors (potentially on <span class="tt">VirtualCore</span>s configured with higher latency to reduce CPU spin when blocked) whose sole job is to handle these blocking calls.<ul>
<li>Your main application actors <span class="tt">push</span> a <span class="tt">BlockingRequestEvent</span> to a dispatcher.</li>
<li>The dispatcher forwards the request to an available worker from the pool.</li>
<li>The worker actor performs the blocking call (its <span class="tt">VirtualCore</span> will block for that actor, but other cores/actors remain responsive).</li>
<li>Upon completion, the worker <span class="tt">push</span>es a <span class="tt">BlockingResponseEvent</span> back to the original requester.</li>
</ul>
</li>
<li><b><span class="tt"><a class="el" href="group___async.html#ga79acd187eb2aeb629523ebb206ee004d" title="Utility function to schedule a callable for execution after a timeout.">qb::io::async::callback</a></span> (for short, infrequent calls):</b> As detailed in Integrating Core &amp; IO: Asynchronous Operations within Actors, you can wrap a blocking call in a lambda scheduled by <span class="tt">async::callback</span>. While the callback itself will block its turn on the <span class="tt">VirtualCore</span>, it prevents the main event handler from blocking.</li>
</ul>
<p><b>(Reference:</b> <span class="tt">example/core_io/file_processor/</span> uses <span class="tt">async::callback</span> within its <span class="tt">FileWorker</span> actors to handle blocking file I/O.)**</p>
<h2>6. Custom Actor Schedulers &amp; <span class="tt">VirtualCore</span> Customization (Conceptual/Advanced)</h2>
<p>While <span class="tt">qb-core</span> provides a robust general-purpose scheduler within each <span class="tt">VirtualCore</span>, extremely advanced scenarios <em>could</em> (with framework modification or careful hooking, if possible) involve:</p>
<ul>
<li><b>Priority Queues for Events:</b> Modifying <span class="tt">VirtualCore</span> to use priority queues for actor mailboxes if certain actors or event types have stringent real-time requirements over others on the same core.</li>
<li><b>Custom <span class="tt">VirtualCore</span> Logic:</b> For deeply embedded systems or specialized hardware, one might envision a scenario requiring modifications to the <span class="tt">VirtualCore</span>'s main loop itself. This is far beyond typical usage and would involve in-depth understanding of QB's internals.</li>
</ul>
<p>These advanced patterns and techniques require a solid understanding of both the Actor Model and QB's specific implementation. Always start with simpler patterns and only introduce more complexity when performance measurements or system requirements clearly justify it. The provided examples are excellent resources for seeing many of these concepts in action.</p>
<p><b>(Next:</b> Consider exploring Guides: Performance Tuning Guide or Guides: Error Handling &amp; Resilience Guide for more specialized advice.**) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="index.html">QB Actor Framework: High-Performance C++17 Concurrent Systems</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
