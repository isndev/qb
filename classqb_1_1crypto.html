<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <head>
        <meta http-equiv="cache-control" content="max-age=86400"/>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta http-equiv="X-UA-Compatible" content="IE=9"/>
        <meta name="generator" content="Doxygen 1.14.0"/>
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <title>qb: qb::crypto Class Reference</title>
        <meta name="description" content="qb OpenSource C++17 Actor Framework Documentation, all API detailed">
        <meta name="keywords"
              content="qb, cube, actor, framework, actor framework, opensource, cpp, c++, cpp17, c++17, documentation, docs, git">
        <meta name="author" content="isndev">
        <!-- BEGIN opengraph metadata -->
<!--        <meta property="og:title" content="Doxygen Awesome"/>-->
<!--        <meta property="og:image"-->
<!--              content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>-->
<!--        <meta property="og:description"-->
<!--              content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>-->
<!--        <meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/"/>-->
        <!-- END opengraph metadata -->
        <!-- BEGIN twitter metadata -->
<!--        <meta name="twitter:image:src"-->
<!--              content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>-->
<!--        <meta name="twitter:title" content="Doxygen Awesome"/>-->
<!--        <meta name="twitter:description"-->
<!--              content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>-->
        <!-- END twitter metadata -->
        <title>qb: qb::crypto Class Reference</title>
        <link href="tabs.css" rel="stylesheet" type="text/css"/>
        <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
        <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
        <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
        <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
        <script type="text/javascript" src="toggle-alternative-theme.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeFragmentCopyButton.init()
            DoxygenAwesomeDarkModeToggle.init()
            DoxygenAwesomeParagraphLink.init()
            DoxygenAwesomeInteractiveToc.init()
            DoxygenAwesomeTabs.init()
        </script>
        <script async defer src="https://buttons.github.io/buttons.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css"/>
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
    </head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/isndev/qb" class="github-corner" title="View source on GitHub"
   target="_blank" rel="noopener noreferrer">
    <svg viewBox="0 0 250 250" width="40" height="40"
         style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
<style>.github-corner:hover .octo-arm {
    animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
    0%, 100% {
        transform: rotate(0)
    }
    20%, 60% {
        transform: rotate(-25deg)
    }
    40%, 80% {
        transform: rotate(10deg)
    }
}
@media (max-width: 500px) {
    .github-corner:hover .octo-arm {
        animation: none
    }
    .github-corner .octo-arm {
        animation: octocat-wave 560ms ease-in-out
    }
}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
            <tr style="height: 56px;">
                <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
                <td id="projectalign" style="padding-left: 0.5em;">
                    <div id="projectname">qb
                        &#160;<span id="projectnumber">2.0.0.0</span>
                    </div>
                    <div id="projectbrief">C++17 Actor Framework</div>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
    <div style="padding-left: 0.5em;">
        <a class="navbar-brand" href="https://github.com/isndev/qb">
            <img src="GitHub-Mark-64px.png" width="32px" alt="qb">
        </a>
        <a class="github-button" href="https://github.com/isndev/qb/issues" data-icon="octicon-issue-opened" data-size="large" data-show-count="true" aria-label="Issue isndev/qb on GitHub">Issue</a>
        <a class="github-button" href="https://github.com/isndev/qb/subscription" data-icon="octicon-eye" data-size="large" data-show-count="true" aria-label="Watch isndev/qb on GitHub">Watch</a>
        <a class="github-button" href="https://github.com/isndev/qb" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star isndev/qb on GitHub">Star</a>
        <a class="github-button" href="https://github.com/isndev/qb/fork" data-icon="octicon-repo-forked" data-size="large" data-show-count="true" aria-label="Fork isndev/qb on GitHub">Fork</a>
        <a class="github-button" href="https://github.com/isndev" data-size="large" data-show-count="false" aria-label="Follow @isndev on GitHub">Follow @isndev</a>
    </div>
    <!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classqb_1_1crypto.html','','classqb_1_1crypto-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">qb::crypto Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provides cryptographic operations and utilities.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="crypto_8h_source.html">crypto.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:Argon2Params" id="r_Argon2Params"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1crypto_1_1_argon2_params.html">Argon2Params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for the Argon2 algorithm.  <a href="structqb_1_1crypto_1_1_argon2_params.html#details">More...</a><br /></td></tr>
<tr class="memitem:base64" id="r_base64"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqb_1_1crypto_1_1base64.html">base64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base64 encoding and decoding utilities.  <a href="classqb_1_1crypto_1_1base64.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3dc6cc6aba197cc631c114a5fbee0035" id="r_a3dc6cc6aba197cc631c114a5fbee0035"><td class="memItemLeft" align="right" valign="top"><a id="a3dc6cc6aba197cc631c114a5fbee0035" name="a3dc6cc6aba197cc631c114a5fbee0035"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dc6cc6aba197cc631c114a5fbee0035">SymmetricAlgorithm</a> { <br />
&#160;&#160;<b>AES_128_CBC</b>
, <b>AES_192_CBC</b>
, <b>AES_256_CBC</b>
, <b>AES_128_GCM</b>
, <br />
&#160;&#160;<b>AES_192_GCM</b>
, <b>AES_256_GCM</b>
, <b>CHACHA20_POLY1305</b>
<br />
 }</td></tr>
<tr class="memdesc:a3dc6cc6aba197cc631c114a5fbee0035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported symmetric cipher algorithms. <br /></td></tr>
<tr class="memitem:aa9baac0850aa32d59d2107994f250020" id="r_aa9baac0850aa32d59d2107994f250020"><td class="memItemLeft" align="right" valign="top"><a id="aa9baac0850aa32d59d2107994f250020" name="aa9baac0850aa32d59d2107994f250020"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a> { <br />
&#160;&#160;<b>MD5</b>
, <b>SHA1</b>
, <b>SHA224</b>
, <b>SHA256</b>
, <br />
&#160;&#160;<b>SHA384</b>
, <b>SHA512</b>
, <b>BLAKE2B512</b>
, <b>BLAKE2S256</b>
<br />
 }</td></tr>
<tr class="memdesc:aa9baac0850aa32d59d2107994f250020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported digest algorithms. <br /></td></tr>
<tr class="memitem:a1b38f47f57580c2be964057f3b92c853" id="r_a1b38f47f57580c2be964057f3b92c853"><td class="memItemLeft" align="right" valign="top"><a id="a1b38f47f57580c2be964057f3b92c853" name="a1b38f47f57580c2be964057f3b92c853"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b38f47f57580c2be964057f3b92c853">Argon2Variant</a> { <b>Argon2d</b>
, <b>Argon2i</b>
, <b>Argon2id</b>
 }</td></tr>
<tr class="memdesc:a1b38f47f57580c2be964057f3b92c853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the Argon2 algorithm. <br /></td></tr>
<tr class="memitem:ab2218dcc7621b7edc22474a9d32df57f" id="r_ab2218dcc7621b7edc22474a9d32df57f"><td class="memItemLeft" align="right" valign="top"><a id="ab2218dcc7621b7edc22474a9d32df57f" name="ab2218dcc7621b7edc22474a9d32df57f"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2218dcc7621b7edc22474a9d32df57f">KdfAlgorithm</a> { <b>PBKDF2</b>
, <b>HKDF</b>
, <b>Argon2</b>
 }</td></tr>
<tr class="memdesc:ab2218dcc7621b7edc22474a9d32df57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key derivation algorithms. <br /></td></tr>
<tr class="memitem:acdd92c899174254b76054486f506b8a5" id="r_acdd92c899174254b76054486f506b8a5"><td class="memItemLeft" align="right" valign="top"><a id="acdd92c899174254b76054486f506b8a5" name="acdd92c899174254b76054486f506b8a5"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdd92c899174254b76054486f506b8a5">ECIESMode</a> { <b>STANDARD</b>
, <b>AES_GCM</b>
, <b>CHACHA20</b>
 }</td></tr>
<tr class="memdesc:acdd92c899174254b76054486f506b8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation modes for elliptic curve encryption. <br /></td></tr>
<tr class="memitem:a93b1d3e401a5a50114601f7de079c036" id="r_a93b1d3e401a5a50114601f7de079c036"><td class="memItemLeft" align="right" valign="top"><a id="a93b1d3e401a5a50114601f7de079c036" name="a93b1d3e401a5a50114601f7de079c036"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93b1d3e401a5a50114601f7de079c036">EnvelopeFormat</a> { <b>RAW</b>
, <b>JSON</b>
, <b>BASE64</b>
 }</td></tr>
<tr class="memdesc:a93b1d3e401a5a50114601f7de079c036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format for envelope encryption outputs. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6e1c8f2386e4178b16111c6eae6160d" id="r_ab6e1c8f2386e4178b16111c6eae6160d"><td class="memTemplParams" colspan="2">template&lt;typename T, std::size_t N&gt; </td></tr>
<tr class="memitem:ab6e1c8f2386e4178b16111c6eae6160d template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6e1c8f2386e4178b16111c6eae6160d">generate_random_string</a> (std::size_t len, const T range[N])</td></tr>
<tr class="memdesc:ab6e1c8f2386e4178b16111c6eae6160d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random string using characters from the specified array.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6dc795342c75e5524951f981e57f5768" id="r_a6dc795342c75e5524951f981e57f5768"><td class="memTemplParams" colspan="2">template&lt;typename T = std::mt19937&gt; </td></tr>
<tr class="memitem:a6dc795342c75e5524951f981e57f5768 template"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dc795342c75e5524951f981e57f5768">random_generator</a> ()</td></tr>
<tr class="memdesc:a6dc795342c75e5524951f981e57f5768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cryptographically secure random number generator.  <br /></td></tr>
<tr class="memitem:a56de53666187e1121fca00c4d07441fe" id="r_a56de53666187e1121fca00c4d07441fe"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a56de53666187e1121fca00c4d07441fe template"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56de53666187e1121fca00c4d07441fe">generate_random_string</a> (std::size_t len, T const &amp;range)</td></tr>
<tr class="memdesc:a56de53666187e1121fca00c4d07441fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random string using characters from the specified range.  <br /></td></tr>
<tr class="memitem:a4a358f323d4318fa3da5f0b03563a297" id="r_a4a358f323d4318fa3da5f0b03563a297"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a358f323d4318fa3da5f0b03563a297">to_hex_string</a> (const std::string &amp;input, std::string_view const &amp;range=<a class="el" href="#a7e688d7de6279dbf5202e942dd2791d7">range_hex_upper</a>) noexcept</td></tr>
<tr class="memdesc:a4a358f323d4318fa3da5f0b03563a297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a binary string to a hexadecimal string.  <br /></td></tr>
<tr class="memitem:a3f956037ca222400e3cf27276ccce3d5" id="r_a3f956037ca222400e3cf27276ccce3d5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f956037ca222400e3cf27276ccce3d5">hex_value</a> (unsigned char hex_digit) noexcept</td></tr>
<tr class="memdesc:a3f956037ca222400e3cf27276ccce3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the numeric value of a hexadecimal digit.  <br /></td></tr>
<tr class="memitem:a6eaf13a9597cc9bb53a600a44f25a723" id="r_a6eaf13a9597cc9bb53a600a44f25a723"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eaf13a9597cc9bb53a600a44f25a723">hex_to_string</a> (const std::string &amp;input) noexcept</td></tr>
<tr class="memdesc:a6eaf13a9597cc9bb53a600a44f25a723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a hexadecimal string to a formatted string.  <br /></td></tr>
<tr class="memitem:a45c47d127b9af3a940407b1900ab5b0d" id="r_a45c47d127b9af3a940407b1900ab5b0d"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45c47d127b9af3a940407b1900ab5b0d">evp</a> (std::istream &amp;stream, const EVP_MD *md) noexcept</td></tr>
<tr class="memdesc:a45c47d127b9af3a940407b1900ab5b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a hash from an input stream using a specified digest algorithm.  <br /></td></tr>
<tr class="memitem:a6bc244cd56f0ae91af0e26fff42336b7" id="r_a6bc244cd56f0ae91af0e26fff42336b7"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bc244cd56f0ae91af0e26fff42336b7">md5</a> (const std::string &amp;input, std::size_t iterations=1) noexcept</td></tr>
<tr class="memdesc:a6bc244cd56f0ae91af0e26fff42336b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate an MD5 hash of a string.  <br /></td></tr>
<tr class="memitem:a9611fc14165417ee6ed5b9102371dbd2" id="r_a9611fc14165417ee6ed5b9102371dbd2"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9611fc14165417ee6ed5b9102371dbd2">md5</a> (std::istream &amp;stream, std::size_t iterations=1) noexcept</td></tr>
<tr class="memdesc:a9611fc14165417ee6ed5b9102371dbd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate an MD5 hash of data from an input stream.  <br /></td></tr>
<tr class="memitem:a25dee0e95588af5fac391cee41fa2d3c" id="r_a25dee0e95588af5fac391cee41fa2d3c"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25dee0e95588af5fac391cee41fa2d3c">sha1</a> (const std::string &amp;input, std::size_t iterations=1) noexcept</td></tr>
<tr class="memdesc:a25dee0e95588af5fac391cee41fa2d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a SHA-1 hash of a string.  <br /></td></tr>
<tr class="memitem:ad5b33c52aa893ba165012cf54499cb83" id="r_ad5b33c52aa893ba165012cf54499cb83"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5b33c52aa893ba165012cf54499cb83">sha1</a> (std::istream &amp;stream, std::size_t iterations=1) noexcept</td></tr>
<tr class="memdesc:ad5b33c52aa893ba165012cf54499cb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a SHA-1 hash of data from an input stream.  <br /></td></tr>
<tr class="memitem:ae82036ab1a0852392da4425506375b6e" id="r_ae82036ab1a0852392da4425506375b6e"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae82036ab1a0852392da4425506375b6e">sha256</a> (const std::string &amp;input, std::size_t iterations=1) noexcept</td></tr>
<tr class="memdesc:ae82036ab1a0852392da4425506375b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a SHA-256 hash of a string.  <br /></td></tr>
<tr class="memitem:a5a3ad2fc11ba527a8e688ec27de7bf7c" id="r_a5a3ad2fc11ba527a8e688ec27de7bf7c"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a3ad2fc11ba527a8e688ec27de7bf7c">sha256</a> (std::istream &amp;stream, std::size_t iterations=1) noexcept</td></tr>
<tr class="memdesc:a5a3ad2fc11ba527a8e688ec27de7bf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a SHA-256 hash of data from an input stream.  <br /></td></tr>
<tr class="memitem:add88ab35aa40c679ca19daa0105baa64" id="r_add88ab35aa40c679ca19daa0105baa64"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add88ab35aa40c679ca19daa0105baa64">sha512</a> (const std::string &amp;input, std::size_t iterations=1) noexcept</td></tr>
<tr class="memdesc:add88ab35aa40c679ca19daa0105baa64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a SHA-512 hash of a string.  <br /></td></tr>
<tr class="memitem:a5c603766c90ce0ef14db1cd0146e53ab" id="r_a5c603766c90ce0ef14db1cd0146e53ab"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c603766c90ce0ef14db1cd0146e53ab">sha512</a> (std::istream &amp;stream, std::size_t iterations=1) noexcept</td></tr>
<tr class="memdesc:a5c603766c90ce0ef14db1cd0146e53ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a SHA-512 hash of data from an input stream.  <br /></td></tr>
<tr class="memitem:a494748b097bce83f3d2202d65f39a580" id="r_a494748b097bce83f3d2202d65f39a580"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a494748b097bce83f3d2202d65f39a580">pbkdf2</a> (const std::string &amp;password, const std::string &amp;salt, int iterations, int key_size) noexcept</td></tr>
<tr class="memdesc:a494748b097bce83f3d2202d65f39a580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive a key using PBKDF2.  <br /></td></tr>
<tr class="memitem:aaaf36d810a1ed90fcadb4558047b779d" id="r_aaaf36d810a1ed90fcadb4558047b779d"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaf36d810a1ed90fcadb4558047b779d">base64_encode</a> (const unsigned char *data, size_t len)</td></tr>
<tr class="memdesc:aaaf36d810a1ed90fcadb4558047b779d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode binary data to Base64.  <br /></td></tr>
<tr class="memitem:ab01379bb4580a342eddfebd9a47c9a31" id="r_ab01379bb4580a342eddfebd9a47c9a31"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab01379bb4580a342eddfebd9a47c9a31">base64_decode</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:ab01379bb4580a342eddfebd9a47c9a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a Base64 string to binary data.  <br /></td></tr>
<tr class="memitem:aeebe506bfbd4a4944f19401de98783a2" id="r_aeebe506bfbd4a4944f19401de98783a2"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeebe506bfbd4a4944f19401de98783a2">hmac_sha256</a> (const std::vector&lt; unsigned char &gt; &amp;key, const std::string &amp;data)</td></tr>
<tr class="memdesc:aeebe506bfbd4a4944f19401de98783a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate an HMAC-SHA256 hash.  <br /></td></tr>
<tr class="memitem:a3fa7e57b305f9f97ccf61b88564ed893" id="r_a3fa7e57b305f9f97ccf61b88564ed893"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fa7e57b305f9f97ccf61b88564ed893">sha256</a> (const std::vector&lt; unsigned char &gt; &amp;data)</td></tr>
<tr class="memdesc:a3fa7e57b305f9f97ccf61b88564ed893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a SHA-256 hash of binary data.  <br /></td></tr>
<tr class="memitem:aae8460e29e8eb769189949ac8c0a42ce" id="r_aae8460e29e8eb769189949ac8c0a42ce"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae8460e29e8eb769189949ac8c0a42ce">xor_bytes</a> (const std::vector&lt; unsigned char &gt; &amp;a, const std::vector&lt; unsigned char &gt; &amp;b)</td></tr>
<tr class="memdesc:aae8460e29e8eb769189949ac8c0a42ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">XOR two byte arrays.  <br /></td></tr>
<tr class="memitem:a2325c465d5d1dc0e4ac987a67997327c" id="r_a2325c465d5d1dc0e4ac987a67997327c"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2325c465d5d1dc0e4ac987a67997327c">generate_random_bytes</a> (size_t size)</td></tr>
<tr class="memdesc:a2325c465d5d1dc0e4ac987a67997327c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate cryptographically secure random bytes.  <br /></td></tr>
<tr class="memitem:a03250715314f502010304ede67ee9f79" id="r_a03250715314f502010304ede67ee9f79"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03250715314f502010304ede67ee9f79">generate_iv</a> (<a class="el" href="#a3dc6cc6aba197cc631c114a5fbee0035">SymmetricAlgorithm</a> algorithm)</td></tr>
<tr class="memdesc:a03250715314f502010304ede67ee9f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random initialization vector (IV)  <br /></td></tr>
<tr class="memitem:a74eab972433b79c9b1b83eac8d168cb4" id="r_a74eab972433b79c9b1b83eac8d168cb4"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74eab972433b79c9b1b83eac8d168cb4">generate_key</a> (<a class="el" href="#a3dc6cc6aba197cc631c114a5fbee0035">SymmetricAlgorithm</a> algorithm)</td></tr>
<tr class="memdesc:a74eab972433b79c9b1b83eac8d168cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random key.  <br /></td></tr>
<tr class="memitem:a775bdd4a85eaf210e23a3f35b841b252" id="r_a775bdd4a85eaf210e23a3f35b841b252"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a775bdd4a85eaf210e23a3f35b841b252">encrypt</a> (const std::vector&lt; unsigned char &gt; &amp;plaintext, const std::vector&lt; unsigned char &gt; &amp;key, const std::vector&lt; unsigned char &gt; &amp;iv, <a class="el" href="#a3dc6cc6aba197cc631c114a5fbee0035">SymmetricAlgorithm</a> algorithm, const std::vector&lt; unsigned char &gt; &amp;aad={})</td></tr>
<tr class="memdesc:a775bdd4a85eaf210e23a3f35b841b252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt data using a symmetric algorithm.  <br /></td></tr>
<tr class="memitem:a19cfa489c501d7f68be4ba724c0fc5a3" id="r_a19cfa489c501d7f68be4ba724c0fc5a3"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19cfa489c501d7f68be4ba724c0fc5a3">decrypt</a> (const std::vector&lt; unsigned char &gt; &amp;ciphertext, const std::vector&lt; unsigned char &gt; &amp;key, const std::vector&lt; unsigned char &gt; &amp;iv, <a class="el" href="#a3dc6cc6aba197cc631c114a5fbee0035">SymmetricAlgorithm</a> algorithm, const std::vector&lt; unsigned char &gt; &amp;aad={})</td></tr>
<tr class="memdesc:a19cfa489c501d7f68be4ba724c0fc5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt data using a symmetric algorithm.  <br /></td></tr>
<tr class="memitem:a7112f44fc7bb183ee03a805bfaf2ae46" id="r_a7112f44fc7bb183ee03a805bfaf2ae46"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7112f44fc7bb183ee03a805bfaf2ae46">hash</a> (const std::vector&lt; unsigned char &gt; &amp;data, <a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a> algorithm)</td></tr>
<tr class="memdesc:a7112f44fc7bb183ee03a805bfaf2ae46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a generic hash using the specified algorithm.  <br /></td></tr>
<tr class="memitem:a93bc2b6cddb536aa808a9e11ec42dd79" id="r_a93bc2b6cddb536aa808a9e11ec42dd79"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93bc2b6cddb536aa808a9e11ec42dd79">hmac</a> (const std::vector&lt; unsigned char &gt; &amp;data, const std::vector&lt; unsigned char &gt; &amp;key, <a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a> algorithm)</td></tr>
<tr class="memdesc:a93bc2b6cddb536aa808a9e11ec42dd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an HMAC using the specified algorithm.  <br /></td></tr>
<tr class="memitem:afd898a5aa629545adea2d4d7084b3246" id="r_afd898a5aa629545adea2d4d7084b3246"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd898a5aa629545adea2d4d7084b3246">generate_rsa_keypair</a> (int bits=2048)</td></tr>
<tr class="memdesc:afd898a5aa629545adea2d4d7084b3246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an RSA key pair.  <br /></td></tr>
<tr class="memitem:a9f41fb828e9a702b5240a871f78f91f2" id="r_a9f41fb828e9a702b5240a871f78f91f2"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f41fb828e9a702b5240a871f78f91f2">generate_ec_keypair</a> (const std::string &amp;curve=&quot;prime256v1&quot;)</td></tr>
<tr class="memdesc:a9f41fb828e9a702b5240a871f78f91f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an EC key pair.  <br /></td></tr>
<tr class="memitem:a7e01b5668c4b51ab494c57890314c7d7" id="r_a7e01b5668c4b51ab494c57890314c7d7"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e01b5668c4b51ab494c57890314c7d7">rsa_sign</a> (const std::vector&lt; unsigned char &gt; &amp;data, const std::string &amp;private_key, <a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a> digest=DigestAlgorithm::SHA256)</td></tr>
<tr class="memdesc:a7e01b5668c4b51ab494c57890314c7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign data using an RSA private key.  <br /></td></tr>
<tr class="memitem:a87f50ea6b212e1af62efe13031491bbd" id="r_a87f50ea6b212e1af62efe13031491bbd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87f50ea6b212e1af62efe13031491bbd">rsa_verify</a> (const std::vector&lt; unsigned char &gt; &amp;data, const std::vector&lt; unsigned char &gt; &amp;signature, const std::string &amp;public_key, <a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a> digest=DigestAlgorithm::SHA256)</td></tr>
<tr class="memdesc:a87f50ea6b212e1af62efe13031491bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify an RSA signature.  <br /></td></tr>
<tr class="memitem:a9df504e09b43b66699a3e48718550e57" id="r_a9df504e09b43b66699a3e48718550e57"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9df504e09b43b66699a3e48718550e57">ec_sign</a> (const std::vector&lt; unsigned char &gt; &amp;data, const std::string &amp;private_key, <a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a> digest=DigestAlgorithm::SHA256)</td></tr>
<tr class="memdesc:a9df504e09b43b66699a3e48718550e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign data using an EC private key.  <br /></td></tr>
<tr class="memitem:a43a36ed173db106fcd4103d9fc3678f5" id="r_a43a36ed173db106fcd4103d9fc3678f5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43a36ed173db106fcd4103d9fc3678f5">ec_verify</a> (const std::vector&lt; unsigned char &gt; &amp;data, const std::vector&lt; unsigned char &gt; &amp;signature, const std::string &amp;public_key, <a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a> digest=DigestAlgorithm::SHA256)</td></tr>
<tr class="memdesc:a43a36ed173db106fcd4103d9fc3678f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify an EC signature.  <br /></td></tr>
<tr class="memitem:a82c82e5cb0be1e4db2f8616917c0d016" id="r_a82c82e5cb0be1e4db2f8616917c0d016"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82c82e5cb0be1e4db2f8616917c0d016">ecdh_derive_secret</a> (const std::string &amp;private_key, const std::string &amp;peer_public_key)</td></tr>
<tr class="memdesc:a82c82e5cb0be1e4db2f8616917c0d016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive a shared secret using ECDH.  <br /></td></tr>
<tr class="memitem:a5387b3da9c628d4556591409596ddee5" id="r_a5387b3da9c628d4556591409596ddee5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5387b3da9c628d4556591409596ddee5">secure_random_fill</a> (std::vector&lt; unsigned char &gt; &amp;buffer)</td></tr>
<tr class="memdesc:a5387b3da9c628d4556591409596ddee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a vector with secure random bytes.  <br /></td></tr>
<tr class="memitem:a60e279c13288a2cb44f4fae17835d18d" id="r_a60e279c13288a2cb44f4fae17835d18d"><td class="memItemLeft" align="right" valign="top">static const EVP_MD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60e279c13288a2cb44f4fae17835d18d">get_evp_md</a> (<a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a> algorithm)</td></tr>
<tr class="memdesc:a60e279c13288a2cb44f4fae17835d18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a digest algorithm enum to its corresponding EVP_MD.  <br /></td></tr>
<tr class="memitem:a795239ffdd3cf43d187ef478f5337f44" id="r_a795239ffdd3cf43d187ef478f5337f44"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a795239ffdd3cf43d187ef478f5337f44">argon2_kdf</a> (const std::string &amp;password, size_t key_length, const <a class="el" href="structqb_1_1crypto_1_1_argon2_params.html">Argon2Params</a> &amp;params, <a class="el" href="#a1b38f47f57580c2be964057f3b92c853">Argon2Variant</a> variant=Argon2Variant::Argon2id)</td></tr>
<tr class="memdesc:a795239ffdd3cf43d187ef478f5337f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key derivation based on Argon2.  <br /></td></tr>
<tr class="memitem:a3b1b324752d0880147e099095a336dcf" id="r_a3b1b324752d0880147e099095a336dcf"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b1b324752d0880147e099095a336dcf">hkdf</a> (const std::vector&lt; unsigned char &gt; &amp;input_key_material, const std::vector&lt; unsigned char &gt; &amp;salt, const std::vector&lt; unsigned char &gt; &amp;info, size_t output_length, <a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a> digest=DigestAlgorithm::SHA256)</td></tr>
<tr class="memdesc:a3b1b324752d0880147e099095a336dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key derivation with HKDF (HMAC-based Key Derivation Function)  <br /></td></tr>
<tr class="memitem:ab21ccbc086ea5f5be541992d1272e026" id="r_ab21ccbc086ea5f5be541992d1272e026"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab21ccbc086ea5f5be541992d1272e026">derive_key</a> (const std::string &amp;password, const std::vector&lt; unsigned char &gt; &amp;salt, size_t key_length, <a class="el" href="#ab2218dcc7621b7edc22474a9d32df57f">KdfAlgorithm</a> algorithm=KdfAlgorithm::Argon2, int iterations=10000, const <a class="el" href="structqb_1_1crypto_1_1_argon2_params.html">Argon2Params</a> &amp;argon2_params=<a class="el" href="structqb_1_1crypto_1_1_argon2_params.html">Argon2Params</a>())</td></tr>
<tr class="memdesc:ab21ccbc086ea5f5be541992d1272e026"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level function to derive a key from a password.  <br /></td></tr>
<tr class="memitem:a51f2dc509048b556eefb4be1c82ef3f2" id="r_a51f2dc509048b556eefb4be1c82ef3f2"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51f2dc509048b556eefb4be1c82ef3f2">ecies_encrypt</a> (const std::vector&lt; unsigned char &gt; &amp;plaintext, const std::string &amp;recipient_public_key, <a class="el" href="#acdd92c899174254b76054486f506b8a5">ECIESMode</a> mode=ECIESMode::AES_GCM, <a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a> digest=DigestAlgorithm::SHA256)</td></tr>
<tr class="memdesc:a51f2dc509048b556eefb4be1c82ef3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrated Elliptic Curve Encryption (ECIES)  <br /></td></tr>
<tr class="memitem:ae503a31081ec06eb01720c3aea2d7375" id="r_ae503a31081ec06eb01720c3aea2d7375"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae503a31081ec06eb01720c3aea2d7375">ecies_decrypt</a> (const std::vector&lt; unsigned char &gt; &amp;ciphertext, const std::string &amp;private_key, <a class="el" href="#acdd92c899174254b76054486f506b8a5">ECIESMode</a> mode=ECIESMode::AES_GCM, <a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a> digest=DigestAlgorithm::SHA256)</td></tr>
<tr class="memdesc:ae503a31081ec06eb01720c3aea2d7375"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECIES decryption.  <br /></td></tr>
<tr class="memitem:a307732d9f9c3e595a23d09a23ead8f92" id="r_a307732d9f9c3e595a23d09a23ead8f92"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a307732d9f9c3e595a23d09a23ead8f92">envelope_encrypt</a> (const std::vector&lt; unsigned char &gt; &amp;plaintext, const std::string &amp;recipient_public_key, <a class="el" href="#a3dc6cc6aba197cc631c114a5fbee0035">SymmetricAlgorithm</a> algorithm=SymmetricAlgorithm::AES_256_GCM, <a class="el" href="#a93b1d3e401a5a50114601f7de079c036">EnvelopeFormat</a> format=EnvelopeFormat::BASE64)</td></tr>
<tr class="memdesc:a307732d9f9c3e595a23d09a23ead8f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Envelope encryption.  <br /></td></tr>
<tr class="memitem:adfb2bcae81cb8b6fcf97656b20912ecc" id="r_adfb2bcae81cb8b6fcf97656b20912ecc"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfb2bcae81cb8b6fcf97656b20912ecc">envelope_decrypt</a> (const std::string &amp;ciphertext, const std::string &amp;private_key, <a class="el" href="#a93b1d3e401a5a50114601f7de079c036">EnvelopeFormat</a> format=EnvelopeFormat::BASE64)</td></tr>
<tr class="memdesc:adfb2bcae81cb8b6fcf97656b20912ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Envelope decryption.  <br /></td></tr>
<tr class="memitem:a44bb10510ee107af17bf9f49de761f77" id="r_a44bb10510ee107af17bf9f49de761f77"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44bb10510ee107af17bf9f49de761f77">constant_time_compare</a> (const std::vector&lt; unsigned char &gt; &amp;a, const std::vector&lt; unsigned char &gt; &amp;b)</td></tr>
<tr class="memdesc:a44bb10510ee107af17bf9f49de761f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Secure string comparison (resistant to timing attacks)  <br /></td></tr>
<tr class="memitem:ac99d50240560933847e0c683648aba2e" id="r_ac99d50240560933847e0c683648aba2e"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac99d50240560933847e0c683648aba2e">generate_token</a> (const std::string &amp;payload, const std::vector&lt; unsigned char &gt; &amp;key, uint64_t ttl=0)</td></tr>
<tr class="memdesc:ac99d50240560933847e0c683648aba2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a secure token with optional TTL.  <br /></td></tr>
<tr class="memitem:ad55bb9b9924f57e06e3dddc41a2ab6ed" id="r_ad55bb9b9924f57e06e3dddc41a2ab6ed"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad55bb9b9924f57e06e3dddc41a2ab6ed">verify_token</a> (const std::string &amp;token, const std::vector&lt; unsigned char &gt; &amp;key)</td></tr>
<tr class="memdesc:ad55bb9b9924f57e06e3dddc41a2ab6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify and decrypt a token.  <br /></td></tr>
<tr class="memitem:aded5c61abba9d7c4573cba6a0bc3da22" id="r_aded5c61abba9d7c4573cba6a0bc3da22"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aded5c61abba9d7c4573cba6a0bc3da22">base64url_encode</a> (const std::vector&lt; unsigned char &gt; &amp;data)</td></tr>
<tr class="memdesc:aded5c61abba9d7c4573cba6a0bc3da22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base64URL encode.  <br /></td></tr>
<tr class="memitem:a8777cdd79e7b914b6badb0ea89b76ef6" id="r_a8777cdd79e7b914b6badb0ea89b76ef6"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8777cdd79e7b914b6badb0ea89b76ef6">base64url_decode</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:a8777cdd79e7b914b6badb0ea89b76ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base64URL decode.  <br /></td></tr>
<tr class="memitem:ad4f04d86ebb6b492aa5323aa80995b64" id="r_ad4f04d86ebb6b492aa5323aa80995b64"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4f04d86ebb6b492aa5323aa80995b64">generate_salt</a> (size_t length)</td></tr>
<tr class="memdesc:ad4f04d86ebb6b492aa5323aa80995b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a secure random salt.  <br /></td></tr>
<tr class="memitem:af80097376980c66177d219b2f9d36cc0" id="r_af80097376980c66177d219b2f9d36cc0"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af80097376980c66177d219b2f9d36cc0">hash_password</a> (const std::string &amp;password, <a class="el" href="#a1b38f47f57580c2be964057f3b92c853">Argon2Variant</a> variant=Argon2Variant::Argon2id)</td></tr>
<tr class="memdesc:af80097376980c66177d219b2f9d36cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash a password securely using Argon2.  <br /></td></tr>
<tr class="memitem:a512ab1a68621bfb9a0095a78ace498f9" id="r_a512ab1a68621bfb9a0095a78ace498f9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a512ab1a68621bfb9a0095a78ace498f9">verify_password</a> (const std::string &amp;password, const std::string &amp;<a class="el" href="#a7112f44fc7bb183ee03a805bfaf2ae46">hash</a>)</td></tr>
<tr class="memdesc:a512ab1a68621bfb9a0095a78ace498f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify a password against a stored hash.  <br /></td></tr>
<tr class="memitem:ac38997b22f1f94edfa01bb3a3c575d71" id="r_ac38997b22f1f94edfa01bb3a3c575d71"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac38997b22f1f94edfa01bb3a3c575d71">generate_ed25519_keypair</a> ()</td></tr>
<tr class="memdesc:ac38997b22f1f94edfa01bb3a3c575d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Ed25519 signing key pair.  <br /></td></tr>
<tr class="memitem:afd1b5e94f47544b1665c641dd7aaf8b8" id="r_afd1b5e94f47544b1665c641dd7aaf8b8"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; std::vector&lt; unsigned char &gt;, std::vector&lt; unsigned char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd1b5e94f47544b1665c641dd7aaf8b8">generate_ed25519_keypair_bytes</a> ()</td></tr>
<tr class="memdesc:afd1b5e94f47544b1665c641dd7aaf8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Ed25519 keypair returning raw byte vectors.  <br /></td></tr>
<tr class="memitem:a6c6e60669c546c6855892c1cb7db6c1a" id="r_a6c6e60669c546c6855892c1cb7db6c1a"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c6e60669c546c6855892c1cb7db6c1a">ed25519_sign</a> (const std::vector&lt; unsigned char &gt; &amp;data, const std::string &amp;private_key)</td></tr>
<tr class="memdesc:a6c6e60669c546c6855892c1cb7db6c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign data using Ed25519 private key.  <br /></td></tr>
<tr class="memitem:a0c2d70b97afbbc75d6b0dc9d40dcfc28" id="r_a0c2d70b97afbbc75d6b0dc9d40dcfc28"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c2d70b97afbbc75d6b0dc9d40dcfc28">ed25519_sign</a> (const std::vector&lt; unsigned char &gt; &amp;data, const std::vector&lt; unsigned char &gt; &amp;private_key)</td></tr>
<tr class="memdesc:a0c2d70b97afbbc75d6b0dc9d40dcfc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign data using Ed25519 with raw private key bytes.  <br /></td></tr>
<tr class="memitem:a27913072a9529503e4db135dc3a5e7a0" id="r_a27913072a9529503e4db135dc3a5e7a0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27913072a9529503e4db135dc3a5e7a0">ed25519_verify</a> (const std::vector&lt; unsigned char &gt; &amp;data, const std::vector&lt; unsigned char &gt; &amp;signature, const std::string &amp;public_key)</td></tr>
<tr class="memdesc:a27913072a9529503e4db135dc3a5e7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify Ed25519 signature.  <br /></td></tr>
<tr class="memitem:a2aecd385862132e77cb62405d0a8661f" id="r_a2aecd385862132e77cb62405d0a8661f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2aecd385862132e77cb62405d0a8661f">ed25519_verify</a> (const std::vector&lt; unsigned char &gt; &amp;data, const std::vector&lt; unsigned char &gt; &amp;signature, const std::vector&lt; unsigned char &gt; &amp;public_key)</td></tr>
<tr class="memdesc:a2aecd385862132e77cb62405d0a8661f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify Ed25519 signature with raw public key bytes.  <br /></td></tr>
<tr class="memitem:a8690b21124619c6f25cb6f906d6f0260" id="r_a8690b21124619c6f25cb6f906d6f0260"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8690b21124619c6f25cb6f906d6f0260">generate_x25519_keypair</a> ()</td></tr>
<tr class="memdesc:a8690b21124619c6f25cb6f906d6f0260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate X25519 key pair for key exchange.  <br /></td></tr>
<tr class="memitem:a846ffa65ee494d89f43e3e741d1d075a" id="r_a846ffa65ee494d89f43e3e741d1d075a"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; std::vector&lt; unsigned char &gt;, std::vector&lt; unsigned char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a846ffa65ee494d89f43e3e741d1d075a">generate_x25519_keypair_bytes</a> ()</td></tr>
<tr class="memdesc:a846ffa65ee494d89f43e3e741d1d075a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate X25519 keypair returning raw byte vectors.  <br /></td></tr>
<tr class="memitem:ae432633065943fd87054cc837cd21bd5" id="r_ae432633065943fd87054cc837cd21bd5"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae432633065943fd87054cc837cd21bd5">x25519_key_exchange</a> (const std::vector&lt; unsigned char &gt; &amp;private_key, const std::vector&lt; unsigned char &gt; &amp;peer_public_key)</td></tr>
<tr class="memdesc:ae432633065943fd87054cc837cd21bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">X25519 key exchange.  <br /></td></tr>
<tr class="memitem:ada4bfcbca9dde18e77becfb9db52c4b1" id="r_ada4bfcbca9dde18e77becfb9db52c4b1"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada4bfcbca9dde18e77becfb9db52c4b1">x25519_key_exchange</a> (const std::string &amp;private_key_pem, const std::string &amp;peer_public_key_pem)</td></tr>
<tr class="memdesc:ada4bfcbca9dde18e77becfb9db52c4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">X25519 key exchange with PEM keys.  <br /></td></tr>
<tr class="memitem:a6e4e3e68ef59d816f3561d352a4d165e" id="r_a6e4e3e68ef59d816f3561d352a4d165e"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e4e3e68ef59d816f3561d352a4d165e">generate_unique_iv</a> (size_t size=12)</td></tr>
<tr class="memdesc:a6e4e3e68ef59d816f3561d352a4d165e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random initialization vector for one-time use.  <br /></td></tr>
<tr class="memitem:ae8ac628a653294b207dfa68935724e62" id="r_ae8ac628a653294b207dfa68935724e62"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8ac628a653294b207dfa68935724e62">encrypt_with_metadata</a> (const std::vector&lt; unsigned char &gt; &amp;plaintext, const std::vector&lt; unsigned char &gt; &amp;key, const std::string &amp;metadata, <a class="el" href="#a3dc6cc6aba197cc631c114a5fbee0035">SymmetricAlgorithm</a> algorithm=SymmetricAlgorithm::AES_256_GCM)</td></tr>
<tr class="memdesc:ae8ac628a653294b207dfa68935724e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Authenticated encryption of data with additional authentication.  <br /></td></tr>
<tr class="memitem:a60827e5303b7c30fcd5ecf7ab7376110" id="r_a60827e5303b7c30fcd5ecf7ab7376110"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; std::pair&lt; std::vector&lt; unsigned char &gt;, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60827e5303b7c30fcd5ecf7ab7376110">decrypt_with_metadata</a> (const std::string &amp;ciphertext, const std::vector&lt; unsigned char &gt; &amp;key, <a class="el" href="#a3dc6cc6aba197cc631c114a5fbee0035">SymmetricAlgorithm</a> algorithm=SymmetricAlgorithm::AES_256_GCM)</td></tr>
<tr class="memdesc:a60827e5303b7c30fcd5ecf7ab7376110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decryption and verification of data and metadata integrity.  <br /></td></tr>
<tr class="memitem:af166e687c978e59baaeba97fb63db37b" id="r_af166e687c978e59baaeba97fb63db37b"><td class="memItemLeft" align="right" valign="top"><a id="af166e687c978e59baaeba97fb63db37b" name="af166e687c978e59baaeba97fb63db37b"></a>
static std::pair&lt; std::vector&lt; unsigned char &gt;, std::vector&lt; unsigned char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ecies_encrypt</b> (const std::vector&lt; unsigned char &gt; &amp;data, const std::vector&lt; unsigned char &gt; &amp;recipient_public_key, const std::vector&lt; unsigned char &gt; &amp;optional_shared_info={}, <a class="el" href="#acdd92c899174254b76054486f506b8a5">ECIESMode</a> mode=ECIESMode::AES_GCM)</td></tr>
<tr class="memitem:a1d3e64014e61f6b2c7f7e5ca0b7f5329" id="r_a1d3e64014e61f6b2c7f7e5ca0b7f5329"><td class="memItemLeft" align="right" valign="top"><a id="a1d3e64014e61f6b2c7f7e5ca0b7f5329" name="a1d3e64014e61f6b2c7f7e5ca0b7f5329"></a>
static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ecies_decrypt</b> (const std::vector&lt; unsigned char &gt; &amp;encrypted_data, const std::vector&lt; unsigned char &gt; &amp;ephemeral_public_key, const std::vector&lt; unsigned char &gt; &amp;recipient_private_key, const std::vector&lt; unsigned char &gt; &amp;optional_shared_info={}, <a class="el" href="#acdd92c899174254b76054486f506b8a5">ECIESMode</a> mode=ECIESMode::AES_GCM)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae40d7a9b79da35808a98921743d62825" id="r_ae40d7a9b79da35808a98921743d62825"><td class="memItemLeft" align="right" valign="top"><a id="ae40d7a9b79da35808a98921743d62825" name="ae40d7a9b79da35808a98921743d62825"></a>
static constexpr const std::string_view&#160;</td><td class="memItemRight" valign="bottom"><b>range_numeric</b> = &quot;0123456789&quot;</td></tr>
<tr class="memdesc:ae40d7a9b79da35808a98921743d62825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character range for numeric values (0-9) <br /></td></tr>
<tr class="memitem:a89143319637405f8e9edda59592145e4" id="r_a89143319637405f8e9edda59592145e4"><td class="memItemLeft" align="right" valign="top">static constexpr const std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89143319637405f8e9edda59592145e4">range_alpha</a></td></tr>
<tr class="memdesc:a89143319637405f8e9edda59592145e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character range for alphabetic values (A-Z, a-z)  <br /></td></tr>
<tr class="memitem:a839abf14ac89cdf7a599815879d6be9e" id="r_a839abf14ac89cdf7a599815879d6be9e"><td class="memItemLeft" align="right" valign="top">static constexpr const std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a839abf14ac89cdf7a599815879d6be9e">range_alpha_lower</a></td></tr>
<tr class="memdesc:a839abf14ac89cdf7a599815879d6be9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character range for lowercase alphabetic values (a-z)  <br /></td></tr>
<tr class="memitem:a52957aecdc9ebc35535424a08674e658" id="r_a52957aecdc9ebc35535424a08674e658"><td class="memItemLeft" align="right" valign="top">static constexpr const std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52957aecdc9ebc35535424a08674e658">range_alpha_upper</a></td></tr>
<tr class="memdesc:a52957aecdc9ebc35535424a08674e658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character range for uppercase alphabetic values (A-Z)  <br /></td></tr>
<tr class="memitem:aab651f15bbabb3bae6181407d69b8b33" id="r_aab651f15bbabb3bae6181407d69b8b33"><td class="memItemLeft" align="right" valign="top">static constexpr const std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab651f15bbabb3bae6181407d69b8b33">range_alpha_numeric</a></td></tr>
<tr class="memdesc:aab651f15bbabb3bae6181407d69b8b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character range for alphanumeric values (0-9, A-Z, a-z)  <br /></td></tr>
<tr class="memitem:afb23e117fc8f8822bc18538191bc0cf3" id="r_afb23e117fc8f8822bc18538191bc0cf3"><td class="memItemLeft" align="right" valign="top">static constexpr const std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb23e117fc8f8822bc18538191bc0cf3">range_alpha_numeric_special</a></td></tr>
<tr class="memdesc:afb23e117fc8f8822bc18538191bc0cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character range for alphanumeric values and special characters.  <br /></td></tr>
<tr class="memitem:a7e688d7de6279dbf5202e942dd2791d7" id="r_a7e688d7de6279dbf5202e942dd2791d7"><td class="memItemLeft" align="right" valign="top"><a id="a7e688d7de6279dbf5202e942dd2791d7" name="a7e688d7de6279dbf5202e942dd2791d7"></a>
static constexpr const std::string_view&#160;</td><td class="memItemRight" valign="bottom"><b>range_hex_upper</b> = &quot;0123456789ABCDEF&quot;</td></tr>
<tr class="memdesc:a7e688d7de6279dbf5202e942dd2791d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character range for uppercase hexadecimal values (0-9, A-F) <br /></td></tr>
<tr class="memitem:a287b5784fd741673fbc22c93151a7956" id="r_a287b5784fd741673fbc22c93151a7956"><td class="memItemLeft" align="right" valign="top"><a id="a287b5784fd741673fbc22c93151a7956" name="a287b5784fd741673fbc22c93151a7956"></a>
static constexpr const std::string_view&#160;</td><td class="memItemRight" valign="bottom"><b>range_hex_lower</b> = &quot;0123456789abcdef&quot;</td></tr>
<tr class="memdesc:a287b5784fd741673fbc22c93151a7956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character range for lowercase hexadecimal values (0-9, a-f) <br /></td></tr>
<tr class="memitem:a414ea90f8d442bbad3f19ef0fcecbab1" id="r_a414ea90f8d442bbad3f19ef0fcecbab1"><td class="memItemLeft" align="right" valign="top">static constexpr const std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a414ea90f8d442bbad3f19ef0fcecbab1">range_byte</a></td></tr>
<tr class="memdesc:a414ea90f8d442bbad3f19ef0fcecbab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character range for binary bytes (0-255)  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides cryptographic operations and utilities. </p>
<p>This class serves as a container for cryptographic operations including hashing, encoding, encryption, and random string generation. It provides a collection of static methods that can be called directly. </p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a6dc795342c75e5524951f981e57f5768" name="a6dc795342c75e5524951f981e57f5768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc795342c75e5524951f981e57f5768">&#9670;&#160;</a></span>random_generator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = std::mt19937&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto qb::crypto::random_generator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a cryptographically secure random number generator. </p>
<p>Creates a random number generator of type T (defaulting to mt19937) seeded with a secure random seed sequence.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of random number generator to create (default: std::mt19937) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A securely seeded random number generator </dd></dl>

</div>
</div>
<a id="a56de53666187e1121fca00c4d07441fe" name="a56de53666187e1121fca00c4d07441fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56de53666187e1121fca00c4d07441fe">&#9670;&#160;</a></span>generate_random_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::generate_random_string </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random string using characters from the specified range. </p>
<p>Creates a random string of the specified length using only characters from the provided range.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the character range </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The length of the random string to generate </td></tr>
    <tr><td class="paramname">range</td><td>The range of characters to use in the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random string of the specified length </dd></dl>

</div>
</div>
<a id="ab6e1c8f2386e4178b16111c6eae6160d" name="ab6e1c8f2386e4178b16111c6eae6160d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e1c8f2386e4178b16111c6eae6160d">&#9670;&#160;</a></span>generate_random_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::generate_random_string </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>range</em></span>[N]&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random string using characters from the specified array. </p>
<p>Creates a random string of the specified length using only characters from the provided array.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the character array elements </td></tr>
    <tr><td class="paramname">N</td><td>The size of the character array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The length of the random string to generate </td></tr>
    <tr><td class="paramname">range</td><td>The array of characters to use in the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random string of the specified length </dd></dl>

</div>
</div>
<a id="a4a358f323d4318fa3da5f0b03563a297" name="a4a358f323d4318fa3da5f0b03563a297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a358f323d4318fa3da5f0b03563a297">&#9670;&#160;</a></span>to_hex_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::to_hex_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view const &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7e688d7de6279dbf5202e942dd2791d7">range_hex_upper</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a binary string to a hexadecimal string. </p>
<p>Converts each byte in the input string to a two-character hexadecimal representation, using characters from the specified range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The binary string to convert </td></tr>
    <tr><td class="paramname">range</td><td>The range of characters to use for hexadecimal digits (default: uppercase) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hexadecimal string representation </dd></dl>

</div>
</div>
<a id="a3f956037ca222400e3cf27276ccce3d5" name="a3f956037ca222400e3cf27276ccce3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f956037ca222400e3cf27276ccce3d5">&#9670;&#160;</a></span>hex_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int qb::crypto::hex_value </td>
          <td>(</td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>hex_digit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the numeric value of a hexadecimal digit. </p>
<p>Converts a hexadecimal digit character to its numeric value (0-15).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hex_digit</td><td>The hexadecimal digit character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The numeric value of the digit, or -1 if the character is not a valid hex digit </dd></dl>

</div>
</div>
<a id="a6eaf13a9597cc9bb53a600a44f25a723" name="a6eaf13a9597cc9bb53a600a44f25a723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eaf13a9597cc9bb53a600a44f25a723">&#9670;&#160;</a></span>hex_to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::hex_to_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a hexadecimal string to a formatted string. </p>
<p>Converts a string of hexadecimal bytes to a formatted string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The hexadecimal string to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The formatted string </dd></dl>

</div>
</div>
<a id="a45c47d127b9af3a940407b1900ab5b0d" name="a45c47d127b9af3a940407b1900ab5b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c47d127b9af3a940407b1900ab5b0d">&#9670;&#160;</a></span>evp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::evp </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EVP_MD *</td>          <td class="paramname"><span class="paramname"><em>md</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a hash from an input stream using a specified digest algorithm. </p>
<p>Computes a cryptographic hash of the data in the input stream using the specified OpenSSL message digest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The input stream containing the data to hash </td></tr>
    <tr><td class="paramname">md</td><td>The OpenSSL message digest to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The calculated hash as a hexadecimal string </dd></dl>

</div>
</div>
<a id="a6bc244cd56f0ae91af0e26fff42336b7" name="a6bc244cd56f0ae91af0e26fff42336b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc244cd56f0ae91af0e26fff42336b7">&#9670;&#160;</a></span>md5() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::md5 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate an MD5 hash of a string. </p>
<p>Computes the MD5 hash of the input string, optionally applying the hash function multiple times for extra security.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The string to hash </td></tr>
    <tr><td class="paramname">iterations</td><td>Number of times to apply the hash function (default: 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MD5 hash as a hexadecimal string </dd></dl>

</div>
</div>
<a id="a9611fc14165417ee6ed5b9102371dbd2" name="a9611fc14165417ee6ed5b9102371dbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9611fc14165417ee6ed5b9102371dbd2">&#9670;&#160;</a></span>md5() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::md5 </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate an MD5 hash of data from an input stream. </p>
<p>Computes the MD5 hash of the data in the input stream, optionally applying the hash function multiple times for extra security.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The input stream containing the data to hash </td></tr>
    <tr><td class="paramname">iterations</td><td>Number of times to apply the hash function (default: 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MD5 hash as a hexadecimal string </dd></dl>

</div>
</div>
<a id="a25dee0e95588af5fac391cee41fa2d3c" name="a25dee0e95588af5fac391cee41fa2d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dee0e95588af5fac391cee41fa2d3c">&#9670;&#160;</a></span>sha1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::sha1 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a SHA-1 hash of a string. </p>
<p>Computes the SHA-1 hash of the input string, optionally applying the hash function multiple times for extra security.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The string to hash </td></tr>
    <tr><td class="paramname">iterations</td><td>Number of times to apply the hash function (default: 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The SHA-1 hash as a hexadecimal string </dd></dl>

</div>
</div>
<a id="ad5b33c52aa893ba165012cf54499cb83" name="ad5b33c52aa893ba165012cf54499cb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b33c52aa893ba165012cf54499cb83">&#9670;&#160;</a></span>sha1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::sha1 </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a SHA-1 hash of data from an input stream. </p>
<p>Computes the SHA-1 hash of the data in the input stream, optionally applying the hash function multiple times for extra security.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The input stream containing the data to hash </td></tr>
    <tr><td class="paramname">iterations</td><td>Number of times to apply the hash function (default: 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The SHA-1 hash as a hexadecimal string </dd></dl>

</div>
</div>
<a id="ae82036ab1a0852392da4425506375b6e" name="ae82036ab1a0852392da4425506375b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82036ab1a0852392da4425506375b6e">&#9670;&#160;</a></span>sha256() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::sha256 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a SHA-256 hash of a string. </p>
<p>Computes the SHA-256 hash of the input string, optionally applying the hash function multiple times for extra security.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The string to hash </td></tr>
    <tr><td class="paramname">iterations</td><td>Number of times to apply the hash function (default: 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The SHA-256 hash as a hexadecimal string </dd></dl>

</div>
</div>
<a id="a5a3ad2fc11ba527a8e688ec27de7bf7c" name="a5a3ad2fc11ba527a8e688ec27de7bf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3ad2fc11ba527a8e688ec27de7bf7c">&#9670;&#160;</a></span>sha256() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::sha256 </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a SHA-256 hash of data from an input stream. </p>
<p>Computes the SHA-256 hash of the data in the input stream, optionally applying the hash function multiple times for extra security.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The input stream containing the data to hash </td></tr>
    <tr><td class="paramname">iterations</td><td>Number of times to apply the hash function (default: 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The SHA-256 hash as a hexadecimal string </dd></dl>

</div>
</div>
<a id="add88ab35aa40c679ca19daa0105baa64" name="add88ab35aa40c679ca19daa0105baa64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add88ab35aa40c679ca19daa0105baa64">&#9670;&#160;</a></span>sha512() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::sha512 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a SHA-512 hash of a string. </p>
<p>Computes the SHA-512 hash of the input string, optionally applying the hash function multiple times for extra security.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The string to hash </td></tr>
    <tr><td class="paramname">iterations</td><td>Number of times to apply the hash function (default: 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The SHA-512 hash as a hexadecimal string </dd></dl>

</div>
</div>
<a id="a5c603766c90ce0ef14db1cd0146e53ab" name="a5c603766c90ce0ef14db1cd0146e53ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c603766c90ce0ef14db1cd0146e53ab">&#9670;&#160;</a></span>sha512() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::sha512 </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a SHA-512 hash of data from an input stream. </p>
<p>Computes the SHA-512 hash of the data in the input stream, optionally applying the hash function multiple times for extra security.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The input stream containing the data to hash </td></tr>
    <tr><td class="paramname">iterations</td><td>Number of times to apply the hash function (default: 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The SHA-512 hash as a hexadecimal string </dd></dl>

</div>
</div>
<a id="a494748b097bce83f3d2202d65f39a580" name="a494748b097bce83f3d2202d65f39a580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494748b097bce83f3d2202d65f39a580">&#9670;&#160;</a></span>pbkdf2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::pbkdf2 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>password</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>salt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iterations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>key_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derive a key using PBKDF2. </p>
<p>Uses the PBKDF2 (Password-Based Key Derivation Function 2) algorithm to derive a key from a password and salt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>The password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>The salt to use in the derivation process </td></tr>
    <tr><td class="paramname">iterations</td><td>Number of iterations to use in the derivation </td></tr>
    <tr><td class="paramname">key_size</td><td>Size of the derived key in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derived key as a string </dd></dl>

</div>
</div>
<a id="aaaf36d810a1ed90fcadb4558047b779d" name="aaaf36d810a1ed90fcadb4558047b779d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf36d810a1ed90fcadb4558047b779d">&#9670;&#160;</a></span>base64_encode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::base64_encode </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode binary data to Base64. </p>
<p>Converts binary data to a Base64-encoded string. This method does not include newline characters in the output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the binary data to encode </td></tr>
    <tr><td class="paramname">len</td><td>Length of the binary data in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Base64-encoded string </dd></dl>

</div>
</div>
<a id="ab01379bb4580a342eddfebd9a47c9a31" name="ab01379bb4580a342eddfebd9a47c9a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01379bb4580a342eddfebd9a47c9a31">&#9670;&#160;</a></span>base64_decode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::base64_decode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode a Base64 string to binary data. </p>
<p>Converts a Base64-encoded string back to its original binary form.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The Base64-encoded string to decode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decoded binary data as a vector of unsigned chars </dd></dl>

</div>
</div>
<a id="aeebe506bfbd4a4944f19401de98783a2" name="aeebe506bfbd4a4944f19401de98783a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebe506bfbd4a4944f19401de98783a2">&#9670;&#160;</a></span>hmac_sha256()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::hmac_sha256 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate an HMAC-SHA256 hash. </p>
<p>Computes an HMAC-SHA256 hash of the input data using the provided key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to use for the HMAC computation </td></tr>
    <tr><td class="paramname">data</td><td>The data to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The HMAC-SHA256 hash as a vector of unsigned chars </dd></dl>

</div>
</div>
<a id="a3fa7e57b305f9f97ccf61b88564ed893" name="a3fa7e57b305f9f97ccf61b88564ed893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa7e57b305f9f97ccf61b88564ed893">&#9670;&#160;</a></span>sha256() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::sha256 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a SHA-256 hash of binary data. </p>
<p>Computes the SHA-256 hash of the input binary data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The binary data to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The SHA-256 hash as a vector of unsigned chars </dd></dl>

</div>
</div>
<a id="aae8460e29e8eb769189949ac8c0a42ce" name="aae8460e29e8eb769189949ac8c0a42ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8460e29e8eb769189949ac8c0a42ce">&#9670;&#160;</a></span>xor_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::xor_bytes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>XOR two byte arrays. </p>
<p>Performs a bitwise XOR operation between corresponding bytes of two arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first byte array </td></tr>
    <tr><td class="paramname">b</td><td>The second byte array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of XORing the two arrays </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the arrays have different sizes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2325c465d5d1dc0e4ac987a67997327c" name="a2325c465d5d1dc0e4ac987a67997327c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2325c465d5d1dc0e4ac987a67997327c">&#9670;&#160;</a></span>generate_random_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::generate_random_bytes </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate cryptographically secure random bytes. </p>
<p>Uses OpenSSL's RAND_bytes to generate secure random bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Number of random bytes to generate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the random bytes </dd></dl>

</div>
</div>
<a id="a03250715314f502010304ede67ee9f79" name="a03250715314f502010304ede67ee9f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03250715314f502010304ede67ee9f79">&#9670;&#160;</a></span>generate_iv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::generate_iv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a3dc6cc6aba197cc631c114a5fbee0035">SymmetricAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algorithm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random initialization vector (IV) </p>
<p>Creates an IV of appropriate size for the specified algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algorithm</td><td>The symmetric algorithm for which to generate the IV </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the random IV </dd></dl>

</div>
</div>
<a id="a74eab972433b79c9b1b83eac8d168cb4" name="a74eab972433b79c9b1b83eac8d168cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74eab972433b79c9b1b83eac8d168cb4">&#9670;&#160;</a></span>generate_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::generate_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a3dc6cc6aba197cc631c114a5fbee0035">SymmetricAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algorithm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random key. </p>
<p>Creates a key of appropriate size for the specified algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algorithm</td><td>The symmetric algorithm for which to generate the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the random key </dd></dl>

</div>
</div>
<a id="a775bdd4a85eaf210e23a3f35b841b252" name="a775bdd4a85eaf210e23a3f35b841b252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775bdd4a85eaf210e23a3f35b841b252">&#9670;&#160;</a></span>encrypt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::encrypt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>plaintext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>iv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3dc6cc6aba197cc631c114a5fbee0035">SymmetricAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algorithm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>aad</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encrypt data using a symmetric algorithm. </p>
<p>Encrypts the provided data using the specified algorithm, key, and IV. For GCM mode, also computes and appends an authentication tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>The data to encrypt </td></tr>
    <tr><td class="paramname">key</td><td>The encryption key </td></tr>
    <tr><td class="paramname">iv</td><td>The initialization vector </td></tr>
    <tr><td class="paramname">algorithm</td><td>The encryption algorithm to use </td></tr>
    <tr><td class="paramname">aad</td><td>Additional authenticated data (for AEAD modes like GCM) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the encrypted data </dd></dl>

</div>
</div>
<a id="a19cfa489c501d7f68be4ba724c0fc5a3" name="a19cfa489c501d7f68be4ba724c0fc5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19cfa489c501d7f68be4ba724c0fc5a3">&#9670;&#160;</a></span>decrypt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::decrypt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ciphertext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>iv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3dc6cc6aba197cc631c114a5fbee0035">SymmetricAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algorithm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>aad</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrypt data using a symmetric algorithm. </p>
<p>Decrypts the provided data using the specified algorithm, key, and IV. For GCM mode, also verifies the authentication tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>The data to decrypt </td></tr>
    <tr><td class="paramname">key</td><td>The decryption key </td></tr>
    <tr><td class="paramname">iv</td><td>The initialization vector </td></tr>
    <tr><td class="paramname">algorithm</td><td>The encryption algorithm that was used </td></tr>
    <tr><td class="paramname">aad</td><td>Additional authenticated data (for AEAD modes like GCM) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the decrypted data or empty if authentication fails </dd></dl>

</div>
</div>
<a id="a7112f44fc7bb183ee03a805bfaf2ae46" name="a7112f44fc7bb183ee03a805bfaf2ae46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7112f44fc7bb183ee03a805bfaf2ae46">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::hash </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algorithm</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a generic hash using the specified algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to hash </td></tr>
    <tr><td class="paramname">algorithm</td><td>The hash algorithm to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the hash </dd></dl>

</div>
</div>
<a id="a93bc2b6cddb536aa808a9e11ec42dd79" name="a93bc2b6cddb536aa808a9e11ec42dd79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93bc2b6cddb536aa808a9e11ec42dd79">&#9670;&#160;</a></span>hmac()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::hmac </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algorithm</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute an HMAC using the specified algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to authenticate </td></tr>
    <tr><td class="paramname">key</td><td>The authentication key </td></tr>
    <tr><td class="paramname">algorithm</td><td>The hash algorithm to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the HMAC </dd></dl>

</div>
</div>
<a id="afd898a5aa629545adea2d4d7084b3246" name="afd898a5aa629545adea2d4d7084b3246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd898a5aa629545adea2d4d7084b3246">&#9670;&#160;</a></span>generate_rsa_keypair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, std::string &gt; qb::crypto::generate_rsa_keypair </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2048</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate an RSA key pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>The key size in bits (e.g., 2048, 3072, 4096) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of strings containing PEM-encoded private and public keys </dd></dl>

</div>
</div>
<a id="a9f41fb828e9a702b5240a871f78f91f2" name="a9f41fb828e9a702b5240a871f78f91f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f41fb828e9a702b5240a871f78f91f2">&#9670;&#160;</a></span>generate_ec_keypair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, std::string &gt; qb::crypto::generate_ec_keypair </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>curve</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;prime256v1&quot;</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate an EC key pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve</td><td>The curve name (e.g., "prime256v1", "secp384r1", "secp521r1") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of strings containing PEM-encoded private and public keys </dd></dl>

</div>
</div>
<a id="a7e01b5668c4b51ab494c57890314c7d7" name="a7e01b5668c4b51ab494c57890314c7d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e01b5668c4b51ab494c57890314c7d7">&#9670;&#160;</a></span>rsa_sign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::rsa_sign </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>private_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>digest</em></span><span class="paramdefsep"> = </span><span class="paramdefval">DigestAlgorithm::SHA256</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign data using an RSA private key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to sign </td></tr>
    <tr><td class="paramname">private_key</td><td>PEM-encoded private key </td></tr>
    <tr><td class="paramname">digest</td><td>The digest algorithm to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the signature </dd></dl>

</div>
</div>
<a id="a87f50ea6b212e1af62efe13031491bbd" name="a87f50ea6b212e1af62efe13031491bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f50ea6b212e1af62efe13031491bbd">&#9670;&#160;</a></span>rsa_verify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qb::crypto::rsa_verify </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>signature</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>public_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>digest</em></span><span class="paramdefsep"> = </span><span class="paramdefval">DigestAlgorithm::SHA256</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify an RSA signature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data that was signed </td></tr>
    <tr><td class="paramname">signature</td><td>The signature to verify </td></tr>
    <tr><td class="paramname">public_key</td><td>PEM-encoded public key </td></tr>
    <tr><td class="paramname">digest</td><td>The digest algorithm that was used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the signature is valid </dd></dl>

</div>
</div>
<a id="a9df504e09b43b66699a3e48718550e57" name="a9df504e09b43b66699a3e48718550e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df504e09b43b66699a3e48718550e57">&#9670;&#160;</a></span>ec_sign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::ec_sign </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>private_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>digest</em></span><span class="paramdefsep"> = </span><span class="paramdefval">DigestAlgorithm::SHA256</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign data using an EC private key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to sign </td></tr>
    <tr><td class="paramname">private_key</td><td>PEM-encoded private key </td></tr>
    <tr><td class="paramname">digest</td><td>The digest algorithm to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the signature </dd></dl>

</div>
</div>
<a id="a43a36ed173db106fcd4103d9fc3678f5" name="a43a36ed173db106fcd4103d9fc3678f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a36ed173db106fcd4103d9fc3678f5">&#9670;&#160;</a></span>ec_verify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qb::crypto::ec_verify </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>signature</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>public_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>digest</em></span><span class="paramdefsep"> = </span><span class="paramdefval">DigestAlgorithm::SHA256</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify an EC signature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data that was signed </td></tr>
    <tr><td class="paramname">signature</td><td>The signature to verify </td></tr>
    <tr><td class="paramname">public_key</td><td>PEM-encoded public key </td></tr>
    <tr><td class="paramname">digest</td><td>The digest algorithm that was used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the signature is valid </dd></dl>

</div>
</div>
<a id="a82c82e5cb0be1e4db2f8616917c0d016" name="a82c82e5cb0be1e4db2f8616917c0d016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c82e5cb0be1e4db2f8616917c0d016">&#9670;&#160;</a></span>ecdh_derive_secret()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::ecdh_derive_secret </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>private_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>peer_public_key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derive a shared secret using ECDH. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">private_key</td><td>PEM-encoded EC private key </td></tr>
    <tr><td class="paramname">peer_public_key</td><td>PEM-encoded EC public key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the shared secret </dd></dl>

</div>
</div>
<a id="a5387b3da9c628d4556591409596ddee5" name="a5387b3da9c628d4556591409596ddee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5387b3da9c628d4556591409596ddee5">&#9670;&#160;</a></span>secure_random_fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qb::crypto::secure_random_fill </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a vector with secure random bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector to fill </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd></dl>

</div>
</div>
<a id="a60e279c13288a2cb44f4fae17835d18d" name="a60e279c13288a2cb44f4fae17835d18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e279c13288a2cb44f4fae17835d18d">&#9670;&#160;</a></span>get_evp_md()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EVP_MD * qb::crypto::get_evp_md </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algorithm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a digest algorithm enum to its corresponding EVP_MD. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algorithm</td><td>The digest algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the EVP_MD structure </dd></dl>

</div>
</div>
<a id="a795239ffdd3cf43d187ef478f5337f44" name="a795239ffdd3cf43d187ef478f5337f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795239ffdd3cf43d187ef478f5337f44">&#9670;&#160;</a></span>argon2_kdf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::argon2_kdf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>password</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>key_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structqb_1_1crypto_1_1_argon2_params.html">Argon2Params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1b38f47f57580c2be964057f3b92c853">Argon2Variant</a></td>          <td class="paramname"><span class="paramname"><em>variant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Argon2Variant::Argon2id</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key derivation based on Argon2. </p>
<p>Implements the Argon2 algorithm (2id by default) to derive a secure key from a password. Argon2 is designed to be resistant to dedicated hardware attacks by using a large amount of memory and parallel operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>Input password </td></tr>
    <tr><td class="paramname">key_length</td><td>Length of the key to generate (in bytes) </td></tr>
    <tr><td class="paramname">params</td><td>Parameters for the Argon2 algorithm </td></tr>
    <tr><td class="paramname">variant</td><td>Argon2 variant to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derived key </dd></dl>

</div>
</div>
<a id="a3b1b324752d0880147e099095a336dcf" name="a3b1b324752d0880147e099095a336dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1b324752d0880147e099095a336dcf">&#9670;&#160;</a></span>hkdf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::hkdf </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input_key_material</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>salt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>output_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>digest</em></span><span class="paramdefsep"> = </span><span class="paramdefval">DigestAlgorithm::SHA256</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key derivation with HKDF (HMAC-based Key Derivation Function) </p>
<p>Implements HKDF according to RFC 5869 to derive one or more keys from input key material. HKDF is particularly useful for extracting entropy from a non-uniform source and extending it to the desired size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_key_material</td><td>Input key material </td></tr>
    <tr><td class="paramname">salt</td><td>Optional salt for the extraction step </td></tr>
    <tr><td class="paramname">info</td><td>Contextual information for the expansion step </td></tr>
    <tr><td class="paramname">output_length</td><td>Length of the key to generate </td></tr>
    <tr><td class="paramname">digest</td><td>Hash algorithm to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derived key </dd></dl>

</div>
</div>
<a id="ab21ccbc086ea5f5be541992d1272e026" name="ab21ccbc086ea5f5be541992d1272e026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21ccbc086ea5f5be541992d1272e026">&#9670;&#160;</a></span>derive_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::derive_key </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>password</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>salt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>key_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab2218dcc7621b7edc22474a9d32df57f">KdfAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algorithm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">KdfAlgorithm::Argon2</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structqb_1_1crypto_1_1_argon2_params.html">Argon2Params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>argon2_params</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structqb_1_1crypto_1_1_argon2_params.html">Argon2Params</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>High-level function to derive a key from a password. </p>
<p>Provides a unified interface for different key derivation algorithms. Recommendations:</p><ul>
<li>For passwords: Argon2</li>
<li>For deriving additional keys from an existing key: HKDF</li>
<li>For compatibility with existing systems: PBKDF2</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>Password or input key </td></tr>
    <tr><td class="paramname">salt</td><td>Salt for derivation </td></tr>
    <tr><td class="paramname">key_length</td><td>Length of the key to generate </td></tr>
    <tr><td class="paramname">algorithm</td><td>Derivation algorithm to use </td></tr>
    <tr><td class="paramname">iterations</td><td>Number of iterations (for PBKDF2) </td></tr>
    <tr><td class="paramname">argon2_params</td><td>Parameters for Argon2 (ignored if another algorithm is used) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derived key </dd></dl>

</div>
</div>
<a id="a51f2dc509048b556eefb4be1c82ef3f2" name="a51f2dc509048b556eefb4be1c82ef3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f2dc509048b556eefb4be1c82ef3f2">&#9670;&#160;</a></span>ecies_encrypt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::ecies_encrypt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>plaintext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>recipient_public_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acdd92c899174254b76054486f506b8a5">ECIESMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ECIESMode::AES_GCM</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>digest</em></span><span class="paramdefsep"> = </span><span class="paramdefval">DigestAlgorithm::SHA256</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrated Elliptic Curve Encryption (ECIES) </p>
<p>Implements ECIES (Elliptic Curve Integrated Encryption Scheme), which combines public key cryptography using elliptic curves and symmetric encryption to provide a secure hybrid system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Data to encrypt </td></tr>
    <tr><td class="paramname">recipient_public_key</td><td>Recipient's public key (PEM) </td></tr>
    <tr><td class="paramname">mode</td><td>ECIES operation mode </td></tr>
    <tr><td class="paramname">digest</td><td>Hash algorithm to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Encrypted data </dd></dl>

</div>
</div>
<a id="ae503a31081ec06eb01720c3aea2d7375" name="ae503a31081ec06eb01720c3aea2d7375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae503a31081ec06eb01720c3aea2d7375">&#9670;&#160;</a></span>ecies_decrypt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::ecies_decrypt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ciphertext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>private_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acdd92c899174254b76054486f506b8a5">ECIESMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ECIESMode::AES_GCM</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa9baac0850aa32d59d2107994f250020">DigestAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>digest</em></span><span class="paramdefsep"> = </span><span class="paramdefval">DigestAlgorithm::SHA256</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ECIES decryption. </p>
<p>Decrypts data encrypted with ECIES.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>Encrypted data </td></tr>
    <tr><td class="paramname">private_key</td><td>Recipient's private key (PEM) </td></tr>
    <tr><td class="paramname">mode</td><td>ECIES operation mode used for encryption </td></tr>
    <tr><td class="paramname">digest</td><td>Hash algorithm used for encryption </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Decrypted data or empty vector on failure </dd></dl>

</div>
</div>
<a id="a307732d9f9c3e595a23d09a23ead8f92" name="a307732d9f9c3e595a23d09a23ead8f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307732d9f9c3e595a23d09a23ead8f92">&#9670;&#160;</a></span>envelope_encrypt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::envelope_encrypt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>plaintext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>recipient_public_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3dc6cc6aba197cc631c114a5fbee0035">SymmetricAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algorithm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SymmetricAlgorithm::AES_256_GCM</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a93b1d3e401a5a50114601f7de079c036">EnvelopeFormat</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EnvelopeFormat::BASE64</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Envelope encryption. </p>
<p>Implements envelope encryption: a symmetric key is generated, used to encrypt the data, and then itself encrypted with a public key. This method is more efficient than ECIES for large volumes of data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Data to encrypt </td></tr>
    <tr><td class="paramname">recipient_public_key</td><td>Recipient's public key (PEM) </td></tr>
    <tr><td class="paramname">algorithm</td><td>Symmetric algorithm to use </td></tr>
    <tr><td class="paramname">format</td><td>Output format for encrypted data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Encrypted data in the specified format </dd></dl>

</div>
</div>
<a id="adfb2bcae81cb8b6fcf97656b20912ecc" name="adfb2bcae81cb8b6fcf97656b20912ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb2bcae81cb8b6fcf97656b20912ecc">&#9670;&#160;</a></span>envelope_decrypt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::envelope_decrypt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>ciphertext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>private_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a93b1d3e401a5a50114601f7de079c036">EnvelopeFormat</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EnvelopeFormat::BASE64</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Envelope decryption. </p>
<p>Decrypts data encrypted with envelope encryption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>Encrypted data </td></tr>
    <tr><td class="paramname">private_key</td><td>Recipient's private key (PEM) </td></tr>
    <tr><td class="paramname">format</td><td>Format of the encrypted data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Decrypted data or empty vector on failure </dd></dl>

</div>
</div>
<a id="a44bb10510ee107af17bf9f49de761f77" name="a44bb10510ee107af17bf9f49de761f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44bb10510ee107af17bf9f49de761f77">&#9670;&#160;</a></span>constant_time_compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qb::crypto::constant_time_compare </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Secure string comparison (resistant to timing attacks) </p>
<p>Compares two byte strings in constant time to avoid information leaks through execution time analysis attacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First string </td></tr>
    <tr><td class="paramname">b</td><td>Second string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the strings are identical, false otherwise </dd></dl>

</div>
</div>
<a id="ac99d50240560933847e0c683648aba2e" name="ac99d50240560933847e0c683648aba2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99d50240560933847e0c683648aba2e">&#9670;&#160;</a></span>generate_token()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::generate_token </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>payload</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>ttl</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a secure token with optional TTL. </p>
<p>Creates a token containing the specified payload, encrypted and authenticated. The token can optionally include an expiration time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>The payload to include in the token </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for encryption </td></tr>
    <tr><td class="paramname">ttl</td><td>Time to live in seconds (0 = no expiration) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated token </dd></dl>

</div>
</div>
<a id="ad55bb9b9924f57e06e3dddc41a2ab6ed" name="ad55bb9b9924f57e06e3dddc41a2ab6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55bb9b9924f57e06e3dddc41a2ab6ed">&#9670;&#160;</a></span>verify_token()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::verify_token </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify and decrypt a token. </p>
<p>Verifies the token's authenticity and expiration time, and returns the payload. Returns an empty string if the token is invalid or expired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The token to verify </td></tr>
    <tr><td class="paramname">key</td><td>The key used for encryption </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The payload or empty string if invalid/expired </dd></dl>

</div>
</div>
<a id="aded5c61abba9d7c4573cba6a0bc3da22" name="aded5c61abba9d7c4573cba6a0bc3da22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded5c61abba9d7c4573cba6a0bc3da22">&#9670;&#160;</a></span>base64url_encode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::base64url_encode </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Base64URL encode. </p>
<p>Encodes data using Base64URL (a variant of Base64 that is safe for use in URLs and filenames).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to encode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Base64URL encoded string </dd></dl>

</div>
</div>
<a id="a8777cdd79e7b914b6badb0ea89b76ef6" name="a8777cdd79e7b914b6badb0ea89b76ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8777cdd79e7b914b6badb0ea89b76ef6">&#9670;&#160;</a></span>base64url_decode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::base64url_decode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Base64URL decode. </p>
<p>Decodes data from Base64URL format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The Base64URL encoded string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Decoded data </dd></dl>

</div>
</div>
<a id="ad4f04d86ebb6b492aa5323aa80995b64" name="ad4f04d86ebb6b492aa5323aa80995b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f04d86ebb6b492aa5323aa80995b64">&#9670;&#160;</a></span>generate_salt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::generate_salt </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a secure random salt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Length of the salt in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated salt </dd></dl>

</div>
</div>
<a id="af80097376980c66177d219b2f9d36cc0" name="af80097376980c66177d219b2f9d36cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80097376980c66177d219b2f9d36cc0">&#9670;&#160;</a></span>hash_password()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::hash_password </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>password</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1b38f47f57580c2be964057f3b92c853">Argon2Variant</a></td>          <td class="paramname"><span class="paramname"><em>variant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Argon2Variant::Argon2id</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash a password securely using Argon2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>The password to hash </td></tr>
    <tr><td class="paramname">variant</td><td>Argon2 variant to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing the formatted hash with parameters </dd></dl>

</div>
</div>
<a id="a512ab1a68621bfb9a0095a78ace498f9" name="a512ab1a68621bfb9a0095a78ace498f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512ab1a68621bfb9a0095a78ace498f9">&#9670;&#160;</a></span>verify_password()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qb::crypto::verify_password </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>password</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify a password against a stored hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>The password to verify </td></tr>
    <tr><td class="paramname">hash</td><td>The stored hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the password matches the hash </dd></dl>

</div>
</div>
<a id="ac38997b22f1f94edfa01bb3a3c575d71" name="ac38997b22f1f94edfa01bb3a3c575d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38997b22f1f94edfa01bb3a3c575d71">&#9670;&#160;</a></span>generate_ed25519_keypair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, std::string &gt; qb::crypto::generate_ed25519_keypair </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Ed25519 signing key pair. </p>
<p>Generates an Ed25519 signing key pair, designed for speed and security.</p>
<dl class="section return"><dt>Returns</dt><dd>Pair of PEM-encoded strings (private key, public key). </dd></dl>

</div>
</div>
<a id="afd1b5e94f47544b1665c641dd7aaf8b8" name="afd1b5e94f47544b1665c641dd7aaf8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1b5e94f47544b1665c641dd7aaf8b8">&#9670;&#160;</a></span>generate_ed25519_keypair_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; unsigned char &gt;, std::vector&lt; unsigned char &gt; &gt; qb::crypto::generate_ed25519_keypair_bytes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Ed25519 keypair returning raw byte vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Paire de clés au format PEM (privée, publique) </dd></dl>

</div>
</div>
<a id="a6c6e60669c546c6855892c1cb7db6c1a" name="a6c6e60669c546c6855892c1cb7db6c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6e60669c546c6855892c1cb7db6c1a">&#9670;&#160;</a></span>ed25519_sign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::ed25519_sign </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>private_key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign data using Ed25519 private key. </p>
<p>Signs data with the Ed25519 algorithm using a PEM-encoded private key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Data to sign. </td></tr>
    <tr><td class="paramname">private_key</td><td>Ed25519 private key in PEM format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signature bytes. </dd></dl>

</div>
</div>
<a id="a0c2d70b97afbbc75d6b0dc9d40dcfc28" name="a0c2d70b97afbbc75d6b0dc9d40dcfc28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2d70b97afbbc75d6b0dc9d40dcfc28">&#9670;&#160;</a></span>ed25519_sign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::ed25519_sign </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>private_key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign data using Ed25519 with raw private key bytes. </p>
<p>Signe des données avec l'algorithme Ed25519.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Données à signer </td></tr>
    <tr><td class="paramname">private_key</td><td>Clé privée Ed25519 au format PEM </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signature </dd></dl>

</div>
</div>
<a id="a27913072a9529503e4db135dc3a5e7a0" name="a27913072a9529503e4db135dc3a5e7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27913072a9529503e4db135dc3a5e7a0">&#9670;&#160;</a></span>ed25519_verify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qb::crypto::ed25519_verify </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>signature</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>public_key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify Ed25519 signature. </p>
<p>Verifies an Ed25519 signature using a PEM-encoded public key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Data that was signed. </td></tr>
    <tr><td class="paramname">signature</td><td>Signature to verify. </td></tr>
    <tr><td class="paramname">public_key</td><td>Ed25519 public key in PEM format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the signature is valid. </dd></dl>

</div>
</div>
<a id="a2aecd385862132e77cb62405d0a8661f" name="a2aecd385862132e77cb62405d0a8661f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aecd385862132e77cb62405d0a8661f">&#9670;&#160;</a></span>ed25519_verify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qb::crypto::ed25519_verify </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>signature</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>public_key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify Ed25519 signature with raw public key bytes. </p>
<p>Vérifie une signature Ed25519.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Données qui ont été signées </td></tr>
    <tr><td class="paramname">signature</td><td>Signature à vérifier </td></tr>
    <tr><td class="paramname">public_key</td><td>Clé publique Ed25519 au format PEM </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vrai si la signature est valide </dd></dl>

</div>
</div>
<a id="a8690b21124619c6f25cb6f906d6f0260" name="a8690b21124619c6f25cb6f906d6f0260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8690b21124619c6f25cb6f906d6f0260">&#9670;&#160;</a></span>generate_x25519_keypair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, std::string &gt; qb::crypto::generate_x25519_keypair </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate X25519 key pair for key exchange. </p>
<p>Generates an X25519 key pair for Elliptic Curve Diffie-Hellman (ECDH) key exchange.</p>
<dl class="section return"><dt>Returns</dt><dd>Pair of PEM-encoded strings (private key, public key). </dd></dl>

</div>
</div>
<a id="a846ffa65ee494d89f43e3e741d1d075a" name="a846ffa65ee494d89f43e3e741d1d075a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846ffa65ee494d89f43e3e741d1d075a">&#9670;&#160;</a></span>generate_x25519_keypair_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; unsigned char &gt;, std::vector&lt; unsigned char &gt; &gt; qb::crypto::generate_x25519_keypair_bytes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate X25519 keypair returning raw byte vectors. </p>
<p>Génère une paire de clés X25519 pour l'échange de clés Diffie-Hellman sur courbe elliptique.</p>
<dl class="section return"><dt>Returns</dt><dd>Paire de clés au format PEM (privée, publique) </dd></dl>

</div>
</div>
<a id="ae432633065943fd87054cc837cd21bd5" name="ae432633065943fd87054cc837cd21bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae432633065943fd87054cc837cd21bd5">&#9670;&#160;</a></span>x25519_key_exchange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::x25519_key_exchange </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>private_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>peer_public_key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>X25519 key exchange. </p>
<p>Derives a shared secret using the X25519 algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">private_key</td><td>X25519 private key in vector format </td></tr>
    <tr><td class="paramname">peer_public_key</td><td>Peer's public key in vector format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared secret </dd></dl>

</div>
</div>
<a id="ada4bfcbca9dde18e77becfb9db52c4b1" name="ada4bfcbca9dde18e77becfb9db52c4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4bfcbca9dde18e77becfb9db52c4b1">&#9670;&#160;</a></span>x25519_key_exchange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::x25519_key_exchange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>private_key_pem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>peer_public_key_pem</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>X25519 key exchange with PEM keys. </p>
<p>Derives a shared secret using the X25519 algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">private_key_pem</td><td>X25519 private key in PEM format </td></tr>
    <tr><td class="paramname">peer_public_key_pem</td><td>Peer's public key in PEM format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared secret </dd></dl>

</div>
</div>
<a id="a6e4e3e68ef59d816f3561d352a4d165e" name="a6e4e3e68ef59d816f3561d352a4d165e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4e3e68ef59d816f3561d352a4d165e">&#9670;&#160;</a></span>generate_unique_iv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; qb::crypto::generate_unique_iv </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">12</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random initialization vector for one-time use. </p>
<p>Generates a random initialization vector guaranteed to be unique, by including a counter and timestamp to avoid duplicates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the initialization vector in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One-time use IV </dd></dl>

</div>
</div>
<a id="ae8ac628a653294b207dfa68935724e62" name="ae8ac628a653294b207dfa68935724e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ac628a653294b207dfa68935724e62">&#9670;&#160;</a></span>encrypt_with_metadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qb::crypto::encrypt_with_metadata </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>plaintext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>metadata</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3dc6cc6aba197cc631c114a5fbee0035">SymmetricAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algorithm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SymmetricAlgorithm::AES_256_GCM</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Authenticated encryption of data with additional authentication. </p>
<p>Encrypts data with authentication, adding metadata protected by integrity (e.g., user ID, timestamp). The metadata is included in the AAD for authenticated encryption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Data to encrypt </td></tr>
    <tr><td class="paramname">key</td><td>Encryption key </td></tr>
    <tr><td class="paramname">metadata</td><td>Metadata to protect (not encrypted but authenticated) </td></tr>
    <tr><td class="paramname">algorithm</td><td>Algorithm to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Encrypted data (with IV, AAD and tag) in structured format </dd></dl>

</div>
</div>
<a id="a60827e5303b7c30fcd5ecf7ab7376110" name="a60827e5303b7c30fcd5ecf7ab7376110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60827e5303b7c30fcd5ecf7ab7376110">&#9670;&#160;</a></span>decrypt_with_metadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::pair&lt; std::vector&lt; unsigned char &gt;, std::string &gt; &gt; qb::crypto::decrypt_with_metadata </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>ciphertext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3dc6cc6aba197cc631c114a5fbee0035">SymmetricAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algorithm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SymmetricAlgorithm::AES_256_GCM</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decryption and verification of data and metadata integrity. </p>
<p>Decrypts data protected by encrypt_with_metadata and verifies the integrity of the metadata.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>Structured encrypted data </td></tr>
    <tr><td class="paramname">key</td><td>Decryption key </td></tr>
    <tr><td class="paramname">algorithm</td><td>Algorithm used for encryption </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Structure containing the decrypted data and verified metadata, or empty optional value if authentication fails </dd></dl>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a89143319637405f8e9edda59592145e4" name="a89143319637405f8e9edda59592145e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89143319637405f8e9edda59592145e4">&#9670;&#160;</a></span>range_alpha</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string_view qb::crypto::range_alpha</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></div>
<div class="line">                                                          <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span></div>
</div><!-- fragment -->
<p>Character range for alphabetic values (A-Z, a-z) </p>

</div>
</div>
<a id="a839abf14ac89cdf7a599815879d6be9e" name="a839abf14ac89cdf7a599815879d6be9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839abf14ac89cdf7a599815879d6be9e">&#9670;&#160;</a></span>range_alpha_lower</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string_view qb::crypto::range_alpha_lower</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span></div>
</div><!-- fragment -->
<p>Character range for lowercase alphabetic values (a-z) </p>

</div>
</div>
<a id="a52957aecdc9ebc35535424a08674e658" name="a52957aecdc9ebc35535424a08674e658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52957aecdc9ebc35535424a08674e658">&#9670;&#160;</a></span>range_alpha_upper</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string_view qb::crypto::range_alpha_upper</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></div>
</div><!-- fragment -->
<p>Character range for uppercase alphabetic values (A-Z) </p>

</div>
</div>
<a id="aab651f15bbabb3bae6181407d69b8b33" name="aab651f15bbabb3bae6181407d69b8b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab651f15bbabb3bae6181407d69b8b33">&#9670;&#160;</a></span>range_alpha_numeric</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string_view qb::crypto::range_alpha_numeric</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        <span class="stringliteral">&quot;0123456789&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span></div>
</div><!-- fragment -->
<p>Character range for alphanumeric values (0-9, A-Z, a-z) </p>

</div>
</div>
<a id="afb23e117fc8f8822bc18538191bc0cf3" name="afb23e117fc8f8822bc18538191bc0cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb23e117fc8f8822bc18538191bc0cf3">&#9670;&#160;</a></span>range_alpha_numeric_special</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string_view qb::crypto::range_alpha_numeric_special</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        <span class="stringliteral">&quot;0123456789&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot; !\&quot;#$%&amp;&#39;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span></div>
</div><!-- fragment -->
<p>Character range for alphanumeric values and special characters. </p>

</div>
</div>
<a id="a414ea90f8d442bbad3f19ef0fcecbab1" name="a414ea90f8d442bbad3f19ef0fcecbab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414ea90f8d442bbad3f19ef0fcecbab1">&#9670;&#160;</a></span>range_byte</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string_view qb::crypto::range_byte</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        <span class="stringliteral">&quot;\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2A\x2B\x2C\x2D\x2E\x2F&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3A\x3B\x3C\x3D\x3E\x3F&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4A\x4B\x4C\x4D\x4E\x4F&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5A\x5B\x5C\x5D\x5E\x5F&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6A\x6B\x6C\x6D\x6E\x6F&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7A\x7B\x7C\x7D\x7E\x7F&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF&quot;</span></div>
</div><!-- fragment -->
<p>Character range for binary bytes (0-255) </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>qb</b></li><li class="navelem"><a href="classqb_1_1crypto.html">crypto</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
