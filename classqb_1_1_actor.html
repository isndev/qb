<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <head>
        <meta http-equiv="cache-control" content="max-age=86400"/>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta http-equiv="X-UA-Compatible" content="IE=9"/>
        <meta name="generator" content="Doxygen 1.14.0"/>
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <title>qb: qb::Actor Class Reference</title>
        <meta name="description" content="qb OpenSource C++17 Actor Framework Documentation, all API detailed">
        <meta name="keywords"
              content="qb, cube, actor, framework, actor framework, opensource, cpp, c++, cpp17, c++17, documentation, docs, git">
        <meta name="author" content="isndev">
        <!-- BEGIN opengraph metadata -->
<!--        <meta property="og:title" content="Doxygen Awesome"/>-->
<!--        <meta property="og:image"-->
<!--              content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>-->
<!--        <meta property="og:description"-->
<!--              content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>-->
<!--        <meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/"/>-->
        <!-- END opengraph metadata -->
        <!-- BEGIN twitter metadata -->
<!--        <meta name="twitter:image:src"-->
<!--              content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>-->
<!--        <meta name="twitter:title" content="Doxygen Awesome"/>-->
<!--        <meta name="twitter:description"-->
<!--              content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>-->
        <!-- END twitter metadata -->
        <title>qb: qb::Actor Class Reference</title>
        <link href="tabs.css" rel="stylesheet" type="text/css"/>
        <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
        <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
        <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
        <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
        <script type="text/javascript" src="toggle-alternative-theme.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeFragmentCopyButton.init()
            DoxygenAwesomeDarkModeToggle.init()
            DoxygenAwesomeParagraphLink.init()
            DoxygenAwesomeInteractiveToc.init()
            DoxygenAwesomeTabs.init()
        </script>
        <script async defer src="https://buttons.github.io/buttons.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css"/>
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
    </head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/isndev/qb" class="github-corner" title="View source on GitHub"
   target="_blank" rel="noopener noreferrer">
    <svg viewBox="0 0 250 250" width="40" height="40"
         style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
<style>.github-corner:hover .octo-arm {
    animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
    0%, 100% {
        transform: rotate(0)
    }
    20%, 60% {
        transform: rotate(-25deg)
    }
    40%, 80% {
        transform: rotate(10deg)
    }
}
@media (max-width: 500px) {
    .github-corner:hover .octo-arm {
        animation: none
    }
    .github-corner .octo-arm {
        animation: octocat-wave 560ms ease-in-out
    }
}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
            <tr style="height: 56px;">
                <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
                <td id="projectalign" style="padding-left: 0.5em;">
                    <div id="projectname">qb
                        &#160;<span id="projectnumber">2.0.0.0</span>
                    </div>
                    <div id="projectbrief">C++17 Actor Framework</div>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
    <div style="padding-left: 0.5em;">
        <a class="navbar-brand" href="https://github.com/isndev/qb">
            <img src="GitHub-Mark-64px.png" width="32px" alt="qb">
        </a>
        <a class="github-button" href="https://github.com/isndev/qb/issues" data-icon="octicon-issue-opened" data-size="large" data-show-count="true" aria-label="Issue isndev/qb on GitHub">Issue</a>
        <a class="github-button" href="https://github.com/isndev/qb/subscription" data-icon="octicon-eye" data-size="large" data-show-count="true" aria-label="Watch isndev/qb on GitHub">Watch</a>
        <a class="github-button" href="https://github.com/isndev/qb" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star isndev/qb on GitHub">Star</a>
        <a class="github-button" href="https://github.com/isndev/qb/fork" data-icon="octicon-repo-forked" data-size="large" data-show-count="true" aria-label="Fork isndev/qb on GitHub">Fork</a>
        <a class="github-button" href="https://github.com/isndev" data-size="large" data-show-count="false" aria-label="Follow @isndev on GitHub">Follow @isndev</a>
    </div>
    <!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classqb_1_1_actor.html','','classqb_1_1_actor-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">qb::Actor Class Reference<div class="ingroups"><a class="el" href="group___q_b.html">QB Actor Framework</a> &raquo; <a class="el" href="group___core.html">Core Actor System</a> &raquo; <a class="el" href="group___actor.html">Actor Components</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Base class for all actors in the qb framework.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="core_2_actor_8h_source.html">Actor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for qb::Actor:</div>
<div class="dyncontent">
<div class="center"><img src="classqb_1_1_actor__inherit__graph.png" border="0" usemap="#aqb_1_1_actor_inherit__map" loading="lazy" alt="Inheritance graph"/></div>
<map name="aqb_1_1_actor_inherit__map" id="aqb_1_1_actor_inherit__map">
<area shape="rect" title="Base class for all actors in the qb framework." alt="" coords="50,79,124,105"/>
<area shape="rect" href="classqb_1_1_service.html" title="Internal base class for services." alt="" coords="43,153,131,178"/>
<area shape="poly" title=" " alt="" coords="90,120,90,152,84,152,84,120"/>
<area shape="rect" href="structqb_1_1nocopy.html" title="Base class to make derived classes non&#45;copyable." alt="" coords="44,5,130,31"/>
<area shape="poly" title=" " alt="" coords="90,46,90,79,84,79,84,46"/>
<area shape="rect" href="classqb_1_1_service_actor.html" title="SingletonActor base class, ensuring one instance per VirtualCore per Tag." alt="" coords="5,226,169,252"/>
<area shape="poly" title=" " alt="" coords="90,194,90,226,84,226,84,194"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for qb::Actor:</div>
<div class="dyncontent">
<div class="center"><img src="classqb_1_1_actor__coll__graph.png" border="0" usemap="#aqb_1_1_actor_coll__map" loading="lazy" alt="Collaboration graph"/></div>
<map name="aqb_1_1_actor_coll__map" id="aqb_1_1_actor_coll__map">
<area shape="rect" title="Base class for all actors in the qb framework." alt="" coords="11,79,85,105"/>
<area shape="rect" href="structqb_1_1nocopy.html" title="Base class to make derived classes non&#45;copyable." alt="" coords="5,5,91,31"/>
<area shape="poly" title=" " alt="" coords="51,46,51,79,45,79,45,46"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:EventBuilder" id="r_EventBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqb_1_1_actor_1_1_event_builder.html">EventBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for building and sending events to actors.  <a href="classqb_1_1_actor_1_1_event_builder.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Built-in Event Handlers</div></td></tr>
<tr class="memitem:a245a2b7be6e086bf622d2acb78b9bded" id="r_a245a2b7be6e086bf622d2acb78b9bded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a245a2b7be6e086bf622d2acb78b9bded">on</a> (<a class="el" href="structqb_1_1_kill_event.html">KillEvent</a> const &amp;<a class="el" href="group___event_core.html#ga3296038c4343f22626c6595a222c0d95">event</a>) noexcept</td></tr>
<tr class="memdesc:a245a2b7be6e086bf622d2acb78b9bded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for <a class="el" href="structqb_1_1_kill_event.html" title="Event used to terminate an actor.">KillEvent</a>.  <br /></td></tr>
<tr class="memitem:ae75c0d54caa6c2b9073527d2ac909dab" id="r_ae75c0d54caa6c2b9073527d2ac909dab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae75c0d54caa6c2b9073527d2ac909dab">on</a> (<a class="el" href="structqb_1_1_signal_event.html">SignalEvent</a> const &amp;<a class="el" href="group___event_core.html#ga3296038c4343f22626c6595a222c0d95">event</a>) noexcept</td></tr>
<tr class="memdesc:ae75c0d54caa6c2b9073527d2ac909dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for <a class="el" href="structqb_1_1_signal_event.html" title="Event used to handle system signals.">SignalEvent</a>.  <br /></td></tr>
<tr class="memitem:af14f0d20ea7e4383c9e741f92974a3a8" id="r_af14f0d20ea7e4383c9e741f92974a3a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af14f0d20ea7e4383c9e741f92974a3a8">on</a> (<a class="el" href="structqb_1_1_unregister_callback_event.html">UnregisterCallbackEvent</a> const &amp;<a class="el" href="group___event_core.html#ga3296038c4343f22626c6595a222c0d95">event</a>) noexcept</td></tr>
<tr class="memdesc:af14f0d20ea7e4383c9e741f92974a3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for <a class="el" href="structqb_1_1_unregister_callback_event.html" title="Event used to unregister an actor&#39;s callback.">UnregisterCallbackEvent</a>.  <br /></td></tr>
<tr class="memitem:a55fb391dd4bd122b1479041ea48bf3f5" id="r_a55fb391dd4bd122b1479041ea48bf3f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55fb391dd4bd122b1479041ea48bf3f5">on</a> (<a class="el" href="structqb_1_1_ping_event.html">PingEvent</a> const &amp;<a class="el" href="group___event_core.html#ga3296038c4343f22626c6595a222c0d95">event</a>) noexcept</td></tr>
<tr class="memdesc:a55fb391dd4bd122b1479041ea48bf3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for <a class="el" href="structqb_1_1_ping_event.html" title="Event used for actor health checks.">PingEvent</a>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Public Member Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>This part describes how to manage <a class="el" href="classqb_1_1_actor.html" title="Base class for all actors in the qb framework.">Actor</a> loop callback, events registration, several ways to send events and create referenced actors. </p>
</td></tr>
<tr class="memitem:a84ac3bd992b62dc8db9509529d1e01ec" id="r_a84ac3bd992b62dc8db9509529d1e01ec"><td class="memTemplParams" colspan="2">template&lt;typename _Actor&gt; </td></tr>
<tr class="memitem:a84ac3bd992b62dc8db9509529d1e01ec template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84ac3bd992b62dc8db9509529d1e01ec">registerCallback</a> (_Actor &amp;<a class="el" href="group___actor.html#gac38e7a5f336d9e903240705500b6d9b6">actor</a>) const noexcept</td></tr>
<tr class="memdesc:a84ac3bd992b62dc8db9509529d1e01ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a looped callback for this actor.  <br /></td></tr>
<tr class="memitem:a23b8e60367d2a59e087e225e4a4df1c8" id="r_a23b8e60367d2a59e087e225e4a4df1c8"><td class="memTemplParams" colspan="2">template&lt;typename _Actor&gt; </td></tr>
<tr class="memitem:a23b8e60367d2a59e087e225e4a4df1c8 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23b8e60367d2a59e087e225e4a4df1c8">unregisterCallback</a> (_Actor &amp;<a class="el" href="group___actor.html#gac38e7a5f336d9e903240705500b6d9b6">actor</a>) const noexcept</td></tr>
<tr class="memdesc:a23b8e60367d2a59e087e225e4a4df1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a previously registered looped callback for this actor.  <br /></td></tr>
<tr class="memitem:a0b7ee1d2a9d94988860df5ba5f19072c" id="r_a0b7ee1d2a9d94988860df5ba5f19072c"><td class="memTemplParams" colspan="2">template&lt;typename _Event, typename _Actor&gt; </td></tr>
<tr class="memitem:a0b7ee1d2a9d94988860df5ba5f19072c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b7ee1d2a9d94988860df5ba5f19072c">registerEvent</a> (_Actor &amp;<a class="el" href="group___actor.html#gac38e7a5f336d9e903240705500b6d9b6">actor</a>) const noexcept</td></tr>
<tr class="memdesc:a0b7ee1d2a9d94988860df5ba5f19072c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe this actor to listen for a specific event type.  <br /></td></tr>
<tr class="memitem:ae5494ea129a6ebf25510996d1699ac43" id="r_ae5494ea129a6ebf25510996d1699ac43"><td class="memTemplParams" colspan="2">template&lt;typename _Event, typename _Actor&gt; </td></tr>
<tr class="memitem:ae5494ea129a6ebf25510996d1699ac43 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5494ea129a6ebf25510996d1699ac43">unregisterEvent</a> (_Actor &amp;<a class="el" href="group___actor.html#gac38e7a5f336d9e903240705500b6d9b6">actor</a>) const noexcept</td></tr>
<tr class="memdesc:ae5494ea129a6ebf25510996d1699ac43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe this actor from listening to a specific event type.  <br /></td></tr>
<tr class="memitem:aab94c84d3cca286d3a3f700fdea6e552" id="r_aab94c84d3cca286d3a3f700fdea6e552"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqb_1_1_actor_1_1_event_builder.html">EventBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab94c84d3cca286d3a3f700fdea6e552">to</a> (<a class="el" href="classqb_1_1_actor_id.html">ActorId</a> dest) const noexcept</td></tr>
<tr class="memdesc:aab94c84d3cca286d3a3f700fdea6e552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <a class="el" href="classqb_1_1_actor_1_1_event_builder.html" title="Helper class for building and sending events to actors.">EventBuilder</a> for sending chained events to a destination actor.  <br /></td></tr>
<tr class="memitem:a45e94c367d5877e6406bf356c145a529" id="r_a45e94c367d5877e6406bf356c145a529"><td class="memTemplParams" colspan="2">template&lt;typename _Event, typename... _Args&gt; </td></tr>
<tr class="memitem:a45e94c367d5877e6406bf356c145a529 template"><td class="memItemLeft" align="right" valign="top">_Event &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45e94c367d5877e6406bf356c145a529">push</a> (<a class="el" href="classqb_1_1_actor_id.html">ActorId</a> const &amp;dest, _Args &amp;&amp;...args) const noexcept</td></tr>
<tr class="memdesc:a45e94c367d5877e6406bf356c145a529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a new event in an ordered fashion to a destination actor, returning a reference to it.  <br /></td></tr>
<tr class="memitem:ac739dafd53101a1d03ddd368ea890a8c" id="r_ac739dafd53101a1d03ddd368ea890a8c"><td class="memTemplParams" colspan="2">template&lt;typename _Event, typename... _Args&gt; </td></tr>
<tr class="memitem:ac739dafd53101a1d03ddd368ea890a8c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac739dafd53101a1d03ddd368ea890a8c">send</a> (<a class="el" href="classqb_1_1_actor_id.html">ActorId</a> const &amp;dest, _Args &amp;&amp;...args) const noexcept</td></tr>
<tr class="memdesc:ac739dafd53101a1d03ddd368ea890a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a new event in an unordered fashion to a destination actor.  <br /></td></tr>
<tr class="memitem:a20c8319b3fb3fb578cf75f6fc37760c6" id="r_a20c8319b3fb3fb578cf75f6fc37760c6"><td class="memTemplParams" colspan="2">template&lt;typename _Event, typename... _Args&gt; </td></tr>
<tr class="memitem:a20c8319b3fb3fb578cf75f6fc37760c6 template"><td class="memItemLeft" align="right" valign="top">_Event&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20c8319b3fb3fb578cf75f6fc37760c6">build_event</a> (<a class="el" href="classqb_1_1_actor_id.html">qb::ActorId</a> const source, _Args &amp;&amp;...args) const noexcept</td></tr>
<tr class="memdesc:a20c8319b3fb3fb578cf75f6fc37760c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an event locally, intended for immediate self-processing or direct calls.  <br /></td></tr>
<tr class="memitem:a04aa20243318124e0412d07a9a362ed6" id="r_a04aa20243318124e0412d07a9a362ed6"><td class="memTemplParams" colspan="2">template&lt;typename _Type&gt; </td></tr>
<tr class="memitem:a04aa20243318124e0412d07a9a362ed6 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04aa20243318124e0412d07a9a362ed6">is</a> (uint32_t const <a class="el" href="#a9999e9e7f937bbcf96a20127fe993092">id</a>) const noexcept</td></tr>
<tr class="memdesc:a04aa20243318124e0412d07a9a362ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a given ID matches the type ID of <span class="tt">_Type</span>.  <br /></td></tr>
<tr class="memitem:ad973d73c28479a2c1e504ad092c24ff5" id="r_ad973d73c28479a2c1e504ad092c24ff5"><td class="memTemplParams" colspan="2">template&lt;typename _Type&gt; </td></tr>
<tr class="memitem:ad973d73c28479a2c1e504ad092c24ff5 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad973d73c28479a2c1e504ad092c24ff5">is</a> (<a class="el" href="structqb_1_1_require_event.html">RequireEvent</a> const &amp;<a class="el" href="group___event_core.html#ga3296038c4343f22626c6595a222c0d95">event</a>) const noexcept</td></tr>
<tr class="memdesc:ad973d73c28479a2c1e504ad092c24ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a <span class="tt"><a class="el" href="structqb_1_1_require_event.html" title="Event used to query actor status.">RequireEvent</a></span> is for a specific actor type.  <br /></td></tr>
<tr class="memitem:afdd14b09a2e5dfe93f4851f08b7c5591" id="r_afdd14b09a2e5dfe93f4851f08b7c5591"><td class="memTemplParams" colspan="2">template&lt;typename... _Actors&gt; </td></tr>
<tr class="memitem:afdd14b09a2e5dfe93f4851f08b7c5591 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdd14b09a2e5dfe93f4851f08b7c5591">require</a> () const noexcept</td></tr>
<tr class="memdesc:afdd14b09a2e5dfe93f4851f08b7c5591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request discovery of other actors of specified types.  <br /></td></tr>
<tr class="memitem:ab229da5c0fdd23b494427e5de43bb394" id="r_ab229da5c0fdd23b494427e5de43bb394"><td class="memTemplParams" colspan="2">template&lt;typename _Event, typename... _Args&gt; </td></tr>
<tr class="memitem:ab229da5c0fdd23b494427e5de43bb394 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab229da5c0fdd23b494427e5de43bb394">broadcast</a> (_Args &amp;&amp;...args) const noexcept</td></tr>
<tr class="memdesc:ab229da5c0fdd23b494427e5de43bb394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast an event to all actors on all cores.  <br /></td></tr>
<tr class="memitem:aa87d1fc0d9360e73182e2d76c41a3dc7" id="r_aa87d1fc0d9360e73182e2d76c41a3dc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa87d1fc0d9360e73182e2d76c41a3dc7">reply</a> (<a class="el" href="classqb_1_1_event.html">Event</a> &amp;<a class="el" href="group___event_core.html#ga3296038c4343f22626c6595a222c0d95">event</a>) const noexcept</td></tr>
<tr class="memdesc:aa87d1fc0d9360e73182e2d76c41a3dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reply to the source of a received event, reusing the event object.  <br /></td></tr>
<tr class="memitem:a8ce447c4172327bc8807fd90d4551560" id="r_a8ce447c4172327bc8807fd90d4551560"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ce447c4172327bc8807fd90d4551560">forward</a> (<a class="el" href="classqb_1_1_actor_id.html">ActorId</a> dest, <a class="el" href="classqb_1_1_event.html">Event</a> &amp;<a class="el" href="group___event_core.html#ga3296038c4343f22626c6595a222c0d95">event</a>) const noexcept</td></tr>
<tr class="memdesc:a8ce447c4172327bc8807fd90d4551560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward a received event to a new destination, reusing the event object.  <br /></td></tr>
<tr class="memitem:a405c602b335d8f75261106367af38321" id="r_a405c602b335d8f75261106367af38321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqb_1_1_pipe.html">Pipe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a405c602b335d8f75261106367af38321">getPipe</a> (<a class="el" href="classqb_1_1_actor_id.html">ActorId</a> dest) const noexcept</td></tr>
<tr class="memdesc:a405c602b335d8f75261106367af38321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get direct access to the underlying communication pipe for a destination actor.  <br /></td></tr>
<tr class="memitem:a3137f7dedde694d2bc3cdb1a074485f2" id="r_a3137f7dedde694d2bc3cdb1a074485f2"><td class="memTemplParams" colspan="2">template&lt;typename _Actor, typename... _Args&gt; </td></tr>
<tr class="memitem:a3137f7dedde694d2bc3cdb1a074485f2 template"><td class="memItemLeft" align="right" valign="top">_Actor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3137f7dedde694d2bc3cdb1a074485f2">addRefActor</a> (_Args &amp;&amp;...args) const</td></tr>
<tr class="memdesc:a3137f7dedde694d2bc3cdb1a074485f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and initialize a new referenced actor on the same <a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Public Accessors</h2></td></tr>
<tr class="memitem:a9999e9e7f937bbcf96a20127fe993092" id="r_a9999e9e7f937bbcf96a20127fe993092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqb_1_1_actor_id.html">ActorId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9999e9e7f937bbcf96a20127fe993092">id</a> () const noexcept</td></tr>
<tr class="memdesc:a9999e9e7f937bbcf96a20127fe993092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classqb_1_1_actor_id.html" title="Unique identifier for actors.">ActorId</a>.  <br /></td></tr>
<tr class="memitem:a9bd1a8a3b244d721ff43da45fc5a305f" id="r_a9bd1a8a3b244d721ff43da45fc5a305f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___core.html#ga12fea0af12c10133b833eb488e52a9d1">CoreId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bd1a8a3b244d721ff43da45fc5a305f">getIndex</a> () const noexcept</td></tr>
<tr class="memdesc:a9bd1a8a3b244d721ff43da45fc5a305f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get core index.  <br /></td></tr>
<tr class="memitem:a7dda6de7e3aab4fb7ec6cffe3c8c4587" id="r_a7dda6de7e3aab4fb7ec6cffe3c8c4587"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dda6de7e3aab4fb7ec6cffe3c8c4587">getName</a> () const noexcept</td></tr>
<tr class="memdesc:a7dda6de7e3aab4fb7ec6cffe3c8c4587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get derived class name.  <br /></td></tr>
<tr class="memitem:a78766228f7805019a17318e678932f1d" id="r_a78766228f7805019a17318e678932f1d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___core.html#gaf938afc2318277511d1b20184c0c1152">CoreIdSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78766228f7805019a17318e678932f1d">getCoreSet</a> () const noexcept</td></tr>
<tr class="memdesc:a78766228f7805019a17318e678932f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of cores that this actor's <a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a> can communicate with.  <br /></td></tr>
<tr class="memitem:a3c9c01fc3fd1b689b5debb8f11434379" id="r_a3c9c01fc3fd1b689b5debb8f11434379"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c9c01fc3fd1b689b5debb8f11434379">time</a> () const noexcept</td></tr>
<tr class="memdesc:a3c9c01fc3fd1b689b5debb8f11434379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current time from the <a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a>'s perspective (nanoseconds since epoch).  <br /></td></tr>
<tr class="memitem:a16acfb752bd30d0782661e8005ee142a" id="r_a16acfb752bd30d0782661e8005ee142a"><td class="memTemplParams" colspan="2">template&lt;typename _ServiceActor&gt; </td></tr>
<tr class="memitem:a16acfb752bd30d0782661e8005ee142a template"><td class="memItemLeft" align="right" valign="top">_ServiceActor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16acfb752bd30d0782661e8005ee142a">getService</a> () const noexcept</td></tr>
<tr class="memdesc:a16acfb752bd30d0782661e8005ee142a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get direct access to ServiceActor* in same core.  <br /></td></tr>
<tr class="memitem:adea54248981ce2b0e66fbf4c3518acd1" id="r_adea54248981ce2b0e66fbf4c3518acd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adea54248981ce2b0e66fbf4c3518acd1">is_alive</a> () const noexcept</td></tr>
<tr class="memdesc:adea54248981ce2b0e66fbf4c3518acd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <a class="el" href="classqb_1_1_actor.html" title="Base class for all actors in the qb framework.">Actor</a> is alive and processing events.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Construction/Destruction</h2></td></tr>
<tr class="memitem:a8e8f179bac677c2e23f4c26cf4a1c0c1" id="r_a8e8f179bac677c2e23f4c26cf4a1c0c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e8f179bac677c2e23f4c26cf4a1c0c1">Actor</a> () noexcept</td></tr>
<tr class="memdesc:a8e8f179bac677c2e23f4c26cf4a1c0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="memitem:ae2dc6fc50459a5763a7b02a6b8e12477" id="r_ae2dc6fc50459a5763a7b02a6b8e12477"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2dc6fc50459a5763a7b02a6b8e12477">~Actor</a> () noexcept=default</td></tr>
<tr class="memdesc:ae2dc6fc50459a5763a7b02a6b8e12477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="memitem:ae61217d6ef37d4658b41cec6d2f6719f" id="r_ae61217d6ef37d4658b41cec6d2f6719f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae61217d6ef37d4658b41cec6d2f6719f">onInit</a> ()</td></tr>
<tr class="memdesc:ae61217d6ef37d4658b41cec6d2f6719f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization callback, called once after construction and ID assignment.  <br /></td></tr>
<tr class="memitem:ad097f332e8617029cbd8031c1f8fdf84" id="r_ad097f332e8617029cbd8031c1f8fdf84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad097f332e8617029cbd8031c1f8fdf84">kill</a> () const noexcept</td></tr>
<tr class="memdesc:ad097f332e8617029cbd8031c1f8fdf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate this actor and mark it for removal from the system.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for all actors in the qb framework. </p>
<p>The <a class="el" href="classqb_1_1_actor.html" title="Base class for all actors in the qb framework.">Actor</a> class is the fundamental unit of computation in the qb framework. Actors communicate exclusively by passing messages (events) to each other, which are processed by event handlers. This messaging pattern ensures isolation and prevents shared mutable state, making the system more robust for concurrent and distributed applications.</p>
<p>Each actor:</p><ul>
<li>Has a unique identity (<a class="el" href="classqb_1_1_actor_id.html" title="Unique identifier for actors.">ActorId</a>)</li>
<li>Processes events asynchronously</li>
<li>Can send events to other actors</li>
<li>Manages its own internal state</li>
<li>Has a well-defined lifecycle</li>
</ul>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyActor : <span class="keyword">public</span> <a class="code hl_class" href="classqb_1_1_actor.html">qb::Actor</a> {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">int</span> counter = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Custom event type</span></div>
<div class="line">    <span class="keyword">struct </span>IncrementEvent : <a class="code hl_class" href="classqb_1_1_event.html">qb::Event</a> {</div>
<div class="line">        <span class="keywordtype">int</span> amount;</div>
<div class="line">        IncrementEvent(<span class="keywordtype">int</span> amt) : amount(amt) {}</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code hl_function" href="#ae61217d6ef37d4658b41cec6d2f6719f">onInit</a>()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Register event handlers</span></div>
<div class="line">        <a class="code hl_function" href="#a0b7ee1d2a9d94988860df5ba5f19072c">registerEvent&lt;IncrementEvent&gt;</a>(*<span class="keyword">this</span>);</div>
<div class="line">        <a class="code hl_function" href="#a0b7ee1d2a9d94988860df5ba5f19072c">registerEvent&lt;qb::KillEvent&gt;</a>(*<span class="keyword">this</span>);</div>
<div class="line">        <a class="code hl_define" href="io_8h.html#a81125cfd7753025dc4ac27c6fa9d1180">LOG_INFO</a>(<span class="stringliteral">&quot;MyActor initialized with ID: &quot;</span> &lt;&lt; <span class="keywordtype">id</span>());</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="#a245a2b7be6e086bf622d2acb78b9bded">on</a>(<span class="keyword">const</span> IncrementEvent&amp; <a class="code hl_typedef" href="group___event_core.html#ga3296038c4343f22626c6595a222c0d95">event</a>) {</div>
<div class="line">        counter += <span class="keyword">event</span>.amount;</div>
<div class="line">        <a class="code hl_define" href="io_8h.html#a81125cfd7753025dc4ac27c6fa9d1180">LOG_INFO</a>(<span class="stringliteral">&quot;Counter updated to: &quot;</span> &lt;&lt; counter);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="#a245a2b7be6e086bf622d2acb78b9bded">on</a>(<span class="keyword">const</span> qb::KillEvent&amp; <a class="code hl_typedef" href="group___event_core.html#ga3296038c4343f22626c6595a222c0d95">event</a>) {</div>
<div class="line">        <a class="code hl_define" href="io_8h.html#a81125cfd7753025dc4ac27c6fa9d1180">LOG_INFO</a>(<span class="stringliteral">&quot;MyActor shutting down...&quot;</span>);</div>
<div class="line">        <a class="code hl_function" href="#ad097f332e8617029cbd8031c1f8fdf84">kill</a>();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In a VirtualCore or Main context:</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_typedef" href="group___core.html#ga577f0efb6b04ea39f9e8330f13dddeaa">actor_id</a> = addActor&lt;MyActor&gt;();</div>
<div class="line"><a class="code hl_function" href="#aab94c84d3cca286d3a3f700fdea6e552">to</a>(<a class="code hl_typedef" href="group___core.html#ga577f0efb6b04ea39f9e8330f13dddeaa">actor_id</a>).<a class="code hl_function" href="classqb_1_1_actor_1_1_event_builder.html#ab94b0f29b97ab2ad38175960595d1fcc">push</a>&lt;MyActor::IncrementEvent&gt;(5);</div>
<div class="ttc" id="aclassqb_1_1_actor_1_1_event_builder_html_ab94b0f29b97ab2ad38175960595d1fcc"><div class="ttname"><a href="classqb_1_1_actor_1_1_event_builder.html#ab94b0f29b97ab2ad38175960595d1fcc">qb::Actor::EventBuilder::push</a></div><div class="ttdeci">EventBuilder &amp; push(_Args &amp;&amp;...args) noexcept</div><div class="ttdoc">Send a new event to the target actor.</div></div>
<div class="ttc" id="aclassqb_1_1_actor_html"><div class="ttname"><a href="classqb_1_1_actor.html">qb::Actor</a></div><div class="ttdoc">Base class for all actors in the qb framework.</div><div class="ttdef"><b>Definition</b> Actor.h:106</div></div>
<div class="ttc" id="aclassqb_1_1_actor_html_a0b7ee1d2a9d94988860df5ba5f19072c"><div class="ttname"><a href="#a0b7ee1d2a9d94988860df5ba5f19072c">qb::Actor::registerEvent</a></div><div class="ttdeci">void registerEvent(_Actor &amp;actor) const noexcept</div><div class="ttdoc">Subscribe this actor to listen for a specific event type.</div></div>
<div class="ttc" id="aclassqb_1_1_actor_html_a245a2b7be6e086bf622d2acb78b9bded"><div class="ttname"><a href="#a245a2b7be6e086bf622d2acb78b9bded">qb::Actor::on</a></div><div class="ttdeci">void on(KillEvent const &amp;event) noexcept</div><div class="ttdoc">Handler for KillEvent.</div></div>
<div class="ttc" id="aclassqb_1_1_actor_html_aab94c84d3cca286d3a3f700fdea6e552"><div class="ttname"><a href="#aab94c84d3cca286d3a3f700fdea6e552">qb::Actor::to</a></div><div class="ttdeci">EventBuilder to(ActorId dest) const noexcept</div><div class="ttdoc">Get an EventBuilder for sending chained events to a destination actor.</div></div>
<div class="ttc" id="aclassqb_1_1_actor_html_ad097f332e8617029cbd8031c1f8fdf84"><div class="ttname"><a href="#ad097f332e8617029cbd8031c1f8fdf84">qb::Actor::kill</a></div><div class="ttdeci">void kill() const noexcept</div><div class="ttdoc">Terminate this actor and mark it for removal from the system.</div></div>
<div class="ttc" id="aclassqb_1_1_actor_html_ae61217d6ef37d4658b41cec6d2f6719f"><div class="ttname"><a href="#ae61217d6ef37d4658b41cec6d2f6719f">qb::Actor::onInit</a></div><div class="ttdeci">virtual bool onInit()</div><div class="ttdoc">Initialization callback, called once after construction and ID assignment.</div><div class="ttdef"><b>Definition</b> Actor.h:198</div></div>
<div class="ttc" id="aclassqb_1_1_event_html"><div class="ttname"><a href="classqb_1_1_event.html">qb::Event</a></div><div class="ttdoc">Base class for all events in the actor system.</div><div class="ttdef"><b>Definition</b> Event.h:85</div></div>
<div class="ttc" id="agroup___core_html_ga577f0efb6b04ea39f9e8330f13dddeaa"><div class="ttname"><a href="group___core.html#ga577f0efb6b04ea39f9e8330f13dddeaa">qb::actor_id</a></div><div class="ttdeci">ActorId actor_id</div><div class="ttdoc">Alias for ActorId.</div><div class="ttdef"><b>Definition</b> ActorId.h:495</div></div>
<div class="ttc" id="agroup___event_core_html_ga3296038c4343f22626c6595a222c0d95"><div class="ttname"><a href="group___event_core.html#ga3296038c4343f22626c6595a222c0d95">qb::event</a></div><div class="ttdeci">Event event</div><div class="ttdoc">Alias for the base Event class.</div><div class="ttdef"><b>Definition</b> Event.h:385</div></div>
<div class="ttc" id="aio_8h_html_a81125cfd7753025dc4ac27c6fa9d1180"><div class="ttname"><a href="io_8h.html#a81125cfd7753025dc4ac27c6fa9d1180">LOG_INFO</a></div><div class="ttdeci">#define LOG_INFO(X)</div><div class="ttdoc">Info-level log macro (no-op if QB_STDOUT_LOG is not defined)</div><div class="ttdef"><b>Definition</b> io.h:229</div></div>
</div><!-- fragment --> </div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8e8f179bac677c2e23f4c26cf4a1c0c1" name="a8e8f179bac677c2e23f4c26cf4a1c0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8f179bac677c2e23f4c26cf4a1c0c1">&#9670;&#160;</a></span>Actor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">qb::Actor::Actor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an actor with a default (invalid) ID. The actual ID will be assigned when the actor is registered with a <a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a>. </p>

</div>
</div>
<a id="ae2dc6fc50459a5763a7b02a6b8e12477" name="ae2dc6fc50459a5763a7b02a6b8e12477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2dc6fc50459a5763a7b02a6b8e12477">&#9670;&#160;</a></span>~Actor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual qb::Actor::~Actor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual destructor. </p>
<p>Ensures proper cleanup of derived actor classes. </p><dl class="section note"><dt>Note</dt><dd>Called after the actor logic has completed and it has been removed from the engine. </dd></dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ae61217d6ef37d4658b41cec6d2f6719f" name="ae61217d6ef37d4658b41cec6d2f6719f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61217d6ef37d4658b41cec6d2f6719f">&#9670;&#160;</a></span>onInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool qb::Actor::onInit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization callback, called once after construction and ID assignment. </p>
<p>This method is called when the actor is added to the system, before it starts processing any events. Override this method to perform initialization tasks such as registering event handlers and setting up actor state.</p>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful, which allows the actor to start. </dd>
<dd>
false if initialization failed, which prevents the actor from being added to the engine and leads to its immediate destruction.</dd></dl>
<p>Crucial for <span class="tt">registerEvent&lt;EventType&gt;(*this)</span> calls. Example: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="#ae61217d6ef37d4658b41cec6d2f6719f">onInit</a>()<span class="keyword"> override </span>{</div>
<div class="line">  <span class="comment">// Register events</span></div>
<div class="line">  <a class="code hl_function" href="#a0b7ee1d2a9d94988860df5ba5f19072c">registerEvent&lt;CustomEvent&gt;</a>(*<span class="keyword">this</span>);</div>
<div class="line">  <a class="code hl_function" href="#a0b7ee1d2a9d94988860df5ba5f19072c">registerEvent&lt;qb::KillEvent&gt;</a>(*<span class="keyword">this</span>); <span class="comment">// Important for graceful shutdown</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Initialize resources or state</span></div>
<div class="line">  _my_resource = std::make_unique&lt;MyResource&gt;();</div>
<div class="line">  <span class="keywordflow">if</span> (!_my_resource) {</div>
<div class="line">    <a class="code hl_define" href="io_8h.html#a163bdd86da9b6aaadb7ec837a67fdfcc">LOG_CRIT</a>(<span class="stringliteral">&quot;Failed to allocate MyResource for Actor &quot;</span> &lt;&lt; <span class="keywordtype">id</span>());</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;  <span class="comment">// Initialization failed</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_define" href="io_8h.html#a81125cfd7753025dc4ac27c6fa9d1180">LOG_INFO</a>(<span class="stringliteral">&quot;Actor &quot;</span> &lt;&lt; <span class="keywordtype">id</span>() &lt;&lt; <span class="stringliteral">&quot; initialized successfully.&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;     <span class="comment">// Initialization successful</span></div>
<div class="line">}</div>
<div class="ttc" id="aio_8h_html_a163bdd86da9b6aaadb7ec837a67fdfcc"><div class="ttname"><a href="io_8h.html#a163bdd86da9b6aaadb7ec837a67fdfcc">LOG_CRIT</a></div><div class="ttdeci">#define LOG_CRIT(X)</div><div class="ttdoc">Critical-level log macro (no-op if QB_STDOUT_LOG is not defined)</div><div class="ttdef"><b>Definition</b> io.h:243</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad097f332e8617029cbd8031c1f8fdf84" name="ad097f332e8617029cbd8031c1f8fdf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad097f332e8617029cbd8031c1f8fdf84">&#9670;&#160;</a></span>kill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qb::Actor::kill </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Terminate this actor and mark it for removal from the system. </p>
<p>Marks the actor for removal from the system. After calling this method, the actor will no longer receive new events (though it may process events already in its queue) and will be cleaned up by the framework during the next appropriate cycle.</p>
<p>This method is typically called from within an event handler (e.g., <span class="tt">on(<a class="el" href="structqb_1_1_kill_event.html" title="Event used to terminate an actor.">qb::KillEvent</a>&amp;)</span>) when the actor decides to terminate itself, or it can be triggered by sending a <span class="tt"><a class="el" href="structqb_1_1_kill_event.html" title="Event used to terminate an actor.">KillEvent</a></span> to the actor. </p><dl class="section note"><dt>Note</dt><dd>This method only flags the actor for termination; the actual destruction and <span class="tt"><a class="el" href="#ae2dc6fc50459a5763a7b02a6b8e12477" title="Virtual destructor.">~Actor()</a></span> call occur later, managed by the <span class="tt"><a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a></span>. </dd></dl>

</div>
</div>
<a id="a245a2b7be6e086bf622d2acb78b9bded" name="a245a2b7be6e086bf622d2acb78b9bded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245a2b7be6e086bf622d2acb78b9bded">&#9670;&#160;</a></span>on() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qb::Actor::on </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqb_1_1_kill_event.html">KillEvent</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>event</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handler for <a class="el" href="structqb_1_1_kill_event.html" title="Event used to terminate an actor.">KillEvent</a>. </p>
<p>Default handler for the <a class="el" href="structqb_1_1_kill_event.html" title="Event used to terminate an actor.">KillEvent</a> which terminates the actor by calling <span class="tt">this-&gt;<a class="el" href="#ad097f332e8617029cbd8031c1f8fdf84" title="Terminate this actor and mark it for removal from the system.">kill()</a></span>. Derived classes can override this handler to perform cleanup actions before termination, but should typically call <span class="tt"><a class="el" href="#ad097f332e8617029cbd8031c1f8fdf84" title="Terminate this actor and mark it for removal from the system.">Actor::kill()</a></span> or <span class="tt">this-&gt;<a class="el" href="#ad097f332e8617029cbd8031c1f8fdf84" title="Terminate this actor and mark it for removal from the system.">kill()</a></span> at the end of their implementation to ensure proper termination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The received kill event (often unused in overrides, but available). Example of overriding: <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="#a245a2b7be6e086bf622d2acb78b9bded">on</a>(<a class="code hl_struct" href="structqb_1_1_kill_event.html">qb::KillEvent</a> <span class="keyword">const</span> &amp;<a class="code hl_typedef" href="group___event_core.html#ga3296038c4343f22626c6595a222c0d95">event</a>)<span class="keyword"> override </span>{</div>
<div class="line">  <a class="code hl_define" href="io_8h.html#a81125cfd7753025dc4ac27c6fa9d1180">LOG_INFO</a>(<span class="stringliteral">&quot;Actor &quot;</span> &lt;&lt; <span class="keywordtype">id</span>() &lt;&lt; <span class="stringliteral">&quot; cleaning up before termination...&quot;</span>);</div>
<div class="line">  <span class="comment">// Perform cleanup: close connections, release resources not handled by RAII, etc.</span></div>
<div class="line">  closeConnections();</div>
<div class="line">  releaseResources();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Finally, ensure the actor is marked for termination</span></div>
<div class="line">  <a class="code hl_function" href="#ad097f332e8617029cbd8031c1f8fdf84">Actor::kill</a>(); <span class="comment">// Or just kill();</span></div>
<div class="line">}</div>
<div class="ttc" id="astructqb_1_1_kill_event_html"><div class="ttname"><a href="structqb_1_1_kill_event.html">qb::KillEvent</a></div><div class="ttdoc">Event used to terminate an actor.</div><div class="ttdef"><b>Definition</b> Event.h:258</div></div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae75c0d54caa6c2b9073527d2ac909dab" name="ae75c0d54caa6c2b9073527d2ac909dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75c0d54caa6c2b9073527d2ac909dab">&#9670;&#160;</a></span>on() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qb::Actor::on </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqb_1_1_signal_event.html">SignalEvent</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>event</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handler for <a class="el" href="structqb_1_1_signal_event.html" title="Event used to handle system signals.">SignalEvent</a>. </p>
<p>Default handler for system signals (e.g., SIGINT) that terminates the actor. Derived classes can override this handler to perform custom signal handling. If overridden, ensure proper state management or actor termination if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The received signal event, containing <span class="tt">event.signum</span>. Example of overriding: <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="#a245a2b7be6e086bf622d2acb78b9bded">on</a>(<a class="code hl_struct" href="structqb_1_1_signal_event.html">qb::SignalEvent</a> <span class="keyword">const</span> &amp;<a class="code hl_typedef" href="group___event_core.html#ga3296038c4343f22626c6595a222c0d95">event</a>)<span class="keyword"> override </span>{</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code hl_typedef" href="group___event_core.html#ga3296038c4343f22626c6595a222c0d95">event</a>.signum == SIGINT) {</div>
<div class="line">    <a class="code hl_define" href="io_8h.html#a81125cfd7753025dc4ac27c6fa9d1180">LOG_INFO</a>(<span class="stringliteral">&quot;Actor &quot;</span> &lt;&lt; <span class="keywordtype">id</span>() &lt;&lt; <span class="stringliteral">&quot; received SIGINT, performing graceful shutdown.&quot;</span>);</div>
<div class="line">    <span class="comment">// Custom shutdown logic here...</span></div>
<div class="line">    <a class="code hl_function" href="#ad097f332e8617029cbd8031c1f8fdf84">kill</a>(); <span class="comment">// Terminate the actor</span></div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_typedef" href="group___event_core.html#ga3296038c4343f22626c6595a222c0d95">event</a>.signum == SIGUSR1) {</div>
<div class="line">    <a class="code hl_define" href="io_8h.html#a81125cfd7753025dc4ac27c6fa9d1180">LOG_INFO</a>(<span class="stringliteral">&quot;Actor &quot;</span> &lt;&lt; <span class="keywordtype">id</span>() &lt;&lt; <span class="stringliteral">&quot; received SIGUSR1, reloading configuration.&quot;</span>);</div>
<div class="line">    reloadConfig();</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <a class="code hl_define" href="io_8h.html#aeff5b3ac3d7e22272df68059ed892cae">LOG_WARN</a>(<span class="stringliteral">&quot;Actor &quot;</span> &lt;&lt; <span class="keywordtype">id</span>() &lt;&lt; <span class="stringliteral">&quot; received unhandled signal: &quot;</span> &lt;&lt; <a class="code hl_typedef" href="group___event_core.html#ga3296038c4343f22626c6595a222c0d95">event</a>.signum);</div>
<div class="line">    <span class="comment">// Default behavior for other signals might be to kill, or call base:</span></div>
<div class="line">    <span class="comment">// Actor::on(event); </span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aio_8h_html_aeff5b3ac3d7e22272df68059ed892cae"><div class="ttname"><a href="io_8h.html#aeff5b3ac3d7e22272df68059ed892cae">LOG_WARN</a></div><div class="ttdeci">#define LOG_WARN(X)</div><div class="ttdoc">Warning-level log macro (no-op if QB_STDOUT_LOG is not defined)</div><div class="ttdef"><b>Definition</b> io.h:236</div></div>
<div class="ttc" id="astructqb_1_1_signal_event_html"><div class="ttname"><a href="structqb_1_1_signal_event.html">qb::SignalEvent</a></div><div class="ttdoc">Event used to handle system signals.</div><div class="ttdef"><b>Definition</b> Event.h:272</div></div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af14f0d20ea7e4383c9e741f92974a3a8" name="af14f0d20ea7e4383c9e741f92974a3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14f0d20ea7e4383c9e741f92974a3a8">&#9670;&#160;</a></span>on() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qb::Actor::on </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqb_1_1_unregister_callback_event.html">UnregisterCallbackEvent</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>event</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handler for <a class="el" href="structqb_1_1_unregister_callback_event.html" title="Event used to unregister an actor&#39;s callback.">UnregisterCallbackEvent</a>. </p>
<p>This handler unregisters a previously registered callback for this actor. It should generally not be overridden by derived classes as its behavior is fixed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The received unregister callback event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This event is usually sent internally when <span class="tt"><a class="el" href="#a23b8e60367d2a59e087e225e4a4df1c8" title="Unregister a previously registered looped callback for this actor.">unregisterCallback()</a></span> is called. </dd></dl>

</div>
</div>
<a id="a55fb391dd4bd122b1479041ea48bf3f5" name="a55fb391dd4bd122b1479041ea48bf3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55fb391dd4bd122b1479041ea48bf3f5">&#9670;&#160;</a></span>on() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qb::Actor::on </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqb_1_1_ping_event.html">PingEvent</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>event</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handler for <a class="el" href="structqb_1_1_ping_event.html" title="Event used for actor health checks.">PingEvent</a>. </p>
<p>Responds to ping requests, primarily used for actor alive checks, diagnostics, and by the <span class="tt">require&lt;T&gt;()</span> mechanism for actor discovery. The default implementation sends a <span class="tt"><a class="el" href="structqb_1_1_require_event.html" title="Event used to query actor status.">RequireEvent</a></span> back to the source of the <span class="tt"><a class="el" href="structqb_1_1_ping_event.html" title="Event used for actor health checks.">PingEvent</a></span> if the ping type matches.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The received ping event, containing <span class="tt">event.type</span> to match against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Derived classes typically do not need to override this unless they have very specific custom ping/discovery logic. </dd></dl>

</div>
</div>
<a id="a9999e9e7f937bbcf96a20127fe993092" name="a9999e9e7f937bbcf96a20127fe993092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9999e9e7f937bbcf96a20127fe993092">&#9670;&#160;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqb_1_1_actor_id.html">ActorId</a> qb::Actor::id </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get <a class="el" href="classqb_1_1_actor_id.html" title="Unique identifier for actors.">ActorId</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classqb_1_1_actor_id.html" title="Unique identifier for actors.">ActorId</a> of this actor. This ID is unique within the QB system. </dd></dl>

</div>
</div>
<a id="a9bd1a8a3b244d721ff43da45fc5a305f" name="a9bd1a8a3b244d721ff43da45fc5a305f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd1a8a3b244d721ff43da45fc5a305f">&#9670;&#160;</a></span>getIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___core.html#ga12fea0af12c10133b833eb488e52a9d1">CoreId</a> qb::Actor::getIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get core index. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___core.html#ga12fea0af12c10133b833eb488e52a9d1" title="Type definition for core identifiers.">CoreId</a> (unsigned short) indicating the <a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a> where this actor is running. </dd></dl>

</div>
</div>
<a id="a7dda6de7e3aab4fb7ec6cffe3c8c4587" name="a7dda6de7e3aab4fb7ec6cffe3c8c4587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dda6de7e3aab4fb7ec6cffe3c8c4587">&#9670;&#160;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view qb::Actor::getName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get derived class name. </p>
<dl class="section return"><dt>Returns</dt><dd>A <span class="tt">std::string_view</span> of this actor's demangled class name. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The name is determined at compile time via <span class="tt">typeid</span>. </dd></dl>

</div>
</div>
<a id="a78766228f7805019a17318e678932f1d" name="a78766228f7805019a17318e678932f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78766228f7805019a17318e678932f1d">&#9670;&#160;</a></span>getCoreSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___core.html#gaf938afc2318277511d1b20184c0c1152">CoreIdSet</a> &amp; qb::Actor::getCoreSet </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the set of cores that this actor's <a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a> can communicate with. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference to a <span class="tt"><a class="el" href="group___core.html#gaf938afc2318277511d1b20184c0c1152" title="Efficient set implementation for storing CoreId values.">CoreIdSet</a></span> representing connected cores.</dd></dl>
<p>This reflects the <span class="tt"><a class="el" href="classqb_1_1_core_set.html" title="Manages a set of core identifiers.">CoreSet</a></span> the <span class="tt"><a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a></span> was initialized with. </p>

</div>
</div>
<a id="a3c9c01fc3fd1b689b5debb8f11434379" name="a3c9c01fc3fd1b689b5debb8f11434379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9c01fc3fd1b689b5debb8f11434379">&#9670;&#160;</a></span>time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t qb::Actor::time </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current time from the <a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a>'s perspective (nanoseconds since epoch). </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">uint64_t</span> timestamp in nanoseconds.</dd></dl>
<p>This value is optimized and cached/updated by the <span class="tt"><a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a></span> at the beginning of each of its processing loops. Thus, multiple calls to <span class="tt"><a class="el" href="#a3c9c01fc3fd1b689b5debb8f11434379" title="Get current time from the VirtualCore&#39;s perspective (nanoseconds since epoch).">time()</a></span> within the same event handler or <span class="tt">onCallback()</span> invocation will return the <em>same</em> timestamp. </p><div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keyword">auto</span> t1 = <a class="code hl_function" href="#a3c9c01fc3fd1b689b5debb8f11434379">time</a>();</div>
<div class="line"><span class="comment">// ... some heavy calculation ...</span></div>
<div class="line">assert(t1 == <a class="code hl_function" href="#a3c9c01fc3fd1b689b5debb8f11434379">time</a>()); <span class="comment">// true - will not assert within the same event handler execution</span></div>
<div class="ttc" id="aclassqb_1_1_actor_html_a3c9c01fc3fd1b689b5debb8f11434379"><div class="ttname"><a href="#a3c9c01fc3fd1b689b5debb8f11434379">qb::Actor::time</a></div><div class="ttdeci">uint64_t time() const noexcept</div><div class="ttdoc">Get current time from the VirtualCore&#39;s perspective (nanoseconds since epoch).</div></div>
</div><!-- fragment --><p> For a continuously updating, high-precision timestamp, use <span class="tt"><a class="el" href="group___time.html#gaaa757fc6404580f46cc811a0c6f7b65b" title="Backward compatibility alias for HighResTimePoint.">qb::NanoTimestamp()</a>::count()</span> from <span class="tt">&lt;<a class="el" href="timestamp_8h.html" title="High-precision timing utilities.">qb/system/timestamp.h</a>&gt;</span>. </p><dl class="section note"><dt>Note</dt><dd>This time is primarily for relative measurements or logging within an actor's turn. </dd></dl>

</div>
</div>
<a id="a16acfb752bd30d0782661e8005ee142a" name="a16acfb752bd30d0782661e8005ee142a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16acfb752bd30d0782661e8005ee142a">&#9670;&#160;</a></span>getService()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ServiceActor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_ServiceActor * qb::Actor::getService </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get direct access to ServiceActor* in same core. </p>
<dl class="section return"><dt>Returns</dt><dd>ptr to _ServiceActor else nullptr if not registered in core </dd></dl>

</div>
</div>
<a id="adea54248981ce2b0e66fbf4c3518acd1" name="adea54248981ce2b0e66fbf4c3518acd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea54248981ce2b0e66fbf4c3518acd1">&#9670;&#160;</a></span>is_alive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qb::Actor::is_alive </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <a class="el" href="classqb_1_1_actor.html" title="Base class for all actors in the qb framework.">Actor</a> is alive and processing events. </p>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="classqb_1_1_actor.html" title="Base class for all actors in the qb framework.">Actor</a> is alive (i.e., <span class="tt"><a class="el" href="#ad097f332e8617029cbd8031c1f8fdf84" title="Terminate this actor and mark it for removal from the system.">kill()</a></span> has not been effectively processed yet), false otherwise.</dd></dl>
<p>An actor is considered alive until its <span class="tt"><a class="el" href="#ad097f332e8617029cbd8031c1f8fdf84" title="Terminate this actor and mark it for removal from the system.">kill()</a></span> method has been called AND the <span class="tt"><a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a></span> has processed its removal. It might still process events in its queue after <span class="tt"><a class="el" href="#ad097f332e8617029cbd8031c1f8fdf84" title="Terminate this actor and mark it for removal from the system.">kill()</a></span> is called but before it's fully removed. </p>

</div>
</div>
<a id="a84ac3bd992b62dc8db9509529d1e01ec" name="a84ac3bd992b62dc8db9509529d1e01ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ac3bd992b62dc8db9509529d1e01ec">&#9670;&#160;</a></span>registerCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Actor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qb::Actor::registerCallback </td>
          <td>(</td>
          <td class="paramtype">_Actor &amp;</td>          <td class="paramname"><span class="paramname"><em>actor</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a looped callback for this actor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Actor</td><td>The derived actor type, which must inherit from <span class="tt"><a class="el" href="classqb_1_1_i_callback.html" title="Interface for actor callbacks.">qb::ICallback</a></span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actor</td><td>A reference to the derived actor instance (usually <span class="tt">*this</span>).</td></tr>
  </table>
  </dd>
</dl>
<p>The registered <span class="tt">onCallback()</span> method (from <span class="tt"><a class="el" href="classqb_1_1_i_callback.html" title="Interface for actor callbacks.">qb::ICallback</a></span>) will be called by the <span class="tt"><a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a></span> during each of its processing loop iterations, after event processing. This allows the actor to perform periodic tasks or background operations. The callback remains active until explicitly unregistered or the actor is terminated. </p><dl class="section note"><dt>Note</dt><dd>Ensure the <span class="tt">onCallback()</span> implementation is fast and non-blocking. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classqb_1_1_i_callback.html" title="Interface for actor callbacks.">qb::ICallback</a> <div class="fragment"><div class="line"><span class="keyword">class </span>MyPollingActor</div>
<div class="line">  : <span class="keyword">public</span> <a class="code hl_class" href="classqb_1_1_actor.html">qb::Actor</a></div>
<div class="line">  , <span class="keyword">public</span> <a class="code hl_interface" href="classqb_1_1_i_callback.html">qb::ICallback</a> <span class="comment">// Must inherit from ICallback</span></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="#ae61217d6ef37d4658b41cec6d2f6719f">onInit</a>()<span class="keyword"> override </span>{</div>
<div class="line">    <a class="code hl_function" href="#a84ac3bd992b62dc8db9509529d1e01ec">registerCallback</a>(*<span class="keyword">this</span>); <span class="comment">// Register self for periodic callbacks</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classqb_1_1_i_callback.html#abaccc7c519a89b821bc142b078166d56">onCallback</a>()<span class="keyword"> override </span>{</div>
<div class="line">    <span class="comment">// This code will be executed periodically by the VirtualCore</span></div>
<div class="line">    <span class="comment">// pollExternalSystem();</span></div>
<div class="line">    <span class="comment">// if (checkCondition()) {</span></div>
<div class="line">    <span class="comment">//   unregisterCallback(); // Stop further callbacks</span></div>
<div class="line">    <span class="comment">// }</span></div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// ... other methods and event handlers ...</span></div>
<div class="line">};</div>
<div class="ttc" id="aclassqb_1_1_actor_html_a84ac3bd992b62dc8db9509529d1e01ec"><div class="ttname"><a href="#a84ac3bd992b62dc8db9509529d1e01ec">qb::Actor::registerCallback</a></div><div class="ttdeci">void registerCallback(_Actor &amp;actor) const noexcept</div><div class="ttdoc">Register a looped callback for this actor.</div></div>
<div class="ttc" id="aclassqb_1_1_i_callback_html"><div class="ttname"><a href="classqb_1_1_i_callback.html">qb::ICallback</a></div><div class="ttdoc">Interface for actor callbacks.</div><div class="ttdef"><b>Definition</b> ICallback.h:49</div></div>
<div class="ttc" id="aclassqb_1_1_i_callback_html_abaccc7c519a89b821bc142b078166d56"><div class="ttname"><a href="classqb_1_1_i_callback.html#abaccc7c519a89b821bc142b078166d56">qb::ICallback::onCallback</a></div><div class="ttdeci">virtual void onCallback()=0</div><div class="ttdoc">Callback function executed during each VirtualCore loop iteration.</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a23b8e60367d2a59e087e225e4a4df1c8" name="a23b8e60367d2a59e087e225e4a4df1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b8e60367d2a59e087e225e4a4df1c8">&#9670;&#160;</a></span>unregisterCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Actor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qb::Actor::unregisterCallback </td>
          <td>(</td>
          <td class="paramtype">_Actor &amp;</td>          <td class="paramname"><span class="paramname"><em>actor</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister a previously registered looped callback for this actor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Actor</td><td>The derived actor type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actor</td><td>A reference to the derived actor instance (usually <span class="tt">*this</span>).</td></tr>
  </table>
  </dd>
</dl>
<p>Stops the periodic invocation of the actor's <span class="tt">onCallback()</span> method. It is safe to call this even if no callback is currently registered. </p><dl class="section note"><dt>Note</dt><dd>Can be called from within <span class="tt">onCallback()</span> to self-terminate the callback cycle, or from any event handler. <div class="fragment"><div class="line"><span class="comment">// void on(MyStopEvent&amp; event) {</span></div>
<div class="line"><span class="comment">//   unregisterCallback(*this); // Stop the periodic callback</span></div>
<div class="line"><span class="comment">// }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0b7ee1d2a9d94988860df5ba5f19072c" name="a0b7ee1d2a9d94988860df5ba5f19072c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7ee1d2a9d94988860df5ba5f19072c">&#9670;&#160;</a></span>registerEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Event, typename _Actor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qb::Actor::registerEvent </td>
          <td>(</td>
          <td class="paramtype">_Actor &amp;</td>          <td class="paramname"><span class="paramname"><em>actor</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe this actor to listen for a specific event type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Event</td><td>The type of event to listen for (must derive from <span class="tt"><a class="el" href="classqb_1_1_event.html" title="Base class for all events in the actor system.">qb::Event</a></span>). </td></tr>
    <tr><td class="paramname">_Actor</td><td>The derived actor type that implements the <span class="tt">on(_Event&amp;)</span> handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actor</td><td>A reference to the derived actor instance (usually <span class="tt">*this</span>).</td></tr>
  </table>
  </dd>
</dl>
<p>After registration, if an event of type <span class="tt">_Event</span> is sent to this actor's ID, its corresponding <span class="tt">void on(_Event&amp; event)</span> or <span class="tt">void on(const _Event&amp; event)</span> method will be invoked by the <span class="tt"><a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a></span>. This is typically called within the actor's <span class="tt"><a class="el" href="#ae61217d6ef37d4658b41cec6d2f6719f" title="Initialization callback, called once after construction and ID assignment.">onInit()</a></span> method. </p><dl class="section note"><dt>Note</dt><dd>The actor must have a public member function <span class="tt">void on(const _Event&amp; event)</span> or <span class="tt">void on(_Event&amp; event)</span>. <div class="fragment"><div class="line"><span class="comment">// bool onInit() override {</span></div>
<div class="line"><span class="comment">//   registerEvent&lt;MyCustomEvent&gt;(*this);</span></div>
<div class="line"><span class="comment">//   registerEvent&lt;AnotherEvent&gt;(*this);</span></div>
<div class="line"><span class="comment">//   return true;</span></div>
<div class="line"><span class="comment">// }</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">// void on(const MyCustomEvent&amp; event) {  handle MyCustomEvent... }</span></div>
<div class="line"><span class="comment">// void on(AnotherEvent&amp; event) { handle AnotherEvent, can reply/forward }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae5494ea129a6ebf25510996d1699ac43" name="ae5494ea129a6ebf25510996d1699ac43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5494ea129a6ebf25510996d1699ac43">&#9670;&#160;</a></span>unregisterEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Event, typename _Actor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qb::Actor::unregisterEvent </td>
          <td>(</td>
          <td class="paramtype">_Actor &amp;</td>          <td class="paramname"><span class="paramname"><em>actor</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe this actor from listening to a specific event type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Event</td><td>The type of event to stop listening for. </td></tr>
    <tr><td class="paramname">_Actor</td><td>The derived actor type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actor</td><td>A reference to the derived actor instance (usually <span class="tt">*this</span>).</td></tr>
  </table>
  </dd>
</dl>
<p>After this call, the actor will no longer receive new events of type <span class="tt">_Event</span>. It is safe to call this for event types the actor was not subscribed to. </p><div class="fragment"><div class="line"><span class="comment">// void on(StopListeningEvent&amp; event) {</span></div>
<div class="line"><span class="comment">//   unregisterEvent&lt;MyCustomEvent&gt;(*this);</span></div>
<div class="line"><span class="comment">// }</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aab94c84d3cca286d3a3f700fdea6e552" name="aab94c84d3cca286d3a3f700fdea6e552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab94c84d3cca286d3a3f700fdea6e552">&#9670;&#160;</a></span>to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqb_1_1_actor_1_1_event_builder.html">EventBuilder</a> qb::Actor::to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqb_1_1_actor_id.html">ActorId</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an <a class="el" href="classqb_1_1_actor_1_1_event_builder.html" title="Helper class for building and sending events to actors.">EventBuilder</a> for sending chained events to a destination actor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The <span class="tt"><a class="el" href="classqb_1_1_actor_id.html" title="Unique identifier for actors.">ActorId</a></span> of the destination actor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <span class="tt"><a class="el" href="classqb_1_1_actor_1_1_event_builder.html" title="Helper class for building and sending events to actors.">Actor::EventBuilder</a></span> instance associated with the destination actor.</dd></dl>
<p>This provides a fluent interface for sending multiple events to the same actor: </p><div class="fragment"><div class="line"><span class="comment">// ActorId target_id = GetSomeActorId();</span></div>
<div class="line"><span class="comment">// to(target_id)</span></div>
<div class="line"><span class="comment">//   .push&lt;MyEvent1&gt;()</span></div>
<div class="line"><span class="comment">//   .push&lt;MyEvent2&gt;(param1, param2)</span></div>
<div class="line"><span class="comment">//   .push&lt;MyEvent3&gt;(data_ptr);</span></div>
</div><!-- fragment --><p> All events pushed via the builder are sent in an ordered fashion, similar to <span class="tt"><a class="el" href="#a45e94c367d5877e6406bf356c145a529" title="Send a new event in an ordered fashion to a destination actor, returning a reference to it.">push()</a></span>. </p><dl class="section attention"><dt>Attention</dt><dd>Multiple calls to <span class="tt">to(same_id)</span> will yield <span class="tt"><a class="el" href="classqb_1_1_actor_1_1_event_builder.html" title="Helper class for building and sending events to actors.">EventBuilder</a></span> instances that operate on the same underlying communication pipe to that destination. <a class="el" href="classqb_1_1_event.html" title="Base class for all events in the actor system.">Event</a> ordering is maintained per pipe. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classqb_1_1_actor_1_1_event_builder.html" title="Helper class for building and sending events to actors.">Actor::EventBuilder</a> </dd></dl>

</div>
</div>
<a id="a45e94c367d5877e6406bf356c145a529" name="a45e94c367d5877e6406bf356c145a529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e94c367d5877e6406bf356c145a529">&#9670;&#160;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Event, typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Event &amp; qb::Actor::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqb_1_1_actor_id.html">ActorId</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a new event in an ordered fashion to a destination actor, returning a reference to it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Event</td><td>The type of event to create and send (must derive from <span class="tt"><a class="el" href="classqb_1_1_event.html" title="Base class for all events in the actor system.">qb::Event</a></span>). </td></tr>
    <tr><td class="paramname">_Args</td><td>Types of arguments to forward to the <span class="tt">_Event</span> constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The <span class="tt"><a class="el" href="classqb_1_1_actor_id.html" title="Unique identifier for actors.">ActorId</a></span> of the destination actor. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the constructor of <span class="tt">_Event</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mutable reference to the constructed <span class="tt">_Event</span> object before it is sent. This allows modification of the event's members after construction but before sending.</dd></dl>
<p>This is the primary and recommended method for sending events. Events sent using <span class="tt"><a class="el" href="#a45e94c367d5877e6406bf356c145a529" title="Send a new event in an ordered fashion to a destination actor, returning a reference to it.">push()</a></span> to the same destination actor from the same source actor are guaranteed to be received in the order they were pushed. The event is queued and sent by the <span class="tt"><a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a></span> at an appropriate time (usually at the end of the current processing loop). Supports events with non-trivially destructible members (e.g., <span class="tt">std::string</span>, <span class="tt">std::vector</span>). </p><div class="fragment"><div class="line"><span class="comment">// ActorId target_id = GetSomeActorId();</span></div>
<div class="line"><span class="comment">// auto&amp; my_evt = push&lt;MyDataEvent&gt;(target_id, initial_value);</span></div>
<div class="line"><span class="comment">// my_evt.data_field = 42; // Modify event before it&#39;s sent</span></div>
<div class="line"><span class="comment">// my_evt.message = &quot;Hello&quot;;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// push&lt;AnotherEvent&gt;(target_id); // This will be processed by target_id after my_evt</span></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>If the event type has a non-trivial destructor, the framework ensures it is called appropriately. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Do not store the returned reference beyond the current scope, as the event object's lifetime is managed by the framework after it's sent. </dd></dl>

</div>
</div>
<a id="ac739dafd53101a1d03ddd368ea890a8c" name="ac739dafd53101a1d03ddd368ea890a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac739dafd53101a1d03ddd368ea890a8c">&#9670;&#160;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Event, typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qb::Actor::send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqb_1_1_actor_id.html">ActorId</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a new event in an unordered fashion to a destination actor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Event</td><td>The type of event to create and send (must derive from <span class="tt"><a class="el" href="classqb_1_1_event.html" title="Base class for all events in the actor system.">qb::Event</a></span> and be trivially destructible). </td></tr>
    <tr><td class="paramname">_Args</td><td>Types of arguments to forward to the <span class="tt">_Event</span> constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The <span class="tt"><a class="el" href="classqb_1_1_actor_id.html" title="Unique identifier for actors.">ActorId</a></span> of the destination actor. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the constructor of <span class="tt">_Event</span>.</td></tr>
  </table>
  </dd>
</dl>
<p>Events sent using <span class="tt"><a class="el" href="#ac739dafd53101a1d03ddd368ea890a8c" title="Send a new event in an unordered fashion to a destination actor.">send()</a></span> are not guaranteed to be received in the order they were sent, even if sent to the same destination from the same source. This method may offer slightly lower latency for same-core communication in specific scenarios but sacrifices ordering. </p><dl class="section note"><dt>Note</dt><dd>The <span class="tt">_Event</span> type <b>must be trivially destructible</b> (e.g., contain only POD types or <span class="tt"><a class="el" href="classqb_1_1string.html" title="Fixed-size string with optimized storage.">qb::string</a></span>). <span class="tt">std::string</span>, <span class="tt">std::vector</span>, etc., are not permitted. <div class="fragment"><div class="line"><span class="comment">// ActorId critical_service_id = GetSomeActorId();</span></div>
<div class="line"><span class="comment">// // Fire-and-forget status update, order not critical</span></div>
<div class="line"><span class="comment">// send&lt;StatusUpdateEvent&gt;(critical_service_id, current_status);</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Use with caution. Prefer <span class="tt"><a class="el" href="#a45e94c367d5877e6406bf356c145a529" title="Send a new event in an ordered fashion to a destination actor, returning a reference to it.">push()</a></span> for most use cases. Misuse can lead to difficult-to-debug race conditions or logical errors if order matters. </dd></dl>

</div>
</div>
<a id="a20c8319b3fb3fb578cf75f6fc37760c6" name="a20c8319b3fb3fb578cf75f6fc37760c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c8319b3fb3fb578cf75f6fc37760c6">&#9670;&#160;</a></span>build_event()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Event, typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Event qb::Actor::build_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqb_1_1_actor_id.html">qb::ActorId</a> const</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an event locally, intended for immediate self-processing or direct calls. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Event</td><td>The type of event to build (must derive from <span class="tt"><a class="el" href="classqb_1_1_event.html" title="Base class for all events in the actor system.">qb::Event</a></span>). </td></tr>
    <tr><td class="paramname">_Args</td><td>Types of arguments to forward to the <span class="tt">_Event</span> constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The <span class="tt"><a class="el" href="classqb_1_1_actor_id.html" title="Unique identifier for actors.">ActorId</a></span> to be set as the source of this event (usually <span class="tt">this-&gt;<a class="el" href="#a9999e9e7f937bbcf96a20127fe993092" title="Get ActorId.">id()</a></span>). </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the constructor of <span class="tt">_Event</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A locally constructed <span class="tt">_Event</span> object.</dd></dl>
<p>This method creates an event object but does not send it through the actor system's messaging queues. It's typically used to prepare an event that will be passed directly to one of the actor's own <span class="tt"><a class="el" href="#a245a2b7be6e086bf622d2acb78b9bded" title="Handler for KillEvent.">on()</a></span> handlers or to a referenced actor's methods. The <span class="tt">dest</span> field of the event will be set to <span class="tt">this-&gt;<a class="el" href="#a9999e9e7f937bbcf96a20127fe993092" title="Get ActorId.">id()</a></span>. </p><div class="fragment"><div class="line"><span class="comment">// // ... inside an actor method ...</span></div>
<div class="line"><span class="comment">// MyInternalEvent local_evt = build_event&lt;MyInternalEvent&gt;(id(), event_data);</span></div>
<div class="line"><span class="comment">// local_evt.some_flag = true;</span></div>
<div class="line"><span class="comment">// this-&gt;on(local_evt); // Directly call the event handler</span></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The lifetime of the returned event is managed by the caller. This does not involve the actor framework's event queue. </dd></dl>

</div>
</div>
<a id="a04aa20243318124e0412d07a9a362ed6" name="a04aa20243318124e0412d07a9a362ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04aa20243318124e0412d07a9a362ed6">&#9670;&#160;</a></span>is() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qb::Actor::is </td>
          <td>(</td>
          <td class="paramtype">uint32_t const</td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a given ID matches the type ID of <span class="tt">_Type</span>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Type</td><td>The type to check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The type ID (usually from an event or actor) to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if <span class="tt">id</span> is the type ID of <span class="tt">_Type</span>, <span class="tt">false</span> otherwise. </dd></dl>

</div>
</div>
<a id="ad973d73c28479a2c1e504ad092c24ff5" name="ad973d73c28479a2c1e504ad092c24ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad973d73c28479a2c1e504ad092c24ff5">&#9670;&#160;</a></span>is() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qb::Actor::is </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqb_1_1_require_event.html">RequireEvent</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>event</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a <span class="tt"><a class="el" href="structqb_1_1_require_event.html" title="Event used to query actor status.">RequireEvent</a></span> is for a specific actor type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Type</td><td>The actor type to check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The <span class="tt"><a class="el" href="structqb_1_1_require_event.html" title="Event used to query actor status.">RequireEvent</a></span> to inspect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if <span class="tt">event.type</span> matches the type ID of <span class="tt">_Type</span>, <span class="tt">false</span> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structqb_1_1_require_event.html" title="Event used to query actor status.">qb::RequireEvent</a> </dd></dl>

</div>
</div>
<a id="afdd14b09a2e5dfe93f4851f08b7c5591" name="afdd14b09a2e5dfe93f4851f08b7c5591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd14b09a2e5dfe93f4851f08b7c5591">&#9670;&#160;</a></span>require()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... _Actors&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qb::Actor::require </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request discovery of other actors of specified types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Actors</td><td>Variadic template pack of actor types to discover. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the discovery ping was successfully broadcasted for all types.</dd></dl>
<p>For each type in <span class="tt">_Actors</span>, this method broadcasts a <span class="tt"><a class="el" href="structqb_1_1_ping_event.html" title="Event used for actor health checks.">PingEvent</a></span>. Live actors of the specified types will respond with a <span class="tt"><a class="el" href="structqb_1_1_require_event.html" title="Event used to query actor status.">RequireEvent</a></span>, which this actor must be registered to handle (via <span class="tt">registerEvent&lt;<a class="el" href="structqb_1_1_require_event.html" title="Event used to query actor status.">RequireEvent</a>&gt;(*this)</span>). The <span class="tt">on(<a class="el" href="structqb_1_1_require_event.html" title="Event used to query actor status.">RequireEvent</a>&amp;)</span> handler can then use <span class="tt">is&lt;_ActorType&gt;(event)</span> to identify responses. </p><div class="fragment"><div class="line"><span class="comment">// bool onInit() override {</span></div>
<div class="line"><span class="comment">//   registerEvent&lt;qb::RequireEvent&gt;(*this);</span></div>
<div class="line"><span class="comment">//   require&lt;ServiceA, ServiceB&gt;(); // Discover ServiceA and ServiceB instances</span></div>
<div class="line"><span class="comment">//   return true;</span></div>
<div class="line"><span class="comment">// }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// void on(const qb::RequireEvent&amp; event) {</span></div>
<div class="line"><span class="comment">//   if (is&lt;ServiceA&gt;(event) &amp;&amp; event.status == qb::ActorStatus::Alive) {</span></div>
<div class="line"><span class="comment">//     // _service_a_id = event.getSource();</span></div>
<div class="line"><span class="comment">//   } else if (is&lt;ServiceB&gt;(event) &amp;&amp; event.status == qb::ActorStatus::Alive) {</span></div>
<div class="line"><span class="comment">//     // _service_b_id = event.getSource();</span></div>
<div class="line"><span class="comment">//   }</span></div>
<div class="line"><span class="comment">// }</span></div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="structqb_1_1_ping_event.html" title="Event used for actor health checks.">qb::PingEvent</a>, <a class="el" href="structqb_1_1_require_event.html" title="Event used to query actor status.">qb::RequireEvent</a> </dd></dl>

</div>
</div>
<a id="ab229da5c0fdd23b494427e5de43bb394" name="ab229da5c0fdd23b494427e5de43bb394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab229da5c0fdd23b494427e5de43bb394">&#9670;&#160;</a></span>broadcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Event, typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qb::Actor::broadcast </td>
          <td>(</td>
          <td class="paramtype">_Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast an event to all actors on all cores. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Event</td><td>The type of event to broadcast (must derive from <span class="tt"><a class="el" href="classqb_1_1_event.html" title="Base class for all events in the actor system.">qb::Event</a></span>). </td></tr>
    <tr><td class="paramname">_Args</td><td>Types of arguments to forward to the <span class="tt">_Event</span> constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to forward to the constructor of <span class="tt">_Event</span>.</td></tr>
  </table>
  </dd>
</dl>
<p>The event will be sent to every actor currently running in the system across all <span class="tt"><a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a></span>s. The source of the event will be this actor's ID. Use <span class="tt">push&lt;MyEvent&gt;(<a class="el" href="classqb_1_1_broadcast_id.html" title="Specialized ActorId for broadcasting messages to all actors on a core.">qb::BroadcastId(core_id)</a>, ...)</span> to broadcast only to a specific core. </p><div class="fragment"><div class="line"><span class="comment">// broadcast&lt;SystemShutdownNoticeEvent&gt;(&quot;System shutting down in 5 minutes&quot;);</span></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Ensure the event type <span class="tt">_Event</span> is appropriate for system-wide broadcast and that all potential recipient actors are registered to handle it or will ignore it safely. </dd></dl>

</div>
</div>
<a id="aa87d1fc0d9360e73182e2d76c41a3dc7" name="aa87d1fc0d9360e73182e2d76c41a3dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87d1fc0d9360e73182e2d76c41a3dc7">&#9670;&#160;</a></span>reply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qb::Actor::reply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqb_1_1_event.html">Event</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>event</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reply to the source of a received event, reusing the event object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event object that was received. This event will be modified (its <span class="tt">dest</span> and <span class="tt">source</span> will be swapped) and sent back to its original source.</td></tr>
  </table>
  </dd>
</dl>
<p>This is the most efficient way to send a response back to the sender of an event. The original event object is reused, minimizing allocations and copies. The <span class="tt"><a class="el" href="#a245a2b7be6e086bf622d2acb78b9bded" title="Handler for KillEvent.">on()</a></span> handler receiving the event must take it by non-const reference (<span class="tt">MyEvent&amp; event</span>) to allow <span class="tt"><a class="el" href="#aa87d1fc0d9360e73182e2d76c41a3dc7" title="Reply to the source of a received event, reusing the event object.">reply()</a></span> to modify and effectively consume it. </p><div class="fragment"><div class="line"><span class="comment">// void on(MyRequestEvent&amp; request) { // Note: non-const reference</span></div>
<div class="line"><span class="comment">//   request.result_data = process(request.input_data);</span></div>
<div class="line"><span class="comment">//   request.status_code = 200;</span></div>
<div class="line"><span class="comment">//   reply(request); // Sends the modified MyRequestEvent back to its original source</span></div>
<div class="line"><span class="comment">// }</span></div>
</div><!-- fragment --> <dl class="section attention"><dt>Attention</dt><dd>After calling <span class="tt">reply(event)</span>, the <span class="tt">event</span> object in the current handler should be considered consumed and no longer valid for further use or modification. </dd></dl>

</div>
</div>
<a id="a8ce447c4172327bc8807fd90d4551560" name="a8ce447c4172327bc8807fd90d4551560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce447c4172327bc8807fd90d4551560">&#9670;&#160;</a></span>forward()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qb::Actor::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqb_1_1_actor_id.html">ActorId</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classqb_1_1_event.html">Event</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>event</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward a received event to a new destination, reusing the event object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The <span class="tt"><a class="el" href="classqb_1_1_actor_id.html" title="Unique identifier for actors.">ActorId</a></span> of the new destination actor. </td></tr>
    <tr><td class="paramname">event</td><td>The event object that was received. This event will be modified (its <span class="tt">dest</span> will be updated to <span class="tt">dest</span>) and sent. The original <span class="tt">source</span> of the event is preserved.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an efficient way to delegate an event to another actor without creating a new event. The <span class="tt"><a class="el" href="#a245a2b7be6e086bf622d2acb78b9bded" title="Handler for KillEvent.">on()</a></span> handler receiving the event must take it by non-const reference (<span class="tt">MyEvent&amp; event</span>) to allow <span class="tt"><a class="el" href="#a8ce447c4172327bc8807fd90d4551560" title="Forward a received event to a new destination, reusing the event object.">forward()</a></span> to modify and effectively consume it. </p><div class="fragment"><div class="line"><span class="comment">// void on(WorkItemEvent&amp; item) { // Note: non-const reference</span></div>
<div class="line"><span class="comment">//   if (item.type == WorkType::TypeA)</span></div>
<div class="line"><span class="comment">//     forward(_worker_a_id, item); // Forward to Worker A</span></div>
<div class="line"><span class="comment">//   else</span></div>
<div class="line"><span class="comment">//     forward(_worker_b_id, item); // Forward to Worker B</span></div>
<div class="line"><span class="comment">// }</span></div>
</div><!-- fragment --> <dl class="section attention"><dt>Attention</dt><dd>After calling <span class="tt">forward(dest, event)</span>, the <span class="tt">event</span> object in the current handler should be considered consumed and no longer valid for further use or modification. </dd></dl>

</div>
</div>
<a id="a405c602b335d8f75261106367af38321" name="a405c602b335d8f75261106367af38321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405c602b335d8f75261106367af38321">&#9670;&#160;</a></span>getPipe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqb_1_1_pipe.html">Pipe</a> qb::Actor::getPipe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqb_1_1_actor_id.html">ActorId</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get direct access to the underlying communication pipe for a destination actor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The <span class="tt"><a class="el" href="classqb_1_1_actor_id.html" title="Unique identifier for actors.">ActorId</a></span> of the destination actor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <span class="tt"><a class="el" href="classqb_1_1_pipe.html" title="Represents a communication channel between actors.">qb::Pipe</a></span> object representing the unidirectional communication channel to <span class="tt">dest</span>.</dd></dl>
<p>This provides lower-level access to the event sending mechanism. It can be useful for performance-critical scenarios, especially when sending multiple events to the same destination or when needing to pre-allocate buffer space for large events using <span class="tt"><a class="el" href="classqb_1_1_pipe.html#a3254c962813f766dcade4b678f3d41c2" title="Push an event with pre-allocated size to the pipe.">Pipe::allocated_push()</a></span>. </p><div class="fragment"><div class="line"><span class="comment">// ActorId target_id = GetSomeActorId();</span></div>
<div class="line"><span class="comment">// qb::Pipe comm_pipe = getPipe(target_id);</span></div>
<div class="line"><span class="comment">// auto&amp; ev1 = comm_pipe.push&lt;MyEvent1&gt;();</span></div>
<div class="line"><span class="comment">// auto&amp; ev2 = comm_pipe.allocated_push&lt;LargeEvent&gt;(data_size, constructor_args_for_large_event);</span></div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="classqb_1_1_pipe.html" title="Represents a communication channel between actors.">qb::Pipe</a> </dd>
<dd>
<a class="el" href="classqb_1_1_pipe.html#a05f8b308e360f7672ca1d62fca899e1e" title="Push an event to the pipe.">Pipe::push</a> </dd>
<dd>
<a class="el" href="classqb_1_1_pipe.html#a3254c962813f766dcade4b678f3d41c2" title="Push an event with pre-allocated size to the pipe.">Pipe::allocated_push</a> </dd></dl>

</div>
</div>
<a id="a3137f7dedde694d2bc3cdb1a074485f2" name="a3137f7dedde694d2bc3cdb1a074485f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3137f7dedde694d2bc3cdb1a074485f2">&#9670;&#160;</a></span>addRefActor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Actor, typename... _Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Actor * qb::Actor::addRefActor </td>
          <td>(</td>
          <td class="paramtype">_Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and initialize a new referenced actor on the same <a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Actor</td><td>The concrete derived actor type to create (must inherit from <span class="tt"><a class="el" href="classqb_1_1_actor.html" title="Base class for all actors in the qb framework.">qb::Actor</a></span>). </td></tr>
    <tr><td class="paramname">_Args</td><td>Types of arguments to forward to the <span class="tt">_Actor</span>'s constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to forward to the constructor of <span class="tt">_Actor</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A raw pointer to the newly created <span class="tt">_Actor</span> instance if successful (i.e., its <span class="tt"><a class="el" href="#ae61217d6ef37d4658b41cec6d2f6719f" title="Initialization callback, called once after construction and ID assignment.">onInit()</a></span> returned <span class="tt">true</span>), otherwise <span class="tt">nullptr</span>.</dd></dl>
<p>Referenced actors are created on the same <span class="tt"><a class="el" href="classqb_1_1_virtual_core.html" title="Manages a virtual processing core (worker thread) in the actor system.">VirtualCore</a></span> as the calling (parent) actor. The parent receives a raw pointer to the child actor. This allows for direct method calls from the parent to the child, bypassing the event queue for the child. The child actor still has its own <span class="tt"><a class="el" href="classqb_1_1_actor_id.html" title="Unique identifier for actors.">ActorId</a></span> and can receive events normally. </p><dl class="section note"><dt>Note</dt><dd>The parent actor does <b>not</b> own the referenced actor. The referenced actor manages its own lifecycle and must call <span class="tt"><a class="el" href="#ad097f332e8617029cbd8031c1f8fdf84" title="Terminate this actor and mark it for removal from the system.">kill()</a></span> to terminate. The parent must be aware that the pointer can become dangling if the child terminates independently. <div class="fragment"><div class="line"><span class="comment">// // Inside ParentActor</span></div>
<div class="line"><span class="comment">// HelperActor* _helper = addRefActor&lt;HelperActor&gt;(initial_config_for_helper);</span></div>
<div class="line"><span class="comment">// if (_helper) {</span></div>
<div class="line"><span class="comment">//   // Helper created successfully. Can send events:</span></div>
<div class="line"><span class="comment">//   push&lt;TaskEvent&gt;(_helper-&gt;id(), task_data);</span></div>
<div class="line"><span class="comment">//   // Or, cautiously, call public methods (bypasses event queue):</span></div>
<div class="line"><span class="comment">//   // _helper-&gt;doSomethingSynchronously(); </span></div>
<div class="line"><span class="comment">// } else {</span></div>
<div class="line"><span class="comment">//   // LOG_CRIT(&quot;Failed to create HelperActor for ParentActor &quot; &lt;&lt; id());</span></div>
<div class="line"><span class="comment">// }</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Direct method calls on the referenced actor bypass its event queue and mailbox, which can break actor model guarantees if not handled with extreme care. Prefer sending events to the child's ID (<span class="tt">child_actor-&gt;<a class="el" href="#a9999e9e7f937bbcf96a20127fe993092" title="Get ActorId.">id()</a></span>) for most interactions. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>qb</b></li><li class="navelem"><a href="classqb_1_1_actor.html">Actor</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
