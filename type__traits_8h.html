<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <head>
        <meta http-equiv="cache-control" content="max-age=86400"/>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta http-equiv="X-UA-Compatible" content="IE=9"/>
        <meta name="generator" content="Doxygen 1.14.0"/>
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <title>qb: include/qb/utility/type_traits.h File Reference</title>
        <meta name="description" content="qb OpenSource C++17 Actor Framework Documentation, all API detailed">
        <meta name="keywords"
              content="qb, cube, actor, framework, actor framework, opensource, cpp, c++, cpp17, c++17, documentation, docs, git">
        <meta name="author" content="isndev">
        <!-- BEGIN opengraph metadata -->
<!--        <meta property="og:title" content="Doxygen Awesome"/>-->
<!--        <meta property="og:image"-->
<!--              content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>-->
<!--        <meta property="og:description"-->
<!--              content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>-->
<!--        <meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/"/>-->
        <!-- END opengraph metadata -->
        <!-- BEGIN twitter metadata -->
<!--        <meta name="twitter:image:src"-->
<!--              content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>-->
<!--        <meta name="twitter:title" content="Doxygen Awesome"/>-->
<!--        <meta name="twitter:description"-->
<!--              content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>-->
        <!-- END twitter metadata -->
        <title>qb: include/qb/utility/type_traits.h File Reference</title>
        <link href="tabs.css" rel="stylesheet" type="text/css"/>
        <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
        <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
        <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
        <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
        <script type="text/javascript" src="toggle-alternative-theme.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeFragmentCopyButton.init()
            DoxygenAwesomeDarkModeToggle.init()
            DoxygenAwesomeParagraphLink.init()
            DoxygenAwesomeInteractiveToc.init()
            DoxygenAwesomeTabs.init()
        </script>
        <script async defer src="https://buttons.github.io/buttons.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css"/>
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
    </head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/isndev/qb" class="github-corner" title="View source on GitHub"
   target="_blank" rel="noopener noreferrer">
    <svg viewBox="0 0 250 250" width="40" height="40"
         style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
<style>.github-corner:hover .octo-arm {
    animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
    0%, 100% {
        transform: rotate(0)
    }
    20%, 60% {
        transform: rotate(-25deg)
    }
    40%, 80% {
        transform: rotate(10deg)
    }
}
@media (max-width: 500px) {
    .github-corner:hover .octo-arm {
        animation: none
    }
    .github-corner .octo-arm {
        animation: octocat-wave 560ms ease-in-out
    }
}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
            <tr style="height: 56px;">
                <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
                <td id="projectalign" style="padding-left: 0.5em;">
                    <div id="projectname">qb
                        &#160;<span id="projectnumber">2.0.0.0</span>
                    </div>
                    <div id="projectbrief">C++17 Actor Framework</div>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
    <div style="padding-left: 0.5em;">
        <a class="navbar-brand" href="https://github.com/isndev/qb">
            <img src="GitHub-Mark-64px.png" width="32px" alt="qb">
        </a>
        <a class="github-button" href="https://github.com/isndev/qb/issues" data-icon="octicon-issue-opened" data-size="large" data-show-count="true" aria-label="Issue isndev/qb on GitHub">Issue</a>
        <a class="github-button" href="https://github.com/isndev/qb/subscription" data-icon="octicon-eye" data-size="large" data-show-count="true" aria-label="Watch isndev/qb on GitHub">Watch</a>
        <a class="github-button" href="https://github.com/isndev/qb" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star isndev/qb on GitHub">Star</a>
        <a class="github-button" href="https://github.com/isndev/qb/fork" data-icon="octicon-repo-forked" data-size="large" data-show-count="true" aria-label="Fork isndev/qb on GitHub">Fork</a>
        <a class="github-button" href="https://github.com/isndev" data-size="large" data-show-count="false" aria-label="Follow @isndev on GitHub">Follow @isndev</a>
    </div>
    <!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('type__traits_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">type_traits.h File Reference<div class="ingroups"><a class="el" href="group___q_b.html">QB Actor Framework</a> &raquo; <a class="el" href="group___utility.html">General Utilities</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Advanced type traits and metaprogramming utilities for the QB Framework.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;string_view&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;valarray&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for type_traits.h:</div>
<div class="dyncontent">
<div class="center"><img src="type__traits_8h__incl.png" border="0" usemap="#ainclude_2qb_2utility_2type__traits_8h" loading="lazy" alt=""/></div>
<map name="ainclude_2qb_2utility_2type__traits_8h" id="ainclude_2qb_2utility_2type__traits_8h">
<area shape="rect" title="Advanced type traits and metaprogramming utilities for the QB Framework." alt="" coords="146,5,261,46"/>
<area shape="rect" title=" " alt="" coords="5,94,93,120"/>
<area shape="poly" title=" " alt="" coords="166,49,87,89,85,84,164,44"/>
<area shape="rect" title=" " alt="" coords="117,94,200,120"/>
<area shape="poly" title=" " alt="" coords="195,48,175,82,171,79,190,45"/>
<area shape="rect" title=" " alt="" coords="224,94,276,120"/>
<area shape="poly" title=" " alt="" coords="217,45,238,79,233,82,213,48"/>
<area shape="rect" title=" " alt="" coords="301,94,368,120"/>
<area shape="poly" title=" " alt="" coords="238,44,303,83,300,88,235,49"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="type__traits_8h__dep__incl.png" border="0" usemap="#ainclude_2qb_2utility_2type__traits_8hdep" loading="lazy" alt=""/></div>
<map name="ainclude_2qb_2utility_2type__traits_8hdep" id="ainclude_2qb_2utility_2type__traits_8hdep">
<area shape="rect" title="Advanced type traits and metaprogramming utilities for the QB Framework." alt="" coords="718,5,834,46"/>
<area shape="rect" href="core_2_actor_8h.html" title="Actor base class and core actor model implementation." alt="" coords="5,190,160,216"/>
<area shape="poly" title=" " alt="" coords="703,31,572,35,416,46,270,66,212,80,169,96,142,117,119,143,90,191,86,188,115,140,138,113,167,92,210,74,269,60,416,41,572,30,702,25"/>
<area shape="rect" href="core_2_core_set_8h.html" title="Core set management for the QB Actor Framework." alt="" coords="387,102,559,127"/>
<area shape="poly" title=" " alt="" coords="704,50,517,103,515,98,702,45"/>
<area shape="rect" href="io_2async_2io_8h.html" title="Core asynchronous I/O class templates for event&#45;driven operations." alt="" coords="1143,190,1302,216"/>
<area shape="poly" title=" " alt="" coords="840,49,1193,187,1191,192,839,54"/>
<area shape="rect" href="async_2listener_8h.html" title="Core event loop manager for the asynchronous IO framework." alt="" coords="1156,94,1289,135"/>
<area shape="poly" title=" " alt="" coords="849,38,1156,97,1155,103,848,44"/>
<area shape="rect" href="protocol_8h.html" title="Protocol interfaces for message processing in the asynchronous IO framework." alt="" coords="1365,94,1498,135"/>
<area shape="poly" title=" " alt="" coords="849,33,1302,91,1365,100,1364,106,1301,97,848,39"/>
<area shape="rect" href="stream_8h.html" title="Core stream abstraction classes for the QB IO library." alt="" coords="701,102,850,127"/>
<area shape="poly" title=" " alt="" coords="778,62,778,101,773,101,773,62"/>
<area shape="rect" href="router_8h.html" title="Event routing system." alt="" coords="180,94,343,135"/>
<area shape="poly" title=" " alt="" coords="703,42,375,97,344,102,343,97,374,91,702,37"/>
<area shape="rect" href="_actor_8h.html" title="Convenience header for the core QB Actor components." alt="" coords="21,279,144,304"/>
<area shape="poly" title=" " alt="" coords="85,232,85,278,80,278,80,232"/>
<area shape="rect" href="_virtual_core_8h.html" title="Defines the VirtualCore class, representing a worker thread in the QB Actor Framework." alt="" coords="168,279,357,304"/>
<area shape="poly" title=" " alt="" coords="123,221,238,276,236,281,120,225"/>
<area shape="rect" href="cube_8h.html" title="Main include file for the QB Actor Framework." alt="" coords="218,368,323,393"/>
<area shape="poly" title=" " alt="" coords="124,309,245,364,243,369,122,314"/>
<area shape="rect" href="core_2main_8h.html" title="Main control for the QB Actor Framework." alt="" coords="397,190,549,216"/>
<area shape="poly" title=" " alt="" coords="476,143,476,190,470,190,470,143"/>
<area shape="rect" href="_core_set_8h.html" title="Convenience header for the QB CoreSet component." alt="" coords="235,190,373,216"/>
<area shape="poly" title=" " alt="" coords="437,137,329,192,326,187,434,132"/>
<area shape="poly" title=" " alt="" coords="430,225,293,281,291,276,428,220"/>
<area shape="rect" href="main_8h.html" title="Convenience header for the QB Main engine controller." alt="" coords="396,279,519,304"/>
<area shape="poly" title=" " alt="" coords="471,232,462,279,457,278,466,231"/>
<area shape="poly" title=" " alt="" coords="418,314,298,369,296,365,416,309"/>
<area shape="rect" href="async_8h.html" title="Main include file for the QB asynchronous I/O library." alt="" coords="940,449,1084,474"/>
<area shape="poly" title=" " alt="" coords="1213,231,1196,272,1184,310,1177,341,1167,371,1144,402,1126,419,1104,432,1060,451,1058,446,1102,427,1122,415,1141,399,1163,368,1172,340,1179,309,1191,270,1208,229"/>
<area shape="rect" href="async_2file_8h.html" title="Asynchronous file operations for the QB IO library." alt="" coords="632,271,765,312"/>
<area shape="poly" title=" " alt="" coords="1154,222,1132,226,1033,241,955,249,877,258,778,274,766,276,765,271,777,269,876,253,954,244,1032,235,1131,221,1153,217"/>
<area shape="rect" href="acceptor_8h.html" title="Asynchronous TCP connection acceptor implementation." alt="" coords="1205,271,1338,312"/>
<area shape="poly" title=" " alt="" coords="1239,228,1263,270,1259,273,1235,231"/>
<area shape="rect" href="tcp_2client_8h.html" title="Asynchronous TCP client implementation for the QB IO library." alt="" coords="997,360,1130,401"/>
<area shape="poly" title=" " alt="" coords="1199,228,1151,273,1111,320,1080,361,1076,358,1107,316,1147,269,1195,224"/>
<area shape="rect" href="udp_2client_8h.html" title="Asynchronous UDP client implementation." alt="" coords="946,271,1080,312"/>
<area shape="poly" title=" " alt="" coords="1180,225,1062,273,1060,268,1178,220"/>
<area shape="rect" href="udp_2server_8h.html" title="Asynchronous UDP server implementation." alt="" coords="789,271,922,312"/>
<area shape="poly" title=" " alt="" coords="1156,222,935,274,923,277,922,272,934,269,1154,217"/>
<area shape="poly" title=" " alt="" coords="750,317,990,446,988,450,747,322"/>
<area shape="rect" href="tcp_2server_8h.html" title="Asynchronous TCP server implementation for the QB IO library." alt="" coords="1205,360,1338,401"/>
<area shape="poly" title=" " alt="" coords="1274,328,1274,360,1269,360,1269,328"/>
<area shape="poly" title=" " alt="" coords="1193,408,1053,451,1051,445,1191,403"/>
<area shape="poly" title=" " alt="" coords="1045,415,1022,450,1018,447,1040,412"/>
<area shape="poly" title=" " alt="" coords="999,327,988,361,985,380,988,400,996,426,1007,447,1002,450,991,428,983,401,980,380,983,359,994,325"/>
<area shape="poly" title=" " alt="" coords="886,322,1003,446,999,450,882,325"/>
<area shape="poly" title=" " alt="" coords="1225,150,1225,190,1220,190,1220,150"/>
<area shape="rect" href="connector_8h.html" title="Asynchronous TCP connection establishment utilities." alt="" coords="1362,360,1496,401"/>
<area shape="poly" title=" " alt="" coords="1270,142,1315,181,1351,227,1382,277,1423,358,1418,361,1378,280,1347,231,1311,185,1266,146"/>
<area shape="poly" title=" " alt="" coords="1348,404,1085,451,1084,446,1347,399"/>
<area shape="poly" title=" " alt="" coords="1371,143,1253,192,1251,187,1369,138"/>
<area shape="rect" href="protocol_2base_8h.html" title="Base protocol implementations for message framing in the QB IO system." alt="" coords="1413,183,1557,223"/>
<area shape="poly" title=" " alt="" coords="1454,147,1475,181,1471,184,1450,149"/>
<area shape="rect" href="protocol_2handshake_8h.html" title="Protocol for handling the handshake of a new connection." alt="" coords="1581,183,1725,223"/>
<area shape="poly" title=" " alt="" coords="1497,138,1604,180,1602,185,1495,143"/>
<area shape="rect" href="io_2protocol_2json_8h.html" title="JSON protocol implementations for the QB IO system." alt="" coords="1581,271,1725,312"/>
<area shape="poly" title=" " alt="" coords="1538,228,1616,269,1614,273,1536,233"/>
<area shape="rect" href="text_8h.html" title="Protocols for processing text and binary messages in the QB IO system." alt="" coords="1413,271,1557,312"/>
<area shape="poly" title=" " alt="" coords="1488,239,1488,271,1482,271,1482,239"/>
<area shape="rect" href="json_8h.html" title="JSON utility functions and types for the qb framework." alt="" coords="1594,368,1713,393"/>
<area shape="poly" title=" " alt="" coords="1656,328,1656,367,1650,367,1650,328"/>
<area shape="rect" href="transport_2file_8h.html" title="File transport implementation for the QB IO library." alt="" coords="624,183,773,223"/>
<area shape="poly" title=" " alt="" coords="757,141,718,184,714,181,753,137"/>
<area shape="rect" href="stcp_8h.html" title="Secure TCP (SSL/TLS) stream transport for the QB IO library." alt="" coords="970,183,1120,223"/>
<area shape="poly" title=" " alt="" coords="829,130,985,180,983,185,827,135"/>
<area shape="rect" href="tcp_8h.html" title="TCP stream transport implementation for the QB IO library." alt="" coords="552,360,701,401"/>
<area shape="poly" title=" " alt="" coords="687,134,646,154,628,167,614,184,603,205,598,229,598,277,608,323,620,359,615,361,603,325,593,278,592,228,598,204,610,181,625,163,643,149,685,129"/>
<area shape="rect" href="udp_8h.html" title="UDP datagram transport implementation for the QB IO library." alt="" coords="797,183,946,223"/>
<area shape="poly" title=" " alt="" coords="802,136,852,180,848,184,799,140"/>
<area shape="poly" title=" " alt="" coords="701,239,701,271,696,271,696,239"/>
<area shape="poly" title=" " alt="" coords="717,397,953,445,952,451,716,403"/>
<area shape="poly" title=" " alt="" coords="918,229,983,269,980,273,915,234"/>
<area shape="poly" title=" " alt="" coords="868,239,862,271,857,270,863,238"/>
<area shape="poly" title=" " alt="" coords="241,149,225,183,222,203,225,223,238,253,255,277,250,280,234,255,220,224,216,203,220,182,236,147"/>
</map>
</div>
</div>
<p><a href="type__traits_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:qb_3A_3Acrtp_3C_20T_20_3E" id="r_qb_3A_3Acrtp_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1crtp.html">qb::crtp&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for implementing the Curiously Recurring Template Pattern (CRTP).  <a href="structqb_1_1crtp.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Adetail_3A_3Ahas_5Fconst_5Fiterator_3C_20T_20_3E" id="r_qb_3A_3Adetail_3A_3Ahas_5Fconst_5Fiterator_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1detail_1_1has__const__iterator.html">qb::detail::has_const_iterator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect whether T has a const_iterator type.  <a href="structqb_1_1detail_1_1has__const__iterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Adetail_3A_3Ahas_5Fbegin_5Fend_3C_20T_20_3E" id="r_qb_3A_3Adetail_3A_3Ahas_5Fbegin_5Fend_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1detail_1_1has__begin__end.html">qb::detail::has_begin_end&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect whether T has begin() and end() methods.  <a href="structqb_1_1detail_1_1has__begin__end.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Adetail_3A_3Ais_5Fmappish_5Fimpl_3C_20T_2C_20U_20_3E" id="r_qb_3A_3Adetail_3A_3Ais_5Fmappish_5Fimpl_3C_20T_2C_20U_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1detail_1_1is__mappish__impl.html">qb::detail::is_mappish_impl&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementation to detect map-like types.  <a href="structqb_1_1detail_1_1is__mappish__impl.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Adetail_3A_3Ais_5Fmappish_5Fimpl_3C_20T_2C_20std_3A_3Avoid_5Ft_3C_20typename_20T_3A_3Akey_5Ftype_2C_20typename_20T_3A_3Amapped_5Ftype_2C_20decltype_28std_3A_3Adeclval_3C_20T_20_26_20_3E_28_29_5Bstd_3A_3Adeclval_3C_20const_20typename_20T_3A_3Akey_5Ftype_20_26_20_3E_28_29_5D_29_3E_20_3E" id="r_qb_3A_3Adetail_3A_3Ais_5Fmappish_5Fimpl_3C_20T_2C_20std_3A_3Avoid_5Ft_3C_20typename_20T_3A_3Akey_5Ftype_2C_20typename_20T_3A_3Amapped_5Ftype_2C_20decltype_28std_3A_3Adeclval_3C_20T_20_26_20_3E_28_29_5Bstd_3A_3Adeclval_3C_20const_20typename_20T_3A_3Akey_5Ftype_20_26_20_3E_28_29_5D_29_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1detail_1_1is__mappish__impl_3_01_t_00_01std_1_1void__t_3_01typename_01_t_1_1key__typ5b328a8e577f5777aa2ae8c06936c2ed.html">qb::detail::is_mappish_impl&lt; T, std::void_t&lt; typename T::key_type, typename T::mapped_type, decltype(std::declval&lt; T &amp; &gt;()[std::declval&lt; const typename T::key_type &amp; &gt;()])&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for types that have key_type, mapped_type, and operator[].  <a href="structqb_1_1detail_1_1is__mappish__impl_3_01_t_00_01std_1_1void__t_3_01typename_01_t_1_1key__typ5b328a8e577f5777aa2ae8c06936c2ed.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Fcontainer_3C_20T_20_3E" id="r_qb_3A_3Ais_5Fcontainer_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__container.html">qb::is_container&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type <span class="tt">T</span> is a container.  <a href="structqb_1_1is__container.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Fcontainer_3C_20T_5BN_5D_3E" id="r_qb_3A_3Ais_5Fcontainer_3C_20T_5BN_5D_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__container_3_01_t_0f_n_0e_4.html">qb::is_container&lt; T[N]&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for array types, which are containers.  <a href="structqb_1_1is__container_3_01_t_0f_n_0e_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Fcontainer_3C_20char_5BN_5D_3E" id="r_qb_3A_3Ais_5Fcontainer_3C_20char_5BN_5D_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__container_3_01char_0f_n_0e_4.html">qb::is_container&lt; char[N]&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for character arrays, which are not considered containers.  <a href="structqb_1_1is__container_3_01char_0f_n_0e_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Fcontainer_3C_20std_3A_3Avalarray_3C_20T_20_3E_20_3E" id="r_qb_3A_3Ais_5Fcontainer_3C_20std_3A_3Avalarray_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__container_3_01std_1_1valarray_3_01_t_01_4_01_4.html">qb::is_container&lt; std::valarray&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for std::valarray, which is a container.  <a href="structqb_1_1is__container_3_01std_1_1valarray_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Fcontainer_3C_20std_3A_3Apair_3C_20T1_2C_20T2_20_3E_20_3E" id="r_qb_3A_3Ais_5Fcontainer_3C_20std_3A_3Apair_3C_20T1_2C_20T2_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__container_3_01std_1_1pair_3_01_t1_00_01_t2_01_4_01_4.html">qb::is_container&lt; std::pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for std::pair, which is a container.  <a href="structqb_1_1is__container_3_01std_1_1pair_3_01_t1_00_01_t2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Fcontainer_3C_20std_3A_3Atuple_3C_20Args_2E_2E_2E_20_3E_20_3E" id="r_qb_3A_3Ais_5Fcontainer_3C_20std_3A_3Atuple_3C_20Args_2E_2E_2E_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__container_3_01std_1_1tuple_3_01_args_8_8_8_01_4_01_4.html">qb::is_container&lt; std::tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for std::tuple, which is a container.  <a href="structqb_1_1is__container_3_01std_1_1tuple_3_01_args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Aremove_5Freference_5Fif_3C_20T_2C_20cond_20_3E" id="r_qb_3A_3Aremove_5Freference_5Fif_3C_20T_2C_20cond_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1remove__reference__if.html">qb::remove_reference_if&lt; T, cond &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally removes a reference from type <span class="tt">T</span> if <span class="tt">cond</span> is true.  <a href="structqb_1_1remove__reference__if.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Aremove_5Freference_5Fif_3C_20T_2C_20true_20_3E" id="r_qb_3A_3Aremove_5Freference_5Fif_3C_20T_2C_20true_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1remove__reference__if_3_01_t_00_01true_01_4.html">qb::remove_reference_if&lt; T, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization that actually removes the reference.  <a href="structqb_1_1remove__reference__if_3_01_t_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Fmappish_3C_20T_20_3E" id="r_qb_3A_3Ais_5Fmappish_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__mappish.html">qb::is_mappish&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type <span class="tt">T</span> is map-like.  <a href="structqb_1_1is__mappish.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Fpair_3C_2E_2E_2E_20_3E" id="r_qb_3A_3Ais_5Fpair_3C_2E_2E_2E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__pair.html">qb::is_pair&lt;... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type is a <span class="tt">std::pair</span>.  <a href="structqb_1_1is__pair.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Fpair_3C_20std_3A_3Apair_3C_20T_2C_20U_20_3E_20_3E" id="r_qb_3A_3Ais_5Fpair_3C_20std_3A_3Apair_3C_20T_2C_20U_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__pair_3_01std_1_1pair_3_01_t_00_01_u_01_4_01_4.html">qb::is_pair&lt; std::pair&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for std::pair, which returns true.  <a href="structqb_1_1is__pair_3_01std_1_1pair_3_01_t_00_01_u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Finserter_3C_20T_2C_20U_20_3E" id="r_qb_3A_3Ais_5Finserter_3C_20T_2C_20U_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__inserter.html">qb::is_inserter&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type <span class="tt">T</span> is an inserter iterator (e.g., <span class="tt">std::back_inserter</span>).  <a href="structqb_1_1is__inserter.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Finserter_3C_20T_2C_20typename_20std_3A_3Aenable_5Fif_3C_21std_3A_3Ais_5Fvoid_3C_20typename_20T_3A_3Acontainer_5Ftype_20_3E_3A_3Avalue_20_3E_3A_3Atype_20_3E" id="r_qb_3A_3Ais_5Finserter_3C_20T_2C_20typename_20std_3A_3Aenable_5Fif_3C_21std_3A_3Ais_5Fvoid_3C_20typename_20T_3A_3Acontainer_5Ftype_20_3E_3A_3Avalue_20_3E_3A_3Atype_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__inserter_3_01_t_00_01typename_01std_1_1enable__if_3_9std_1_1is__void_3_01typenam1679f36d3842d955a4bbb6863fc3e819.html">qb::is_inserter&lt; T, typename std::enable_if&lt;!std::is_void&lt; typename T::container_type &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for types that have a container_type.  <a href="structqb_1_1is__inserter_3_01_t_00_01typename_01std_1_1enable__if_3_9std_1_1is__void_3_01typenam1679f36d3842d955a4bbb6863fc3e819.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Aiterator_5Ftype_3C_20Iter_2C_20T_20_3E" id="r_qb_3A_3Aiterator_5Ftype_3C_20Iter_2C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1iterator__type.html">qb::iterator_type&lt; Iter, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to extract the <span class="tt">value_type</span> from an iterator <span class="tt">Iter</span>.  <a href="structqb_1_1iterator__type.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Aiterator_5Ftype_3C_20Iter_2C_20typename_20std_3A_3Aenable_5Fif_3C_20is_5Finserter_3C_20Iter_20_3E_3A_3Avalue_20_3E_3A_3Atype_20_3E" id="r_qb_3A_3Aiterator_5Ftype_3C_20Iter_2C_20typename_20std_3A_3Aenable_5Fif_3C_20is_5Finserter_3C_20Iter_20_3E_3A_3Avalue_20_3E_3A_3Atype_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1iterator__type_3_01_iter_00_01typename_01std_1_1enable__if_3_01is__inserter_3_01_ite092c8a534a4f1296358380c3c2f19d8b.html">qb::iterator_type&lt; Iter, typename std::enable_if&lt; is_inserter&lt; Iter &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for inserter iterators.  <a href="structqb_1_1iterator__type_3_01_iter_00_01typename_01std_1_1enable__if_3_01is__inserter_3_01_ite092c8a534a4f1296358380c3c2f19d8b.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Fterator_3C_20Iter_2C_20T_20_3E" id="r_qb_3A_3Ais_5Fterator_3C_20Iter_2C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__terator.html">qb::is_terator&lt; Iter, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type <span class="tt">Iter</span> is an iterator.  <a href="structqb_1_1is__terator.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Fterator_3C_20Iter_2C_20typename_20std_3A_3Aenable_5Fif_3C_20is_5Finserter_3C_20Iter_20_3E_3A_3Avalue_20_3E_3A_3Atype_20_3E" id="r_qb_3A_3Ais_5Fterator_3C_20Iter_2C_20typename_20std_3A_3Aenable_5Fif_3C_20is_5Finserter_3C_20Iter_20_3E_3A_3Avalue_20_3E_3A_3Atype_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__terator_3_01_iter_00_01typename_01std_1_1enable__if_3_01is__inserter_3_01_iter_01_4_1_1value_01_4_1_1type_01_4.html">qb::is_terator&lt; Iter, typename std::enable_if&lt; is_inserter&lt; Iter &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for inserter iterators.  <a href="structqb_1_1is__terator_3_01_iter_00_01typename_01std_1_1enable__if_3_01is__inserter_3_01_iter_01_4_1_1value_01_4_1_1type_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Fterator_3C_20Iter_2C_20typename_20std_3A_3Aenable_5Fif_3C_21std_3A_3Ais_5Fvoid_3C_20typename_20std_3A_3Aiterator_5Ftraits_3C_20Iter_20_3E_3A_3Avalue_5Ftype_20_3E_3A_3Avalue_20_3E_3A_3Atype_20_3E" id="r_qb_3A_3Ais_5Fterator_3C_20Iter_2C_20typename_20std_3A_3Aenable_5Fif_3C_21std_3A_3Ais_5Fvoid_3C_20typename_20std_3A_3Aiterator_5Ftraits_3C_20Iter_20_3E_3A_3Avalue_5Ftype_20_3E_3A_3Avalue_20_3E_3A_3Atype_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__terator_3_01_iter_00_01typename_01std_1_1enable__if_3_9std_1_1is__void_3_01typened62cdd4d712d2cf876fa6cca34d9eda.html">qb::is_terator&lt; Iter, typename std::enable_if&lt;!std::is_void&lt; typename std::iterator_traits&lt; Iter &gt;::value_type &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for standard iterators.  <a href="structqb_1_1is__terator_3_01_iter_00_01typename_01std_1_1enable__if_3_9std_1_1is__void_3_01typened62cdd4d712d2cf876fa6cca34d9eda.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Fmap_5Fiterator_3C_20T_20_3E" id="r_qb_3A_3Ais_5Fmap_5Fiterator_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__map__iterator.html">qb::is_map_iterator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if an iterator <span class="tt">T</span> points to map elements (i.e., <span class="tt">std::pair</span>).  <a href="structqb_1_1is__map__iterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ahas_5Fpush_5Fback_3C_20T_2C_20typename_20_3E" id="r_qb_3A_3Ahas_5Fpush_5Fback_3C_20T_2C_20typename_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1has__push__back.html">qb::has_push_back&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type <span class="tt">T</span> has a <span class="tt">push_back(T::value_type)</span> member function.  <a href="structqb_1_1has__push__back.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ahas_5Fpush_5Fback_3C_20T_2C_20typename_20std_3A_3Aenable_5Fif_3C_20std_3A_3Ais_5Fvoid_3C_20decltype_28std_3A_3Adeclval_3C_20T_20_3E_28_29_2Epush_5Fback_28std_3A_3Adeclval_3C_20typename_20T_3A_3Avalue_5Ftype_20_3E_28_29_29_29_3E_3A_3Avalue_20_3E_3A_3Atype_20_3E" id="r_qb_3A_3Ahas_5Fpush_5Fback_3C_20T_2C_20typename_20std_3A_3Aenable_5Fif_3C_20std_3A_3Ais_5Fvoid_3C_20decltype_28std_3A_3Adeclval_3C_20T_20_3E_28_29_2Epush_5Fback_28std_3A_3Adeclval_3C_20typename_20T_3A_3Avalue_5Ftype_20_3E_28_29_29_29_3E_3A_3Avalue_20_3E_3A_3Atype_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1has__push__back_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__void_3_01dec65ae74cb68f7aa25052303e6551d87cd.html">qb::has_push_back&lt; T, typename std::enable_if&lt; std::is_void&lt; decltype(std::declval&lt; T &gt;().push_back(std::declval&lt; typename T::value_type &gt;()))&gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for types with a valid push_back method.  <a href="structqb_1_1has__push__back_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__void_3_01dec65ae74cb68f7aa25052303e6551d87cd.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ahas_5Finsert_3C_20T_2C_20typename_20_3E" id="r_qb_3A_3Ahas_5Finsert_3C_20T_2C_20typename_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1has__insert.html">qb::has_insert&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type <span class="tt">T</span> has an <span class="tt">insert(T::const_iterator, T::value_type)</span> member function.  <a href="structqb_1_1has__insert.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ahas_5Finsert_3C_20T_2C_20typename_20std_3A_3Aenable_5Fif_3C_20std_3A_3Ais_5Fsame_3C_20decltype_28std_3A_3Adeclval_3C_20T_20_3E_28_29_2Einsert_28std_3A_3Adeclval_3C_20typename_20T_3A_3Aconst_5Fiterator_20_3E_28_29_2C_20std_3A_3Adeclval_3C_20typename_20T_3A_3Avalue_5Ftype_20_3E_28_29_29_29_2C_20typename_20T_3A_3Aiterator_20_3E_3A_3Avalue_20_3E_3A_3Atype_20_3E" id="r_qb_3A_3Ahas_5Finsert_3C_20T_2C_20typename_20std_3A_3Aenable_5Fif_3C_20std_3A_3Ais_5Fsame_3C_20decltype_28std_3A_3Adeclval_3C_20T_20_3E_28_29_2Einsert_28std_3A_3Adeclval_3C_20typename_20T_3A_3Aconst_5Fiterator_20_3E_28_29_2C_20std_3A_3Adeclval_3C_20typename_20T_3A_3Avalue_5Ftype_20_3E_28_29_29_29_2C_20typename_20T_3A_3Aiterator_20_3E_3A_3Avalue_20_3E_3A_3Atype_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1has__insert_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__same_3_01decltypb3518dba9a0e9bb3d486531d9dcc249e.html">qb::has_insert&lt; T, typename std::enable_if&lt; std::is_same&lt; decltype(std::declval&lt; T &gt;().insert(std::declval&lt; typename T::const_iterator &gt;(), std::declval&lt; typename T::value_type &gt;())), typename T::iterator &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for types with a valid insert method.  <a href="structqb_1_1has__insert_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__same_3_01decltypb3518dba9a0e9bb3d486531d9dcc249e.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Fsequence_5Fcontainer_3C_20T_20_3E" id="r_qb_3A_3Ais_5Fsequence_5Fcontainer_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__sequence__container.html">qb::is_sequence_container&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if type <span class="tt">T</span> is a sequence container.  <a href="structqb_1_1is__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Ais_5Fassociative_5Fcontainer_3C_20T_20_3E" id="r_qb_3A_3Ais_5Fassociative_5Fcontainer_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1is__associative__container.html">qb::is_associative_container&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if type <span class="tt">T</span> is an associative container.  <a href="structqb_1_1is__associative__container.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Anth_5Ftype_3C_20num_2C_20T_2C_20Y_2E_2E_2E_20_3E" id="r_qb_3A_3Anth_5Ftype_3C_20num_2C_20T_2C_20Y_2E_2E_2E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1nth__type_3_01num_00_01_t_00_01_y_8_8_8_01_4.html">qb::nth_type&lt; num, T, Y... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive case for <a class="el" href="structqb_1_1nth__type.html" title="Metafunction for selecting the Nth type in a variadic template parameter pack.">nth_type</a> template.  <a href="structqb_1_1nth__type_3_01num_00_01_t_00_01_y_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Anth_5Ftype_3C_200_2C_20T_2C_20Y_2E_2E_2E_20_3E" id="r_qb_3A_3Anth_5Ftype_3C_200_2C_20T_2C_20Y_2E_2E_2E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1nth__type_3_010_00_01_t_00_01_y_8_8_8_01_4.html">qb::nth_type&lt; 0, T, Y... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base case for <a class="el" href="structqb_1_1nth__type.html" title="Metafunction for selecting the Nth type in a variadic template parameter pack.">nth_type</a> template.  <a href="structqb_1_1nth__type_3_010_00_01_t_00_01_y_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Aindexes_5Ftuple_3C_20Indexes_20_3E" id="r_qb_3A_3Aindexes_5Ftuple_3C_20Indexes_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1indexes__tuple.html">qb::indexes_tuple&lt; Indexes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a compile-time tuple of <span class="tt">size_t</span> indexes.  <a href="structqb_1_1indexes__tuple.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Aindex_5Fbuilder_3C_20num_2C_20indexes_5Ftuple_3C_20Indexes_2E_2E_2E_20_3E_20_3E" id="r_qb_3A_3Aindex_5Fbuilder_3C_20num_2C_20indexes_5Ftuple_3C_20Indexes_2E_2E_2E_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1index__builder_3_01num_00_01indexes__tuple_3_01_indexes_8_8_8_01_4_01_4.html">qb::index_builder&lt; num, indexes_tuple&lt; Indexes... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive case for <a class="el" href="structqb_1_1index__builder.html" title="Generates a compile-time sequence of indices as an indexes_tuple.">index_builder</a>.  <a href="structqb_1_1index__builder_3_01num_00_01indexes__tuple_3_01_indexes_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Aindex_5Fbuilder_3C_200_2C_20indexes_5Ftuple_3C_20Indexes_2E_2E_2E_20_3E_20_3E" id="r_qb_3A_3Aindex_5Fbuilder_3C_200_2C_20indexes_5Ftuple_3C_20Indexes_2E_2E_2E_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1index__builder_3_010_00_01indexes__tuple_3_01_indexes_8_8_8_01_4_01_4.html">qb::index_builder&lt; 0, indexes_tuple&lt; Indexes... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base case for <a class="el" href="structqb_1_1index__builder.html" title="Generates a compile-time sequence of indices as an indexes_tuple.">index_builder</a>.  <a href="structqb_1_1index__builder_3_010_00_01indexes__tuple_3_01_indexes_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:qb_3A_3Aexpand" id="r_qb_3A_3Aexpand"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqb_1_1expand.html">qb::expand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for forcing parameter pack expansion in certain contexts.  <a href="structqb_1_1expand.html#details">More...</a><br /></td></tr>
<tr class="memitem:ambiguate_3C_20Args_20_3E" id="r_ambiguate_3C_20Args_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structambiguate.html">ambiguate&lt; Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to force ambiguity of class members.  <a href="structambiguate.html#details">More...</a><br /></td></tr>
<tr class="memitem:got_5Ftype_3C_20A_2C_20typename_20_3E" id="r_got_5Ftype_3C_20A_2C_20typename_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgot__type.html">got_type&lt; A, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type exists.  <a href="structgot__type.html#details">More...</a><br /></td></tr>
<tr class="memitem:got_5Ftype_3C_20A_20_3E" id="r_got_5Ftype_3C_20A_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgot__type_3_01_a_01_4.html">got_type&lt; A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization that indicates the type exists.  <a href="structgot__type_3_01_a_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:sig_5Fcheck_3C_20T_2C_20T_20_3E" id="r_sig_5Fcheck_3C_20T_2C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig__check.html">sig_check&lt; T, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for signature checking.  <a href="structsig__check.html#details">More...</a><br /></td></tr>
<tr class="memitem:has_5Fmember_3C_20Alias_2C_20AmbiguitySeed_20_3E" id="r_has_5Fmember_3C_20Alias_2C_20AmbiguitySeed_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhas__member.html">has_member&lt; Alias, AmbiguitySeed &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type has a specific member.  <a href="structhas__member.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab4fc7d2cccbb97d55e21010335cb36e2" id="r_ab4fc7d2cccbb97d55e21010335cb36e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4fc7d2cccbb97d55e21010335cb36e2">CREATE_MEMBER_CHECK</a>(member)</td></tr>
<tr class="memdesc:ab4fc7d2cccbb97d55e21010335cb36e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to create a type trait to check for any member with a given name.  <br /></td></tr>
<tr class="memitem:a56f86bde0015cb7e6b6286e7b1b0903b" id="r_a56f86bde0015cb7e6b6286e7b1b0903b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56f86bde0015cb7e6b6286e7b1b0903b">CREATE_MEMBER_VAR_CHECK</a>(var_name)</td></tr>
<tr class="memdesc:a56f86bde0015cb7e6b6286e7b1b0903b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to create a type trait to check for a member variable with given name.  <br /></td></tr>
<tr class="memitem:a16cdd91dc487d176cf811f996fa3722d" id="r_a16cdd91dc487d176cf811f996fa3722d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16cdd91dc487d176cf811f996fa3722d">CREATE_MEMBER_CLASS_CHECK</a>(class_name)</td></tr>
<tr class="memdesc:a16cdd91dc487d176cf811f996fa3722d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to create a type trait to check for a member class with given name.  <br /></td></tr>
<tr class="memitem:a513fd467788ea74f2404b2e4085948fa" id="r_a513fd467788ea74f2404b2e4085948fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a513fd467788ea74f2404b2e4085948fa">CREATE_MEMBER_UNION_CHECK</a>(union_name)</td></tr>
<tr class="memdesc:a513fd467788ea74f2404b2e4085948fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to create a type trait to check for a member union with given name.  <br /></td></tr>
<tr class="memitem:a9e169c8ad19c2f1d358135046e1002ed" id="r_a9e169c8ad19c2f1d358135046e1002ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e169c8ad19c2f1d358135046e1002ed">CREATE_MEMBER_ENUM_CHECK</a>(enum_name)</td></tr>
<tr class="memdesc:a9e169c8ad19c2f1d358135046e1002ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to create a type trait to check for a member enum with given name.  <br /></td></tr>
<tr class="memitem:a3113b321d1d28c1a0daaaa701a53cee8" id="r_a3113b321d1d28c1a0daaaa701a53cee8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3113b321d1d28c1a0daaaa701a53cee8">CREATE_MEMBER_FUNC_CHECK</a>(func)</td></tr>
<tr class="memdesc:a3113b321d1d28c1a0daaaa701a53cee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to create a type trait to check for a member function with given name.  <br /></td></tr>
<tr class="memitem:af1871583f7c686a7767a379ff5da00ff" id="r_af1871583f7c686a7767a379ff5da00ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1871583f7c686a7767a379ff5da00ff">CREATE_MEMBER_CHECKS</a>(member)</td></tr>
<tr class="memdesc:af1871583f7c686a7767a379ff5da00ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to create all member check variants for a single member name.  <br /></td></tr>
<tr class="memitem:ab592189d6429a3a390de9754ba71da8a" id="r_ab592189d6429a3a390de9754ba71da8a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab592189d6429a3a390de9754ba71da8a">GENERATE_HAS_METHOD</a>(method)</td></tr>
<tr class="memdesc:ab592189d6429a3a390de9754ba71da8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to generate a type trait to check for a method with a specific signature.  <br /></td></tr>
<tr class="memitem:abe5b5a9d3e17b980b405dce5c0a3dc13" id="r_abe5b5a9d3e17b980b405dce5c0a3dc13"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe5b5a9d3e17b980b405dce5c0a3dc13">GENERATE_HAS_MEMBER</a>(member)</td></tr>
<tr class="memdesc:abe5b5a9d3e17b980b405dce5c0a3dc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to generate a type trait to check for a member of any kind.  <br /></td></tr>
<tr class="memitem:ab45f03109ecaf5b4c7814df7ed0dd88a" id="r_ab45f03109ecaf5b4c7814df7ed0dd88a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab45f03109ecaf5b4c7814df7ed0dd88a">GENERATE_HAS_MEMBER_TYPE</a>(Type)</td></tr>
<tr class="memdesc:ab45f03109ecaf5b4c7814df7ed0dd88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to generate a type trait to check for a member type.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga21a53aa99af48a14844c5ecb3295b699" id="r_ga21a53aa99af48a14844c5ecb3295b699"><td class="memTemplParams" colspan="2">template&lt;typename...&gt; </td></tr>
<tr class="memitem:ga21a53aa99af48a14844c5ecb3295b699 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_traits.html#ga21a53aa99af48a14844c5ecb3295b699">qb::Void</a> = void</td></tr>
<tr class="memdesc:ga21a53aa99af48a14844c5ecb3295b699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias to <span class="tt">void</span> for SFINAE purposes.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5da9cd39aa4fc3c980fce22794c2b592" id="r_ga5da9cd39aa4fc3c980fce22794c2b592"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga5da9cd39aa4fc3c980fce22794c2b592 template"><td class="memItemLeft" align="right" valign="top">std::remove_reference_t&lt; T &gt; &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___misc_utils.html#ga5da9cd39aa4fc3c980fce22794c2b592">mv</a> (T &amp;&amp;t) noexcept</td></tr>
<tr class="memdesc:ga5da9cd39aa4fc3c980fce22794c2b592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <span class="tt">std::move</span> with a concise syntax.  <br /></td></tr>
<tr class="memitem:ga31f0d9b5be85aa160e2e8c4fbeffd986" id="r_ga31f0d9b5be85aa160e2e8c4fbeffd986"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga31f0d9b5be85aa160e2e8c4fbeffd986 template"><td class="memItemLeft" align="right" valign="top">T &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___misc_utils.html#ga31f0d9b5be85aa160e2e8c4fbeffd986">fwd</a> (std::remove_reference_t&lt; T &gt; &amp;t) noexcept</td></tr>
<tr class="memdesc:ga31f0d9b5be85aa160e2e8c4fbeffd986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <span class="tt">std::forward</span> with a concise syntax (lvalue overload).  <br /></td></tr>
<tr class="memitem:ga00bc0ecf96c98acbc5f47240c8f77dd7" id="r_ga00bc0ecf96c98acbc5f47240c8f77dd7"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga00bc0ecf96c98acbc5f47240c8f77dd7 template"><td class="memItemLeft" align="right" valign="top">T &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___misc_utils.html#ga00bc0ecf96c98acbc5f47240c8f77dd7">fwd</a> (std::remove_reference_t&lt; T &gt; &amp;&amp;t) noexcept</td></tr>
<tr class="memdesc:ga00bc0ecf96c98acbc5f47240c8f77dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <span class="tt">std::forward</span> with a concise syntax (rvalue overload).  <br /></td></tr>
<tr class="memitem:a8fab0adb641af6a2bcbbff8bfaa338b5" id="r_a8fab0adb641af6a2bcbbff8bfaa338b5"><td class="memItemLeft" align="right" valign="top"><a id="a8fab0adb641af6a2bcbbff8bfaa338b5" name="a8fab0adb641af6a2bcbbff8bfaa338b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CREATE_MEMBER_CHECKS</b> (is_alive)</td></tr>
<tr class="memitem:a03f0cb4183f763612c52869db8e1dae5" id="r_a03f0cb4183f763612c52869db8e1dae5"><td class="memItemLeft" align="right" valign="top"><a id="a03f0cb4183f763612c52869db8e1dae5" name="a03f0cb4183f763612c52869db8e1dae5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CREATE_MEMBER_CHECKS</b> (is_broadcast)</td></tr>
<tr class="memitem:afd69a8474f405e51d35c425987978bbc" id="r_afd69a8474f405e51d35c425987978bbc"><td class="memItemLeft" align="right" valign="top"><a id="afd69a8474f405e51d35c425987978bbc" name="afd69a8474f405e51d35c425987978bbc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CREATE_MEMBER_CHECKS</b> (is_valid)</td></tr>
<tr class="memitem:a0da4171a0c95b56c7e3477f18cf5205a" id="r_a0da4171a0c95b56c7e3477f18cf5205a"><td class="memItemLeft" align="right" valign="top"><a id="a0da4171a0c95b56c7e3477f18cf5205a" name="a0da4171a0c95b56c7e3477f18cf5205a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CREATE_MEMBER_CHECKS</b> (disconnect)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Advanced type traits and metaprogramming utilities for the QB Framework. </p>
<p>This file extends the standard library's <span class="tt">&lt;type_traits&gt;</span> with additional type traits and metaprogramming utilities. These are used for compile-time introspection and template metaprogramming, enabling features such as:</p><ul>
<li>Detection of container properties (e.g., <span class="tt">is_container</span>, <span class="tt">is_sequence_container</span>).</li>
<li>Iterator category detection and value type extraction (<span class="tt">is_map_iterator</span>, <span class="tt">iterator_type</span>).</li>
<li>CRTP (Curiously Recurring Template Pattern) base helper (<span class="tt"><a class="el" href="structqb_1_1crtp.html" title="Base class for implementing the Curiously Recurring Template Pattern (CRTP).">qb::crtp</a></span>).</li>
<li>SFINAE utilities for detecting member types and functions (e.g., <span class="tt">has_push_back</span>, macros like <span class="tt">CREATE_MEMBER_CHECK</span>).</li>
<li>Helper aliases for <span class="tt">std::move</span> and <span class="tt">std::forward</span> (<span class="tt">qb::mv</span>, <span class="tt">qb::fwd</span>).</li>
<li>Utilities for variadic template expansion (<span class="tt"><a class="el" href="structqb_1_1indexes__tuple.html" title="Represents a compile-time tuple of size_t indexes.">qb::indexes_tuple</a></span>, <span class="tt"><a class="el" href="structqb_1_1expand.html" title="Utility for forcing parameter pack expansion in certain contexts.">qb::expand</a></span>).</li>
</ul>
<p>These utilities are primarily for internal framework use but can also be leveraged by application code for advanced template programming. </p>
</div><a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ab4fc7d2cccbb97d55e21010335cb36e2" name="ab4fc7d2cccbb97d55e21010335cb36e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fc7d2cccbb97d55e21010335cb36e2">&#9670;&#160;</a></span>CREATE_MEMBER_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CREATE_MEMBER_CHECK</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>member</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                                                                  \</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = std::true_type&gt;                              \</div>
<div class="line">    <span class="keyword">struct </span>Alias_##member;                                                        \</div>
<div class="line">                                                                                  \</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                                         \</div>
<div class="line">    <span class="keyword">struct </span>Alias_##member&lt;                                                        \</div>
<div class="line">        T, std::integral_constant&lt;bool, got_type&lt;decltype(&amp;T::member)&gt;::value&gt;&gt; { \</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">decltype</span>(&amp;T::member) value;                                  \</div>
<div class="line">    };                                                                            \</div>
<div class="line">                                                                                  \</div>
<div class="line">    <span class="keyword">struct </span>AmbiguitySeed_##member {                                               \</div>
<div class="line">        <span class="keywordtype">char</span> member;                                                              \</div>
<div class="line">    };                                                                            \</div>
<div class="line">                                                                                  \</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                                         \</div>
<div class="line">    <span class="keyword">struct </span>has_member_##member {                                                  \</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value =                                                 \</div>
<div class="line">            has_member&lt;Alias_##member&lt;ambiguate&lt;T, AmbiguitySeed_##member&gt;&gt;,      \</div>
<div class="line">                       Alias_##member&lt;AmbiguitySeed_##member&gt;&gt;::value;            \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Macro to create a type trait to check for any member with a given name. </p>
<p>Creates has_member_[member] trait that can detect variables, functions, classes, unions, or enums.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>Name of the member to check for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56f86bde0015cb7e6b6286e7b1b0903b" name="a56f86bde0015cb7e6b6286e7b1b0903b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f86bde0015cb7e6b6286e7b1b0903b">&#9670;&#160;</a></span>CREATE_MEMBER_VAR_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CREATE_MEMBER_VAR_CHECK</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>var_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                                                                       \</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = std::true_type&gt;                                   \</div>
<div class="line">    <span class="keyword">struct </span>has_member_var_##var_name : std::false_type {};                             \</div>
<div class="line">                                                                                       \</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                                              \</div>
<div class="line">    <span class="keyword">struct </span>has_member_var_##var_name&lt;                                                  \</div>
<div class="line">        T, std::integral_constant&lt;                                                     \</div>
<div class="line">               bool, !std::is_member_function_pointer&lt;decltype(&amp;T::var_name)&gt;::value&gt;&gt; \</div>
<div class="line">        : std::true_type {}</div>
</div><!-- fragment -->
<p>Macro to create a type trait to check for a member variable with given name. </p>
<p>Creates has_member_var_[var_name] trait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var_name</td><td>Name of the variable to check for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16cdd91dc487d176cf811f996fa3722d" name="a16cdd91dc487d176cf811f996fa3722d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16cdd91dc487d176cf811f996fa3722d">&#9670;&#160;</a></span>CREATE_MEMBER_CLASS_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CREATE_MEMBER_CLASS_CHECK</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>class_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                                                                    \</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = std::true_type&gt;                                \</div>
<div class="line">    <span class="keyword">struct </span>has_member_class_##class_name : std::false_type {};                      \</div>
<div class="line">                                                                                    \</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                                           \</div>
<div class="line">    <span class="keyword">struct </span>has_member_class_##class_name&lt;                                           \</div>
<div class="line">        T, std::integral_constant&lt;bool, std::is_class&lt;typename got_type&lt;            \</div>
<div class="line">                                            typename T::class_name&gt;::type&gt;::value&gt;&gt; \</div>
<div class="line">        : std::true_type {}</div>
</div><!-- fragment -->
<p>Macro to create a type trait to check for a member class with given name. </p>
<p>Creates has_member_class_[class_name] trait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_name</td><td>Name of the class to check for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a513fd467788ea74f2404b2e4085948fa" name="a513fd467788ea74f2404b2e4085948fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513fd467788ea74f2404b2e4085948fa">&#9670;&#160;</a></span>CREATE_MEMBER_UNION_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CREATE_MEMBER_UNION_CHECK</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>union_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                                                                    \</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = std::true_type&gt;                                \</div>
<div class="line">    <span class="keyword">struct </span>has_member_union_##union_name : std::false_type {};                      \</div>
<div class="line">                                                                                    \</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                                           \</div>
<div class="line">    <span class="keyword">struct </span>has_member_union_##union_name&lt;                                           \</div>
<div class="line">        T, std::integral_constant&lt;bool, std::is_union&lt;typename got_type&lt;            \</div>
<div class="line">                                            typename T::union_name&gt;::type&gt;::value&gt;&gt; \</div>
<div class="line">        : std::true_type {}</div>
</div><!-- fragment -->
<p>Macro to create a type trait to check for a member union with given name. </p>
<p>Creates has_member_union_[union_name] trait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">union_name</td><td>Name of the union to check for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e169c8ad19c2f1d358135046e1002ed" name="a9e169c8ad19c2f1d358135046e1002ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e169c8ad19c2f1d358135046e1002ed">&#9670;&#160;</a></span>CREATE_MEMBER_ENUM_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CREATE_MEMBER_ENUM_CHECK</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>enum_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                                                                        \</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = std::true_type&gt;                                    \</div>
<div class="line">    <span class="keyword">struct </span>has_member_enum_##enum_name : std::false_type {};                            \</div>
<div class="line">                                                                                        \</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                                               \</div>
<div class="line">    <span class="keyword">struct </span>has_member_enum_##enum_name&lt;                                                 \</div>
<div class="line">        T,                                                                              \</div>
<div class="line">        std::integral_constant&lt;                                                         \</div>
<div class="line">            bool, std::is_enum&lt;typename got_type&lt;typename T::enum_name&gt;::type&gt;::value&gt;&gt; \</div>
<div class="line">        : std::true_type {}</div>
</div><!-- fragment -->
<p>Macro to create a type trait to check for a member enum with given name. </p>
<p>Creates has_member_enum_[enum_name] trait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enum_name</td><td>Name of the enum to check for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3113b321d1d28c1a0daaaa701a53cee8" name="a3113b321d1d28c1a0daaaa701a53cee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3113b321d1d28c1a0daaaa701a53cee8">&#9670;&#160;</a></span>CREATE_MEMBER_FUNC_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CREATE_MEMBER_FUNC_CHECK</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                                               \</div>
<div class="line">    <span class="keyword">struct </span>has_member_func_##func {                                                     \</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value =                                                       \</div>
<div class="line">            has_member_##func&lt;T&gt;::value &amp;&amp; !has_member_var_##func&lt;T&gt;::value &amp;&amp;          \</div>
<div class="line">            !has_member_class_##func&lt;T&gt;::value &amp;&amp; !has_member_union_##func&lt;T&gt;::value &amp;&amp; \</div>
<div class="line">            !has_member_enum_##func&lt;T&gt;::value;                                          \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Macro to create a type trait to check for a member function with given name. </p>
<p>Creates has_member_func_[func] trait that identifies functions specifically (not variables, classes, unions, or enums).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Name of the function to check for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1871583f7c686a7767a379ff5da00ff" name="af1871583f7c686a7767a379ff5da00ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1871583f7c686a7767a379ff5da00ff">&#9670;&#160;</a></span>CREATE_MEMBER_CHECKS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CREATE_MEMBER_CHECKS</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>member</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="#ab4fc7d2cccbb97d55e21010335cb36e2">CREATE_MEMBER_CHECK</a>(member);       \</div>
<div class="line">    CREATE_MEMBER_VAR_CHECK(member);   \</div>
<div class="line">    CREATE_MEMBER_CLASS_CHECK(member); \</div>
<div class="line">    CREATE_MEMBER_UNION_CHECK(member); \</div>
<div class="line">    CREATE_MEMBER_ENUM_CHECK(member);  \</div>
<div class="line">    CREATE_MEMBER_FUNC_CHECK(member)</div>
<div class="ttc" id="atype__traits_8h_html_ab4fc7d2cccbb97d55e21010335cb36e2"><div class="ttname"><a href="#ab4fc7d2cccbb97d55e21010335cb36e2">CREATE_MEMBER_CHECK</a></div><div class="ttdeci">#define CREATE_MEMBER_CHECK(member)</div><div class="ttdoc">Macro to create a type trait to check for any member with a given name.</div><div class="ttdef"><b>Definition</b> type_traits.h:669</div></div>
</div><!-- fragment -->
<p>Macro to create all member check variants for a single member name. </p>
<p>Creates checks for any member type, variables, classes, unions, enums, and functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>Name of the member to check for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab592189d6429a3a390de9754ba71da8a" name="ab592189d6429a3a390de9754ba71da8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab592189d6429a3a390de9754ba71da8a">&#9670;&#160;</a></span>GENERATE_HAS_METHOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GENERATE_HAS_METHOD</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>method</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                                                                     \</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;                            \</div>
<div class="line">    <span class="keyword">class </span>has_method_##method {                                                      \</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                                        \</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> check(T *) -&gt; <span class="keyword">typename</span> std::is_same&lt;                   \</div>
<div class="line">            decltype(std::declval&lt;T&gt;().method(std::declval&lt;Args&gt;()...)), Ret&gt;::type; \</div>
<div class="line">                                                                                     \</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;                                                          \</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> std::false_type check(...);                                 \</div>
<div class="line">                                                                                     \</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">decltype</span>(check&lt;C&gt;(0)) type;                                          \</div>
<div class="line">                                                                                     \</div>
<div class="line">    <span class="keyword">public</span>:                                                                          \</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> value = type::value;                                   \</div>
<div class="line">    };</div>
</div><!-- fragment -->
<p>Macro to generate a type trait to check for a method with a specific signature. </p>
<p>Creates has_method_[method] trait that checks if a type has a method with the given name and matches the specified signature (return type and parameters).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Name of the method to check for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe5b5a9d3e17b980b405dce5c0a3dc13" name="abe5b5a9d3e17b980b405dce5c0a3dc13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5b5a9d3e17b980b405dce5c0a3dc13">&#9670;&#160;</a></span>GENERATE_HAS_MEMBER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GENERATE_HAS_MEMBER</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>member</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                                                                      \</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;                                                                \</div>
<div class="line">    <span class="keyword">class </span>HasMember_##member {                                                        \</div>
<div class="line">    <span class="keyword">private</span>:                                                                          \</div>
<div class="line">        <span class="keyword">using </span>Yes = <span class="keywordtype">char</span>[2];                                                          \</div>
<div class="line">        <span class="keyword">using </span>No  = <span class="keywordtype">char</span>[1];                                                          \</div>
<div class="line">                                                                                      \</div>
<div class="line">        <span class="keyword">struct </span>Fallback {                                                             \</div>
<div class="line">            <span class="keywordtype">int</span> member;                                                               \</div>
<div class="line">        };                                                                            \</div>
<div class="line">        <span class="keyword">struct </span>Derived                                                                \</div>
<div class="line">            : T                                                                       \</div>
<div class="line">            , Fallback {};                                                            \</div>
<div class="line">                                                                                      \</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;                                                            \</div>
<div class="line">        <span class="keyword">static</span> No &amp;test(<span class="keyword">decltype</span>(U::member) *);                                       \</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;                                                         \</div>
<div class="line">        <span class="keyword">static</span> Yes &amp;test(U *);                                                        \</div>
<div class="line">                                                                                      \</div>
<div class="line">    <span class="keyword">public</span>:                                                                           \</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> RESULT = <span class="keyword">sizeof</span>(test&lt;Derived&gt;(<span class="keyword">nullptr</span>)) == <span class="keyword">sizeof</span>(Yes); \</div>
<div class="line">    };                                                                                \</div>
<div class="line">                                                                                      \</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;                                                                \</div>
<div class="line">    <span class="keyword">struct </span>has_member_##member                                                        \</div>
<div class="line">        : <span class="keyword">public</span> std::integral_constant&lt;bool, HasMember_##member&lt;T&gt;::RESULT&gt; {};</div>
</div><!-- fragment -->
<p>Macro to generate a type trait to check for a member of any kind. </p>
<p>Creates has_member_[member] trait using a different technique that avoids ambiguity issues in some contexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>Name of the member to check for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab45f03109ecaf5b4c7814df7ed0dd88a" name="ab45f03109ecaf5b4c7814df7ed0dd88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45f03109ecaf5b4c7814df7ed0dd88a">&#9670;&#160;</a></span>GENERATE_HAS_MEMBER_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GENERATE_HAS_MEMBER_TYPE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                                                                      \</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;                                                                \</div>
<div class="line">    <span class="keyword">class </span>HasMemberType_##Type {                                                      \</div>
<div class="line">    <span class="keyword">private</span>:                                                                          \</div>
<div class="line">        <span class="keyword">using </span>Yes = <span class="keywordtype">char</span>[2];                                                          \</div>
<div class="line">        <span class="keyword">using </span>No  = <span class="keywordtype">char</span>[1];                                                          \</div>
<div class="line">                                                                                      \</div>
<div class="line">        <span class="keyword">struct </span>Fallback {                                                             \</div>
<div class="line">            <span class="keyword">struct </span>Type {};                                                           \</div>
<div class="line">        };                                                                            \</div>
<div class="line">        <span class="keyword">struct </span>Derived                                                                \</div>
<div class="line">            : T                                                                       \</div>
<div class="line">            , Fallback {};                                                            \</div>
<div class="line">                                                                                      \</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;                                                            \</div>
<div class="line">        <span class="keyword">static</span> No &amp;test(<span class="keyword">typename</span> U::Type *);                                          \</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;                                                         \</div>
<div class="line">        <span class="keyword">static</span> Yes &amp;test(U *);                                                        \</div>
<div class="line">                                                                                      \</div>
<div class="line">    <span class="keyword">public</span>:                                                                           \</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> RESULT = <span class="keyword">sizeof</span>(test&lt;Derived&gt;(<span class="keyword">nullptr</span>)) == <span class="keyword">sizeof</span>(Yes); \</div>
<div class="line">    };                                                                                \</div>
<div class="line">                                                                                      \</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;                                                                \</div>
<div class="line">    <span class="keyword">struct </span>has_member_type_##Type                                                     \</div>
<div class="line">        : <span class="keyword">public</span> std::integral_constant&lt;bool, HasMemberType_##Type&lt;T&gt;::RESULT&gt; {};</div>
</div><!-- fragment -->
<p>Macro to generate a type trait to check for a member type. </p>
<p>Creates has_member_type_[Type] trait that checks if a type has a nested type definition with the given name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Type</td><td>Name of the type to check for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a href="dir_99176029e6245da7be482686d42cbcde.html">qb</a></li><li class="navelem"><a href="dir_5f381180f4226af1ba60bb26c8f21896.html">utility</a></li><li class="navelem"><a href="type__traits_8h.html">type_traits.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
